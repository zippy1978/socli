schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
scalar BaseballISO8601DateTime
"action_dispatch_uploaded_file"
scalar File
scalar HexColorCode
"An ISO 8601-encoded date"
scalar ISO8601Date
"An ISO 8601-encoded datetime"
scalar ISO8601DateTime
scalar Json
scalar NBAISO8601DateTime
scalar Time
scalar UUID
"ETH amount expressed in wei as a string"
scalar WeiAmount
"Autogenerated return type of acceptOffer."
type acceptOfferPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  deal: TokenDeal
  errors: [UserError!]!
  offer: Offer @deprecated(reason: "Use tokenOffer instead")
  "The sport-agnostic offer"
  tokenOffer: TokenOffer
}
"Autogenerated return type of acceptSo5NoCardLineup."
type acceptSo5NoCardLineupPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  so5NoCardLineup: So5NoCardLineup
}
"Autogenerated return type of acceptTerms."
type acceptTermsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  result: String!
}
"An Account"
type Account implements Node {
  accountable: Accountable!
  id: ID!
  owner: AccountOwner
  sorareManaged: Boolean!
}
"An action reward"
type ActionReward implements Node {
  action: Action!
  id: ID!
  pickSize: Int!
  "The `pickable_players` field cannot be nested within a list."
  pickablePlayers: [PickablePlayer!]!
  "The `reward_cards` field cannot be nested within a list."
  rewardCards: [RewardCard!]!
  shippingState: ShippingState!
}
"Autogenerated return type of activateWalletRecovery."
type activateWalletRecoveryPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of addCardsToDeck."
type addCardsToDeckPayload {
  cards: [Card!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  deck: DeckInterface
  errors: [UserError!]!
}
"Autogenerated return type of addDevice."
type addDevicePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  deliveryType: [Delivery!]
  errors: [UserError!]!
}
"Autogenerated return type of addEmailToList."
type addEmailToListPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
}
"Autogenerated return type of addFavouriteClubs."
type addFavouriteClubsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of addWalletRecovery."
type addWalletRecoveryPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
type Age {
  cutOffDate: ISO8601Date!
  max: Int
  min: Int
}
"An announcement"
type Announcement implements Node {
  content: String!
  createdAt: ISO8601DateTime!
  id: ID!
  sport: Sport
  title: String!
}
"The connection type for Announcement."
type AnnouncementConnection {
  "A list of edges."
  edges: [AnnouncementEdge!]!
  "A list of nodes."
  nodes: [Announcement!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type AnnouncementEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Announcement
}
"A user notification regarding an Announcement"
type AnnouncementNotification implements Node & NotificationInterface {
  announcement: Announcement!
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
  read: Boolean!
  sport: Sport
  user: CurrentUser!
}
"An anonymous User"
type AnonymousUser implements BlockchainUserInterface & Node {
  accounts: [Account!]!
  cardsCount: Int!
  ethVaultId: Int
  ethereumAddress: String!
  id: ID!
  sorareAddress: String
  starkKey: String
  starkKeyRegistered: Boolean! @deprecated(reason: "no longer relevant")
}
"Autogenerated return type of approveMigrator."
type approveMigratorPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
}
"AuctionDrop metadata"
type AuctionDrop {
  endDate: ISO8601DateTime!
  id: String!
  label: String!
  livePrimaryButtonHref: String
  livePrimaryButtonLabel: String
  modalText: String!
  so5TournamentTypes: [So5Tournament!]!
  startDate: ISO8601DateTime!
}
"A user notification regarding an Auction"
type AuctionNotification implements Node & NotificationInterface {
  auction: BundledAuction! @deprecated(reason: "use tokenAuction")
  bid: Bid @deprecated(reason: "use tokenBid")
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
  read: Boolean!
  sport: Sport
  tokenAuction: TokenAuction!
  tokenBid: TokenBid
  user: CurrentUser!
}
type AuthorizationRequest implements Node {
  fingerprint: String!
  id: ID!
  request: Request!
}
type AverageScoreOpenBoundaries {
  averageType: AveragePlayerScore!
  count: Int!
  max: Int
  min: Int
}
"The connection type for BankAccount."
type BankAccountConnection {
  "A list of edges."
  edges: [BankAccountEdge]
  "A list of nodes."
  nodes: [BankAccount]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type BankAccountEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: BankAccount
}
"Banner metadata"
type Banner {
  description: String!
  desktopPictureUrl: String!
  id: String!
  mobilePictureUrl: String!
  title: String!
  url: String!
}
"A collection of banners"
type BannersSet {
  banners: [Banner!]!
  id: String!
  title: String!
}
"A baseball card"
type BaseballCard implements SportsNode & CardInterface {
  assetId: ID!
  token: Token
  id: UUID!
  slug: String!
  owner: User
  player: BaseballPlayer!
  team: BaseballTeam
  rarity: CardRarity!
  season: String!
  serialNumber: Int!
  positions: [BaseballPlayerPosition!]!
  fullImageUrl: String!
  avatarImageUrl: String!
  backImageUrl: String!
  cardLevel: Int!
  xpThresholdForCurrentCardLevel: Int!
  xpThresholdForNextCardLevel: Int
  xp: Int!
  seasonBonus: Float!
  rarityBonus: Float!
  xpBonus: Float!
  totalBonus: Float!
  bonusLossAfterTransfer: Float!
}
type BaseballCardConnection {
  nodes: [BaseballCard!]!
  pageInfo: PageInfo!
}
type BaseballCardCountsByLineupPosition {
  startingPitcherCount: Int!
  reliefPitcherCount: Int!
  cornerInfielderCount: Int!
  middleInfielderCount: Int!
  outfielderCount: Int!
}
type BaseballCardForComposeLineup {
  card: BaseballCard!
  usedInOtherLineup: BaseballLineup
  totalBonusInLineup: Float!
}
type BaseballCardForComposeLineupConnection {
  nodes: [BaseballCardForComposeLineup!]!
  pageInfo: PageInfo!
}
type BaseballCardInLineup implements CardInLineupInterface {
  lineup: BaseballLineup!
  indexInLineup: Int!
  card: BaseballCard!
  playerInFixture: BaseballPlayerInFixture!
  score: Float!
  totalBonus: Float!
  gameScores: [BaseballCardInLineupGameScore!]
}
type BaseballCardInLineupGameScore implements CardInLineupGameScoreInterface {
  score: BaseballScore!
  gameStats: BaseballPlayerGameStats!
  detailedPitchingGameScore: BaseballPlayerGameDetailedPitchingScores
  detailedBattingGameScore: BaseballPlayerGameDetailedBattingScores
}
type BaseballCardsPaginated {
  currentPage: Int!
  pages: Int!
  cards: [BaseballCard!]!
}
type BaseballCollection implements CollectionInterface {
  slug: String!
  isComplete: Boolean!
  slots: [BaseballCollectionSlot!]!
  slotsCount: Int!
  filledSlots: Int!
  team: BaseballTeam
  season: String
}
type BaseballCollectionSlot implements CollectionSlotInterface {
  requiredPlayer: BaseballPlayer!
  ownedCards: [BaseballCard!]
  displayCard: BaseballCard
}
type BaseballCreateOrUpdateLineupResponse {
  createdLineup: BaseballLineup
  lineupValidationErrors: [BaseballCreateOrUpdateLineupValidationError!]!
}
type BaseballFixture implements SportsNode & FixtureInterface {
  id: UUID!
  slug: String!
  fixtureState: FixtureState!
  gameWeek: Int!
  startDate: Time!
  endDate: Time!
  games: [BaseballGame!]!
  leaderboards(includeTraining: Boolean): [BaseballLeaderboard!]!
  myEligibleGames: [BaseballGame!]!
  myLiveLineupGames: [BaseballGameWithCardInLineup!]!
  myLineups: [BaseballLineup!]!
  playerFixtureStats(input: BaseballPlayerFixtureStatsInput!): BaseballPlayerFixtureStatsConnection!
  rewardPool(rarity: BaseballCardRarity, cardRarity: CardRarity, tier: Int!): [BaseballPlayer!]!
  nextFixture: BaseballFixture
  previousFixture: BaseballFixture
}
type BaseballFixtureConnection {
  nodes: [BaseballFixture!]!
  pageInfo: PageInfo!
}
type BaseballGame implements SportsNode & GameInterface {
  id: UUID!
  status: GameStatus!
  startDate: Time!
  homeTeam: BaseballTeam!
  awayTeam: BaseballTeam!
  homeScore: Int!
  awayScore: Int!
  inning: BaseballInning
  homeProbableStartingPitcher: BaseballPlayer
  awayProbableStartingPitcher: BaseballPlayer
  pastPlayerPerformance(playerSlug: String!, last: Int! = 5): [BaseballPlayerGameStats!]!
  gameWeek: Int!
}
type BaseballGameWithCardInLineup implements GameWithCardInLineupInterface {
  game: BaseballGame!
  homeCardsInLineups: [BaseballCardInLineup!]!
  awayCardsInLineups: [BaseballCardInLineup!]!
}
type BaseballInning {
  half: BaseballInningHalf!
  number: Int!
}
type BaseballLeaderboard implements SportsNode & LeaderboardInterface {
  id: UUID!
  slug: String!
  displayName: String!
  displayNameWithoutRarity: String!
  descriptions: [String]!
  lineups(first: Int! = 20, after: String, userId: ID): BaseballLineupConnection!
  myLineups: [BaseballLineup!]!
  lineupsCount: Int!
  fixture: BaseballFixture!
  prizePool: LeaderboardPrizePool!
  requirements: BaseballLeaderboardRequirements!
  leaderboardRarity: LeaderboardRarity!
  isUserEligible: Boolean!
  isTraining: Boolean!
  iconImageUrl: String!
  monochromeIconImageUrl: String!
  myComposeLineupCards(query: String, lineupId: UUID, first: Int! = 20, after: String, includeUsed: Boolean!, indexInLineup: Int!, cardsInLineupPartial: [ID!]!, scoreSortOrder: BaseballComposeLineupCardsScoreSortOrder): BaseballCardForComposeLineupConnection!
  scoringStrategy: String!
}
type BaseballLeaderboardRequirements implements LeaderboardRequirementsInterface {
  allowedRarities: [CardRarity!]!
  minRarity: LeaderboardRulesMinimumRarityRequirement
  minRookieCount: Int!
  playerAgeRequirements: PlayerAgeRequirements
  allowedConference: BaseballConference
  marketplaceQueryParameters: String
}
type BaseballLineup implements SportsNode & LineupInterface {
  id: UUID!
  leaderboard: BaseballLeaderboard!
  cards: [BaseballCardInLineup!]!
  games: [BaseballGameWithCardInLineup!]!
  score: Float!
  rank: Int!
  user: User!
  xpScore: Float! @deprecated(reason: "No longer supported")
  projectedReward: ProjectedReward
  reward: BaseballReward
}
type BaseballLineupConnection {
  nodes: [BaseballLineup!]!
  pageInfo: PageInfo!
}
type BaseballPlayer implements SportsNode & PlayerInterface {
  id: UUID!
  slug: String!
  birthPlaceCountry: String!
  birthDate: Time!
  age: Int!
  displayName: String!
  firstName: String!
  lastName: String!
  shirtNumber: Int!
  positions: [BaseballPlayerPosition!]!
  team: BaseballTeam
  avatarImageUrl: String!
  latestFinalGameStats(last: Int!): [BaseballPlayerGameStats!]!
  latestFixtureStats(last: Int!): [BaseballPlayerInFixture!]!
  fixtureGames(fixtureSlug: String!): [BaseballGame!]! @deprecated(reason: "use PlayerInFixture.upcomingGames")
  upcomingGames(next: Int!): [BaseballGame!]!
  inFixture(fixtureSlug: String!): BaseballPlayerInFixture
  currentSeasonAverageScore: BaseballScore!
  last15AverageScore: BaseballScore! @deprecated(reason: "use BaseballPlayer.last15AverageGameStats.score")
  last15AverageGameStats: BaseballPlayerAverageGameStats!
  isActive: Boolean!
  playerInjury: PlayerInjury
  cards(first: Int! = 100, after: String, positions: [BaseballPlayerPosition!], rarities: [CardRarity!]): BaseballCardConnection!
  pictureUrl: String!
}
type BaseballPlayerAverageGameBattingStats {
  runs: Float
  rbi: Float
  singles: Float
  doubles: Float
  triples: Float
  homeRuns: Float
  walks: Float
  strikeouts: Float
  stolenBases: Float
  hitByPitch: Float
  stealsCaught: Float!
}
type BaseballPlayerAverageGamePitchingStats {
  outs: Float
  strikeouts: Float
  hitsAllowed: Float
  earnedRuns: Float
  walks: Float
  hitBatsmen: Float
  win: Float
  loss: Float
  save: Float
  hold: Float
  reliefAppearance: Float!
}
type BaseballPlayerAverageGameStats {
  score: BaseballScore!
  pitching: BaseballPlayerAverageGamePitchingStats
  batting: BaseballPlayerAverageGameBattingStats
  detailedPitchingScores: BaseballPlayerGameDetailedPitchingScores
  detailedBattingScores: BaseballPlayerGameDetailedBattingScores
}
type BaseballPlayerFixtureStatsConnection {
  nodes: [BaseballPlayerInFixture!]!
  pageInfo: PageInfo!
}
type BaseballPlayerGameBattingStats {
  runs: Int
  rbi: Int
  singles: Int
  doubles: Int
  triples: Int
  homeRuns: Int
  walks: Int
  strikeouts: Int
  stolenBases: Int
  hitByPitch: Int
  stealsCaught: Int!
}
type BaseballPlayerGameDetailedBattingScores {
  runs: Float
  rbi: Float
  singles: Float
  doubles: Float
  triples: Float
  homeRuns: Float
  walks: Float
  strikeouts: Float
  stolenBases: Float
  hitByPitch: Float
  stealsCaught: Float!
}
type BaseballPlayerGameDetailedPitchingScores {
  outs: Float
  strikeouts: Float
  hitsAllowed: Float
  earnedRuns: Float
  walks: Float
  hitBatsmen: Float
  win: Float
  loss: Float
  save: Float
  hold: Float
  reliefAppearance: Float!
}
type BaseballPlayerGamePitchingStats {
  outs: Int
  strikeouts: Int
  hitsAllowed: Int
  earnedRuns: Int
  walks: Int
  hitBatsmen: Int
  win: Int
  loss: Int
  save: Int
  hold: Int
  reliefAppearance: Int!
}
type BaseballPlayerGameStats implements PlayerGameStatsInterface {
  score: BaseballScore!
  playedInGame: Boolean!
  pitching: BaseballPlayerGamePitchingStats
  batting: BaseballPlayerGameBattingStats
  detailedPitchingScores: BaseballPlayerGameDetailedPitchingScores
  detailedBattingScores: BaseballPlayerGameDetailedBattingScores
  game: BaseballGame!
  team: BaseballTeam!
  againstTeam: BaseballTeam!
}
type BaseballPlayerInFixture implements PlayerInFixtureInterface {
  fixture: BaseballFixture!
  player: BaseballPlayer!
  score: BaseballScore!
  status: BaseballPlayerInFixtureStatus!
}
type BaseballPlayerInFixtureStatus implements PlayerInFixtureStatusInterface {
  gameStats: [BaseballPlayerGameStats!]!
  upcomingGames: [BaseballGame!]!
  inGame: Boolean!
  isScoreFinal: Boolean!
  statusIconType: PlayerInFixtureStatusIconType!
  hasTBDGames: Boolean!
  probablePitcherGames: [BaseballGame!]!
}
type BaseballReferralReward implements SportsNode & ReferralRewardInterface {
  id: UUID!
  card: BaseballCard!
  state: RewardState!
}
type BaseballReward implements SportsNode & RewardInterface {
  id: UUID!
  card: BaseballCard!
  backImageUrl: String!
  tier: Int!
  lineup: BaseballLineup!
  state: RewardState!
}
type BaseballScore {
  pitching: Float!
  batting: Float!
}
type BaseballScoutingMission {
  slug: String!
  displayName: String!
  description: String!
  endDate: Time!
  minPlayersRequired: Int!
  isComplete: Boolean!
  slots: [BaseballScoutingMissionSlot!]!
}
type BaseballScoutingMissionSlot {
  requiredPlayer: BaseballPlayer!
  ownedCard: BaseballCard
}
type BaseballTeam implements SportsTeamInterface {
  id: UUID!
  name: String!
  market: String!
  fullName: String!
  slug: String!
  abbreviation: String!
  svgUrl: String!
  monochromeSvgUrl: String!
  teamStyleGuidePrimaryColor: HexColorCode!
  teamStyleGuideSecondaryColor: HexColorCode!
  players: [BaseballPlayer!]!
}
type BeginnerLeaderboardDetails {
  progressionRankPercentageThreshold: Int!
  progressOnReward: CardRarity
  isCompleted: Boolean!
  isVisible: Boolean!
}
"A Bid in an auction"
type Bid implements Node {
  "Bid amount, in auction currency."
  amount: String!
  amounts: MonetaryAmount!
  bidder: BlockchainUser
  createdAt: ISO8601DateTime!
  englishAuction: BundledAuction! @deprecated(reason: "use tokenAuction instead")
  fiatPayment: Boolean!
  id: ID!
  tokenAuction: TokenAuction!
}
"The connection type for Bid."
type BidConnection {
  "A list of edges."
  edges: [BidEdge!]!
  "A list of nodes."
  nodes: [Bid!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}
"An edge in a connection."
type BidEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Bid
}
"Autogenerated return type of bid."
type bidPayload {
  bid: Bid @deprecated(reason: "Use tokenBid instead")
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  "The sport-agnostic bid"
  tokenBid: TokenBid
}
"A bid with conversion rates"
type BidWithRates implements Node {
  "Bid amount, in auction currency."
  amount: String!
  amountInFiat: Fiat!
  amounts: MonetaryAmount!
  bidder: BlockchainUser
  createdAt: ISO8601DateTime!
  englishAuction: BundledAuction! @deprecated(reason: "use tokenAuction instead")
  fiatPayment: Boolean!
  id: ID!
  tokenAuction: TokenAuction!
}
"Autogenerated return type of blockUserOffers."
type blockUserOffersPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"An Auction on a bundle of Cards"
type BundledAuction implements EnglishAuctionInterface & Node {
  bestBid: BidWithRates
  "The `bids` field cannot be nested within a list."
  bids(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BidConnection!
  bidsCount: Int!
  blockchainId: String!
  cancelled: Boolean!
  cards: [Card!]!
  contentProvider: EnglishAuctionContentProvider
  creditCardFee: Float!
  currency: SupportedCurrency!
  "Current price, in auction currency."
  currentPrice: String!
  endDate: ISO8601DateTime!
  id: ID!
  "Minimum next bid amount, in auction currency."
  minNextBid: String!
  "Best bid if the connected user is the best bidder, null otherwise"
  myBestBid: MyBidWithRates
  open: Boolean!
  slug: String!
  startDate: ISO8601DateTime!
  tokenAuction: TokenAuction!
}
"Autogenerated return type of buyDeliverableShopItem."
type buyDeliverableShopItemPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  shopItem: DeliverableShopItem
}
"Autogenerated return type of buyShopItem."
type buyShopItemPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  shopItem: ClubShopItem
}
"A Mangopay Canadian bank account type"
type CaBankAccount implements BankAccountInterface & Node {
  "Account number (last 4 digits)"
  accountNumber: String!
  bankName: String
  "3-digit number assigned to branches of Canadian financial institutions"
  branchCode: String
  country: Country!
  id: ID!
  "3-digit number assigned to Canadian financial institutions"
  institutionNumber: String!
  ownerAddress: MangopayBankAccountOwnerAddress
  ownerName: String
}
"Autogenerated return type of cancelEthBankWithdrawals."
type cancelEthBankWithdrawalsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of cancelFastWithdrawal."
type cancelFastWithdrawalPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  fastWithdrawal: FastWithdrawal
}
"Autogenerated return type of cancelOffer."
type cancelOfferPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  offer: Offer @deprecated(reason: "Use tokenOffer instead")
  "The sport-agnostic offer"
  tokenOffer: TokenOffer
}
"Autogenerated return type of cancelWithdrawal."
type cancelWithdrawalPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  withdrawal: Withdrawal
}
"A card representing a professional football player"
type Card implements CardGameInterface & CardMarketInterface & Node & WithSubscriptionsInterface {
  age: Int
  "All player So5Scores ordered by descending game date"
  allSo5Scores(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): So5ScoreConnection!
  assetId: String
  availableCardBoosters: [ClubShopItem!]!
  availableCardBoosts: [CardBoost!]!
  availableUserShopItems: [UserShopItem!]! @deprecated(reason: "Use availableCardBoosters")
  averageScore(type: AveragePlayerScore!): Float
  backPictureUrl: String!
  birthTxHash: String
  blockchain: String!
  blockchainId: String
  canBuy: Boolean! @deprecated(reason: "Use `Token.tradeableStatus` instead")
  cardCollectionCards: [CardCollectionCard!]!
  coverageStatus: CardCoverageStatus!
  createdAt: ISO8601DateTime!
  currentUserSubscription: EmailSubscription
  customCardEditionName: String
  customDecks: [CustomDeck!]!
  displayRarity: String!
  "Current card fitness bonus"
  fitnessBonus: Float
  gameForLeague(so5LeaderboardSlug: String = null, so5LeagueSlug: String = null): Game
  "Current card level"
  grade: Int!
  gradeAfterTransfer: Int!
  id: ID!
  inRollup: Boolean!
  latestEnglishAuction: EnglishAuction @deprecated(reason: "Use `Token.latestEnglishAuction` instead")
  levelUpAppliedCount: Int!
  liveSingleBuyOffers: [Offer!]! @deprecated(reason: "Use `Token.liveSingleBuyOffers` instead")
  liveSingleSaleOffer: SingleSaleOffer @deprecated(reason: "Use `Token.liveSingleSaleOffer` instead")
  "So5Lineup that this card is being used in for the live So5Fixture"
  liveSo5Lineup: So5Lineup
  liveStarterPack: StarterPack
  maxLevelUpAppliedCount: Int!
  myMintedSingleSaleOffer: SingleSaleOffer @deprecated(reason: "Use `Token.myMintedSingleSaleOffer` instead")
  name: String!
  notContractOwners: [OwnerWithRates!]!
  onSale: Boolean! @deprecated(reason: "Use `token` fields instead")
  openEnglishAuction: EnglishAuction @deprecated(reason: "Use `token` fields instead")
  openForDomesticStats: Boolean!
  openForGameStats: Boolean!
  openForGameStatsCompetitions: [Competition!]!
  openedSo5Lineup: So5Lineup @deprecated(reason: "Use Card.openedSo5Lineups instead")
  "So5Lineups that this card is being used in for the opened So5Fixtures"
  openedSo5Lineups: [So5Lineup!]!
  owner: Owner
  ownerSince: ISO8601DateTime
  ownerWithRates: OwnerWithRates
  pendingWithdrawal: StarkwareWithdrawal
  pictureUrl(derivative: String = "tinified"): String
  player: Player!
  position: String! @deprecated(reason: "Use the typed version instead: positionTyped")
  positionTyped: Position!
  "Total card bonus (XP + Season bonus)"
  power(so5LeaderboardSlug: String = null): String!
  powerBreakdown(so5LeaderboardSlug: String = null): PowerBreakdown!
  powerMalusAfterTransfer: String!
  privateMinPrice: String @deprecated(reason: "Use `Token.privateMinPrice` instead")
  publicMinPrice: String @deprecated(reason: "Use `Token.publicMinPrice` instead")
  rarity: String!
  season: Season!
  serialNumber: Int!
  shirtNumber: Int
  singleCivilYear: Boolean!
  slug: String!
  "Up to 10 last So5Scores used in a So5Fixture"
  so5Scores(last: Int!, lowCoverage: Boolean = true): [So5Score]!
  starkwareTokenId: String
  subscriptionsCount: Int!
  team: Team!
  token: Token
  tradeableStatus: Tradeable!
  u23Eligible: Boolean!
  user: User
  userOwner: UserOwner
  visible: Boolean!
  walletStatus: WalletStatus!
  xp: Int!
  xpAfterTransfer: Int!
  "XP start range of current card level"
  xpNeededForCurrentGrade: Int!
  "XP end range of current card level"
  xpNeededForNextGrade: Int
}
type CardBoost {
  id: String!
  levelToReach: Int!
  shopItem: ClubShopItem!
  xpToGain: Int!
}
"A collection of cards"
type CardCollection implements Node {
  backgroundPictureUrl: String
  bannerPictureUrl: String
  "The `best_by_completed_at` field cannot be nested within a list."
  bestByCompletedAt(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCardCollectionConnection!
  "The `best_by_score` field cannot be nested within a list."
  bestByScore(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCardCollectionConnection!
  bonusThresholds: [CardCollectionBonusThreshold!]!
  complete(forUserSlug: String!): Boolean! @deprecated(reason: "Use the UserCardCollection field instead")
  emptySlotBackgroundPictureUrl: String
  fulfilledSlotsCount(forUserSlug: String!): Int! @deprecated(reason: "Use the UserCardCollection field instead")
  id: ID!
  name: String!
  rarity: Rarity
  "The `related_shield` field cannot be nested within a list."
  relatedShield: SkinShopItem
  scoreRankingSize: Int!
  season: Season
  slots: [CardCollectionSlot!]!
  slotsCount: Int!
  slug: String!
  "The `social_picture_urls` field cannot be nested within a list."
  socialPictureUrls(forUserSlug: String!): SocialPictureDerivative!
  subtitle: String!
  team: Team
  userCardCollection(forUserSlug: String!): UserCardCollection
}
"A card collection bonus threshold"
type CardCollectionBonusThreshold {
  bonus: Float!
  threshold: Float!
}
"A card in a collection of cards"
type CardCollectionCard implements Node {
  card: Card!
  cardCollection: CardCollection!
  heldSince: ISO8601DateTime!
  highlighted: Boolean
  id: ID!
  scoreBreakdown: CardCollectionCardScoreBreakdown!
}
"An object representing the breakdown of the score of a Card in a Card Collection"
type CardCollectionCardScoreBreakdown {
  firstOwner: Int!
  firstSerialNumber: Int!
  holding: Int!
  owner: Int!
  shirtMatchingSerialNumber: Int!
  specialEdition: Int!
  total: Int!
}
"The connection type for CardCollection."
type CardCollectionConnection {
  "A list of edges."
  edges: [CardCollectionEdge!]!
  "A list of nodes."
  nodes: [CardCollection!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  raritiesCount: [RarityCount!]!
  seasonsCount: [SeasonCount!]!
  totalCount: Int!
}
"An edge in a connection."
type CardCollectionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CardCollection
}
"A user notification regarding a Card Collection"
type CardCollectionNotification implements Node & NotificationInterface {
  card: Card
  cardCollection: CardCollection!
  cardCollectionSlot: CardCollectionSlot
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
  read: Boolean!
  shieldShopItem: SkinShopItem
  sport: Sport
  user: CurrentUser!
}
"A card collection requirement on a shop item"
type CardCollectionRequirement {
  cardCollection: CardCollection!
  score: Int!
}
"A slot in a collection of cards"
type CardCollectionSlot implements Node {
  cardCollectionCards(forUserSlug: String!): [CardCollectionCard!]!
  cardPictureUrl: String!
  customCardEditionName: String
  displayedRequirements: String
  id: ID!
  player: Player!
  rarity: Rarity
  season: Season
  serialNumber: Int
  team: Team
  transferMarketFilters: String!
}
"The connection type for Card."
type CardConnection {
  "A list of edges."
  edges: [CardEdge!]!
  "A list of nodes."
  nodes: [Card!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"A user card count breakdown"
type CardCount {
  common: Int!
  customSeries: Int!
  limited: Int!
  rare: Int!
  superRare: Int!
  total: Int!
  unique: Int!
}
type CardCountsByRarity {
  uniqueCount: Int!
  superRareCount: Int!
  rareCount: Int!
  limitedCount: Int!
  commonCount: Int!
}
"A card dropped during onboarding"
type CardDrop {
  pictureUrl: String!
  slug: String!
}
"An edge in a connection."
type CardEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Card
}
"Represents a card edition"
type CardEdition implements Node & WithPublicCardsInterface {
  "The `cards` field cannot be nested within a list."
  cards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,age: Int, assetIds: [String!], 
    "Returns the elements in the list that come before the specified cursor."
    before: String,customCardEditionName: String, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): CardConnection!
  displayName: String!
  id: ID!
  name: String!
}
"Enforces restrictions on specific card editions of submitted lineups"
type CardEditionCount {
  "The display name of the card edition on which this rule would apply"
  displayName: String!
  max: Int
  min: Int
  "The name of the card edition on which this rule would apply"
  name: String!
}
"Enforces restrictions on card editions of submitted lineups"
type CardEditionsCount {
  "Card editions on which restrictions are applied with their additional restrictions, if any"
  editions: [CardEditionCount!]!
  max: Int
  min: Int
}
"Represents a card layout"
type CardLayout {
  backgroundMaskUrl: String
  backgroundUrl: String
  cardDesign: CardDesign
  layerUrl: String @deprecated(reason: "Use layers instead")
  layers: [String!]!
  playerMaskUrl: String
  teamLogoUrl: String @deprecated(reason: "Legacy")
}
"A user notification regarding a Card"
type CardNotification implements Node & NotificationInterface {
  card: Card
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
  read: Boolean!
  sport: Sport
  token: Token
  tokenWithdrawal: TokenWithdrawal
  user: CurrentUser!
  withdrawal: StarkwareWithdrawal
}
type CardReward {
  id: UUID!
  card: CardInterface!
  backImageUrl: String!
  tier: Int!
  lineup: LineupInterface!
  state: RewardState!
}
"The supply of cards for a Player in a Season"
type CardSeasonSupply {
  limited: Int!
  player: Player!
  rare: Int!
  season: Season!
  superRare: Int!
  unique: Int!
}
"A card representing a professional football player"
type CardSubscription implements CardGameInterface & CardMarketInterface & Node & WithSubscriptionsInterface {
  age: Int
  "All player So5Scores ordered by descending game date"
  allSo5Scores(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): So5ScoreConnection!
  assetId: String
  availableCardBoosters: [ClubShopItem!]!
  availableCardBoosts: [CardBoost!]!
  availableUserShopItems: [UserShopItem!]! @deprecated(reason: "Use availableCardBoosters")
  averageScore(type: AveragePlayerScore!): Float
  backPictureUrl: String!
  birthTxHash: String
  blockchain: String!
  blockchainId: String
  canBuy: Boolean! @deprecated(reason: "Use `Token.tradeableStatus` instead")
  cardCollectionCards: [CardCollectionCard!]!
  coverageStatus: CardCoverageStatus!
  createdAt: ISO8601DateTime!
  currentUserSubscription: EmailSubscription
  customCardEditionName: String
  customDecks: [CustomDeck!]!
  displayRarity: String!
  eventType: CardWasUpdatedEvent!
  "Current card fitness bonus"
  fitnessBonus: Float
  gameForLeague(so5LeaderboardSlug: String = null, so5LeagueSlug: String = null): Game
  "Current card level"
  grade: Int!
  gradeAfterTransfer: Int!
  id: ID!
  inRollup: Boolean!
  latestEnglishAuction: EnglishAuction @deprecated(reason: "Use `Token.latestEnglishAuction` instead")
  levelUpAppliedCount: Int!
  liveSingleBuyOffers: [Offer!]! @deprecated(reason: "Use `Token.liveSingleBuyOffers` instead")
  liveSingleSaleOffer: SingleSaleOffer @deprecated(reason: "Use `Token.liveSingleSaleOffer` instead")
  "So5Lineup that this card is being used in for the live So5Fixture"
  liveSo5Lineup: So5Lineup
  liveStarterPack: StarterPack
  maxLevelUpAppliedCount: Int!
  myMintedSingleSaleOffer: SingleSaleOffer @deprecated(reason: "Use `Token.myMintedSingleSaleOffer` instead")
  name: String!
  notContractOwners: [OwnerWithRates!]!
  onSale: Boolean! @deprecated(reason: "Use `token` fields instead")
  openEnglishAuction: EnglishAuction @deprecated(reason: "Use `token` fields instead")
  openForDomesticStats: Boolean!
  openForGameStats: Boolean!
  openForGameStatsCompetitions: [Competition!]!
  openedSo5Lineup: So5Lineup @deprecated(reason: "Use Card.openedSo5Lineups instead")
  "So5Lineups that this card is being used in for the opened So5Fixtures"
  openedSo5Lineups: [So5Lineup!]!
  owner: Owner
  ownerSince: ISO8601DateTime
  ownerWithRates: OwnerWithRates
  pendingWithdrawal: StarkwareWithdrawal
  pictureUrl(derivative: String = "tinified"): String
  player: Player!
  position: String! @deprecated(reason: "Use the typed version instead: positionTyped")
  positionTyped: Position!
  "Total card bonus (XP + Season bonus)"
  power(so5LeaderboardSlug: String = null): String!
  powerBreakdown(so5LeaderboardSlug: String = null): PowerBreakdown!
  powerMalusAfterTransfer: String!
  privateMinPrice: String @deprecated(reason: "Use `Token.privateMinPrice` instead")
  publicMinPrice: String @deprecated(reason: "Use `Token.publicMinPrice` instead")
  rarity: String!
  season: Season!
  serialNumber: Int!
  shirtNumber: Int
  singleCivilYear: Boolean!
  slug: String!
  "Up to 10 last So5Scores used in a So5Fixture"
  so5Scores(last: Int!, lowCoverage: Boolean = true): [So5Score]!
  starkwareTokenId: String
  subscriptionsCount: Int!
  team: Team!
  token: Token
  tradeableStatus: Tradeable!
  u23Eligible: Boolean!
  user: User
  userOwner: UserOwner
  visible: Boolean!
  walletStatus: WalletStatus!
  xp: Int!
  xpAfterTransfer: Int!
  "XP start range of current card level"
  xpNeededForCurrentGrade: Int!
  "XP end range of current card level"
  xpNeededForNextGrade: Int
}
type CashReward {
  id: UUID!
  lineup: LineupInterface!
  state: RewardState!
}
"A challenge"
type Challenge implements Node {
  completed: Boolean
  description: String!
  id: ID!
}
"A Head to Head manager with information about his lineup being registered"
type Challenger {
  composed: Boolean!
  id: String!
  manager: FootballHeadToHeadManager!
}
"The connection type for Challenger."
type ChallengerConnection {
  "A list of edges."
  edges: [ChallengerEdge!]!
  "A list of nodes."
  nodes: [Challenger!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ChallengerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Challenger
}
"Autogenerated return type of changePassword."
type changePasswordPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser!
  errors: [UserError!]!
}
"Autogenerated return type of checkPhoneNumberVerificationCode."
type checkPhoneNumberVerificationCodePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of claimAward."
type claimAwardPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of claimCardDrop."
type claimCardDropPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of claimConversionCredit."
type claimConversionCreditPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  conversionCredit: ConversionCredit
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of claimFootballManagerTask."
type claimFootballManagerTaskPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  footballManagerTask: FootballManagerTask
}
"Autogenerated return type of claimReferralReward."
type claimReferralRewardPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  referralReward: ReferralReward
}
"Autogenerated return type of claimReward."
type claimRewardPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  so5Reward: So5Reward
}
"Autogenerated return type of claimRewards."
type claimRewardsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  so5Rewards: [So5Reward!]
}
"A Clan feed item type"
type ClanFeedItem implements FeedItemInterface & Node {
  appearance: SorareDailyAppearance
  id: ID!
  itemDate: ISO8601DateTime!
  itemType: ClanFeedItemType!
  lineup: SorareDailyLineup!
}
type Club implements Node & TeamInterface & WithSubscriptionsInterface {
  activeCompetitions: [Competition!]!
  "The `active_memberships` field cannot be nested within a list."
  activeMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MembershipConnection!
  "The `active_players` field cannot be nested within a list."
  activePlayers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PlayerConnection!
  "The `cards` field cannot be nested within a list."
  cards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,age: Int, assetIds: [String!], 
    "Returns the elements in the list that come before the specified cursor."
    before: String,customCardEditionName: String, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): CardConnection!
  code: String
  country: Country!
  currentUserSubscription: EmailSubscription
  customBanner: CustomBanner
  dataPartner: DataPartner
  domesticLeague: Competition
  founded: String
  "The `games` field cannot be nested within a list."
  games(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "End time (inclusive) of the game."
    endDate: ISO8601DateTime!,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Start time (inclusive) of the game."
    startDate: ISO8601DateTime!
  ): GameConnection!
  id: ID!
  lastFiveGames: [Game!]!
  "The `latest_games` field cannot be nested within a list."
  latestGames(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GameConnection!
  name: String!
  optaId: String
  pictureSecondaryUrl: String
  pictureUrl(derivative: String = "low_res"): String
  "The `players` field cannot be nested within a list."
  players(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PlayerConnection!
  ready: Boolean!
  "The `recent_departures` field cannot be nested within a list."
  recentDepartures(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PlayerConnection!
  "Returns the top 3 of the league, excluding the current club"
  relatedClubs: [Club!]
  shortName: String!
  slug: String!
  subscriptionsCount: Int!
  upcomingGames(first: Int!): [Game]!
}
"The connection type for Club."
type ClubConnection {
  "A list of edges."
  edges: [ClubEdge!]!
  "A list of nodes."
  nodes: [Club!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ClubEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Club
}
"The connection type for ClubShopItem."
type ClubShopItemConnection {
  "A list of edges."
  edges: [ClubShopItemEdge!]!
  "A list of nodes."
  nodes: [ClubShopItem!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}
"An edge in a connection."
type ClubShopItemEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClubShopItem
}
"A Common Account"
type CommonAccount implements Node {
  id: ID!
}
"A common draft campaign"
type CommonDraftCampaign {
  autoPick(selectedPrintablePlayerIds: [ID!]): [DraftablePlayer!]!
  "The `available_players` field cannot be nested within a list."
  availablePlayers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "The position to filter on or empty for the extra positions"
    position: Position,
    "Full text search query to filter cards"
    query: String,selectedPrintablePlayerIds: [ID!], sortType: AvailableDraftPlayersSortInput, teamSlugs: [String!], value: RangeInput  ): DraftablePlayerConnection!
  availableSwapsCountForUpcoming: Int!
  budget: Int!
  campaignType: CommonDraftCampaignType!
  competitions: [Competition!]!
  displayName: String!
  "The `drafted_players` field cannot be nested within a list."
  draftedPlayers: [DraftablePlayer!]!
  maxDraftablePlayerValue: Int!
  maximumSwapsCountForUpcoming: Int!
  positions: [Position!]!
  slug: String!
  status: CommonDraftCampaignStatus!
  swappablePlayers: [SwappablePlayer!]
  teams: [Team!]!
  upcomingSo5Leaderboard: So5Leaderboard
  upcomingSwaps: [CommonDraftSwap!]!
}
"Swaps that have been done for a common draft"
type CommonDraftSwap implements Node {
  id: ID!
  swappedPlayersIn: [SwappablePlayer!]!
  swappedPlayersOut: [SwappablePlayer!]!
}
"A professional football competition"
type Competition implements CompetitionGraphicalIdentityInterface & Node {
  backgroundColor: String
  backgroundPictureUrl: String
  "The `clubs` field cannot be nested within a list."
  clubs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClubConnection!
  "The `contestants` field cannot be nested within a list."
  contestants(seasonStartYear: Int!): [Contestant!]!
  country: Country
  customBanner: CustomBanner
  displayName: String!
  featuredCardPictureUrls: [String!]
  featuredPlayer: PickablePlayer
  format: CompetitionFormat!
  id: ID!
  logoUrl: String
  name: String!
  openForGameStats: Boolean!
  pictureUrl(derivative: String = "low_res"): String
  "The `players_by_last_five_average` field cannot be nested within a list."
  playersByLastFiveAverage(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PlayerConnection!
  released: Boolean!
  "The `seasons` field cannot be nested within a list."
  seasons: [Season!]!
  slug: String!
  type: CompetitionType!
}
"Autogenerated return type of completeOnboardingTask."
type completeOnboardingTaskPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"The frontend config"
type Config {
  algoliaApplicationId: String!
  algoliaIndexSuffix: String!
  algoliaSearchApiKey: String!
  bankAddress: String!
  banners: [BannersSet!]!
  baseballTokensAddress: String!
  counts: Counts!
  currentLocation: Location!
  defaultFiatCurrency: FiatCurrency!
  "Countries where Sorare can deliver goods"
  deliverableCountries: [Country!]!
  ethAssetType: String!
  ethQuantum: String!
  ethereumEndpoint: String!
  ethereumNetworkId: String!
  exchangeRate: ExchangeRate!
  "Countries where Sorare's Fiat Wallet is supported."
  fiatWalletCountries: [Country!]!
  footballNationalSeriesTokensAddress: String!
  frontendAssetsHost: String! @deprecated(reason: "Not used anymore")
  heroBanners: [HeroBannersSet!]!
  id: ID!
  landingClubCount: String!
  landingClubs: [LandingClub!]!
  landingTheme: LandingTheme
  marketFeeRateBasisPoints(sport: Sport): Int!
  marketplacePromotionalEvents: [MarketplacePromotionalEvents!]!
  migratorAddress: String
  minimumReceiveWeiAmount: WeiAmount!
  nbaTokensAddress: String!
  referralCampaign: ReferralCampaign
  relayAddress: String!
  responsiveBanners: [ResponsiveBannersSet!]!
  so5: So5Config!
  sorareCardsAddress: String!
  sorareEncryptionKey: String!
  sorareTokensAddress: String!
  sponsorAccountAddress: String!
  starkExchangeAddress: String
  stripePublicKey: String!
  walletChallenge: String!
  walletUrl: String! @deprecated(reason: "Not used anymore")
}
"Autogenerated return type of confirmDevice."
type confirmDevicePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of confirmEmail."
type confirmEmailPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of confirmSo5Lineups."
type confirmSo5LineupsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  so5Lineups: [So5Lineup!]!
}
"Autogenerated return type of confirmSo5NoCardLineup."
type confirmSo5NoCardLineupPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  so5NoCardLineup: So5NoCardLineup
}
"OAuth account connected by the user."
type ConnectedOAuth implements Node {
  email: String!
  id: ID!
  provider: OAuthProvider!
}
"Autogenerated return type of consumeCardBooster."
type consumeCardBoosterPayload {
  card: Card
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
}
"Autogenerated return type of consumeEphemeralToken."
type consumeEphemeralTokenPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  "Where to redirect the user"
  redirectUrl: String
}
"Autogenerated return type of consumeRecoveryKit."
type consumeRecoveryKitPayload {
  card: Card
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
}
"Metadata for a content unit"
type ContentUnit {
  id: String!
  illustrationUrl: String
  primaryButtonLabel: String!
  primaryButtonUrl: String!
  secondaryButtonLabel: String!
  secondaryButtonUrl: String!
  subtitle: String
  title: String!
  videoUrl: String
}
"Collection of content unit banners"
type ContentUnitsSet {
  contentUnits: [ContentUnit!]!
  id: String!
}
"A contestant"
type Contestant implements Node {
  id: ID!
  matchesDrawn: Int
  matchesLost: Int
  matchesPlayed: Int
  matchesWon: Int
  points: Int
  rank: Int
  team: Team!
}
"A smart contract"
type Contract implements Node {
  addressHex: String!
  blockchain: String!
  id: ID!
  name: String!
}
"A conversion credit"
type ConversionCredit implements Node {
  endDate: ISO8601DateTime!
  id: ID!
  maxDiscount: MonetaryAmount!
  percentageDiscount: Float!
  sport: Sport
  status: ConversionCreditStatus!
}
"A conversion credit campaign"
type ConversionCreditCampaign implements Node {
  campaignCode: String!
  endDate: ISO8601DateTime!
  id: ID!
  maxDiscount: MonetaryAmount!
  percentageDiscount: Float!
  sport: Sport
  status: ConversionCreditCampaignStatus!
}
"A country"
type Country implements Node & WithSubscriptionsInterface {
  "Country code in ISO 3166-1 format."
  code: String!
  currentUserSubscription: EmailSubscription
  flagUrl(shape: String, size: Int): String!
  id: ID!
  slug: String!
  subscriptionsCount: Int!
  threeLetterCode: String
}
"Some Stats"
type Counts {
  football: FootballCounts!
  usersCount: Int!
}
"Autogenerated return type of createCardAuthorization."
type createCardAuthorizationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  secureModeRedirectUrl: String
}
"Autogenerated return type of createCardDeposit."
type createCardDepositPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  secureModeRedirectUrl: String
}
"Autogenerated return type of createCardRegistration."
type createCardRegistrationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  preRegistrationData: PreRegistrationData
}
"Autogenerated return type of createCardWithdrawal."
type createCardWithdrawalPayload {
  card: Card
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  token: Token
}
"Autogenerated return type of createCommonDraftSwap."
type createCommonDraftSwapPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  commonDraftCampaign: CommonDraftCampaign
  errors: [UserError!]!
  swapError: So5CommonDraftSwapError
}
"Autogenerated return type of createCustomDeck."
type createCustomDeckPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  deck: CustomDeck
  errors: [UserError!]!
}
"Autogenerated return type of createDepositBankAccountMutation."
type createDepositBankAccountMutationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of createDirectOffer."
type createDirectOfferPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  offer: Offer @deprecated(reason: "Use tokenOffer instead")
  "The sport-agnostic offer"
  tokenOffer: TokenOffer
}
"Autogenerated return type of createDraftAndSo5Lineup."
type createDraftAndSo5LineupPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  so5Lineup: So5Lineup
}
"Autogenerated return type of createEphemeralLink."
type createEphemeralLinkPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  "The resulting URL if there was no error"
  url: String
}
"Autogenerated return type of createEthBankWithdrawalIntent."
type createEthBankWithdrawalIntentPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  ethBankWithdrawalIntent: EthBankWithdrawalIntent
}
"Autogenerated return type of createEthDeposit."
type createEthDepositPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of createEthMigration."
type createEthMigrationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of createEthVault."
type createEthVaultPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of createFastWithdrawal."
type createFastWithdrawalPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of createFiatPayer."
type createFiatPayerPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of createFiatWallet."
type createFiatWalletPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of createFiatWithdrawal."
type createFiatWithdrawalPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  withdrawal: MangopayWithdrawal
}
"Autogenerated return type of createIdentityVerificationSession."
type createIdentityVerificationSessionPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  verificationSession: VerificationSession
}
"Autogenerated return type of createOrUpdateSingleBuyOfferMinPrice."
type createOrUpdateSingleBuyOfferMinPricePayload {
  card: Card @deprecated(reason: "use token")
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  token: Token
}
"Autogenerated return type of createOrUpdateSo5Lineup."
type createOrUpdateSo5LineupPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  so5Lineup: So5Lineup
}
"Autogenerated return type of createSingleBuyOffer."
type createSingleBuyOfferPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  offer: Offer @deprecated(reason: "Use tokenOffer instead")
  "The sport-agnostic offer"
  tokenOffer: TokenOffer
}
"Autogenerated return type of createSingleSaleOffer."
type createSingleSaleOfferPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  offer: SingleSaleOffer @deprecated(reason: "use tokenOffer instead")
  "The sport-agnostic offer"
  tokenOffer: TokenOffer
}
"Autogenerated return type of createSo5UserGroup."
type createSo5UserGroupPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  so5UserGroup: So5UserGroup
}
"Autogenerated return type of createSubscription."
type createSubscriptionPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  subscription: EmailSubscription
}
"Autogenerated return type of createWallet."
type createWalletPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser!
  errors: [UserError!]!
}
"Autogenerated return type of createWireTransferDeposit."
type createWireTransferDepositPayload {
  bankAccount: BankAccount
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  wireReference: String
}
"Autogenerated return type of createWithdrawalBankAccount."
type createWithdrawalBankAccountPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  mangopayBankAccount: BankAccount
}
"Autogenerated return type of createWithdrawal."
type createWithdrawalPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  withdrawal: Withdrawal
}
"Credit Card"
type CreditCard {
  brand: CreditCardBrand!
  expMonth: Int!
  expYear: Int!
  last4: String!
}
type CumulativeLeaderboard {
  slug: String!
  displayName: String!
  displayNameWithoutRarity: String!
  iconImageUrl: String!
  startGameWeek: Int!
  endGameWeek: Int!
  currentCumulativeGameWeek: Int!
  cumulativeLeaderboardRanks(first: Int! = 20, after: String): CumulativeLeaderboardRankConnection!
  myCumulativeLeaderboardRank: CumulativeLeaderboardRank
  prizeLevels: [PrizeCreditsLevel!]!
  participantsCount: Int!
  leaderboardRarity: LeaderboardRarity!
  myLineups: [LineupInterface!]!
  webUrl: String
}
type CumulativeLeaderboardRank {
  id: UUID!
  user: User!
  score: Float!
  rank: Int!
  lineups: [LineupInterface]!
  cumulativeLeaderboard: CumulativeLeaderboard!
  projectedPrizeCredits: Int
}
type CumulativeLeaderboardRankConnection {
  nodes: [CumulativeLeaderboardRank!]!
  pageInfo: PageInfo!
}
"Current Sorare Daily manager"
type CurrentManager implements PublicManagerInterface {
  availableBoosts: [SorareDailyBoost!]!
  coinBalance: Int!
  dailyCoinsToClaim: Int!
  division: Int!
  id: ID!
  myLiveClan: SorareDailyClan
  myLiveDivisionLeaderboard: SorareDailyDivisionLeaderboard
  nickname: String!
  packs: [SorareDailyPack!]!
  pictureUrl(derivative: String = "low_res"): String
}
type CurrentNBAUser {
  id: UUID!
  nbaCurrentUserData: NBACurrentUserData!
  nbaCards(first: Int! = 100, after: String): NBACardConnection!
  unclaimedRewards: [NBAReward!]
}
type CurrentSportsUser implements UserInterface {
  id: ID!
  slug: String!
  nickname: String!
  nbaCards(first: Int = 100, after: String, positions: [NBAPlayerPosition!], rarities: [CardRarity!]): NBACardConnection!
  nbaCurrentUserData: NBACurrentUserData!
  nbaUnclaimedLineupRewards: [NBAReward!]!
  nbaCardCounts: CardCountsByRarity!
  nbaLeagues: [NBALeague!]!
  nbaCollections(slugsFilter: [String!]): [NBACollection!]!
  baseballCards(first: Int! = 100, after: String, positions: [BaseballPlayerPosition!], rarities: [CardRarity!]): BaseballCardConnection!
  baseballCardCounts: CardCountsByRarity!
  baseballCardCountsByLineupPosition(rarities: [CardRarity!]): BaseballCardCountsByLineupPosition!
  baseballUnclaimedLineupRewards: [BaseballReward!]!
  baseballScoutingMissions: [BaseballScoutingMission!]! @deprecated(reason: "unsupported")
  baseballCollections(slugsFilter: [String!]): [BaseballCollection!]!
}
"Current Sorare user"
type CurrentUser implements PublicUserInfoInterface & So5CurrentUserInterface & UserOffersInterface & UserSocialInterface & WithFastWithdrawal & WithFavoriteInterface & WithNotifications & WithReferralsInterface & UserInterface {
  accountEntries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,currencyType: Currency, endDate: ISO8601DateTime, entryType: [UserAccountEntryEntry!], 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,significant: Boolean, sortType: SortingOption, startDate: ISO8601DateTime  ): UserAccountEntryConnection!
  accounts: [Account!]!
  active: Boolean
  activeMintingQuota: MintingQuota @deprecated(reason: "legacy")
  apiKey: String
  "Current user available balance, in wei."
  availableBalance: String!
  "Current user available balance for withdrawal, in wei."
  availableBalanceForWithdrawal: String!
  availableConversionCredit: ConversionCredit
  awards(category: AwardCategory): [UserAward!]! @deprecated(reason: "Use football manager tasks instead")
  "Current user bank balance, in wei."
  bankBalance: String!
  bankMappedEthereumAddress: String
  bankMappedEthereumAddressApprovedBank: Boolean
  baseballProfile: UserSportProfile
  betaTester: Boolean!
  "List of current user blockchain football cards engaged in lineups (for live or upcoming fixtures)"
  blockchainCardsInLineups: [String!]!
  blockedUntil: ISO8601DateTime
  blockedUsers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserConnection!
  "The `bought_single_sale_offers` field cannot be nested within a list."
  boughtSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use boughtSingleSaleTokenOffers instead")
  "The `bought_single_sale_token_offers` field cannot be nested within a list."
  boughtSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  "The `buying_english_auctions` field cannot be nested within a list."
  buyingEnglishAuctions(
    "Returns auctions sorted by `startDate` in descending order when set."
    newlyListed: Boolean
  ): [EnglishAuction!]! @deprecated(reason: "use buyingTokenAuctions instead")
  "The `buying_token_auctions` field cannot be nested within a list."
  buyingTokenAuctions(
    "Returns auctions sorted by `startDate` in descending order when set."
    newlyListed: Boolean,sport: [Sport!]  ): [TokenAuction!]!
  cardCounts: CardCount!
  cardFilters(sport: Sport!): Json!
  cardsCount: Int!
  coinBalance: Int!
  "Whether the user confirmed their email"
  confirmed: Boolean
  confirmedDevice: Boolean!
  connectedOAuthAccessTokens: [OAuthAccessToken!]
  connectedOauths: [ConnectedOAuth!]
  createdAt: ISO8601DateTime!
  "Current device used for this query"
  currentDevice: UserDevice
  "The `custom_decks` field cannot be nested within a list."
  customDecks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Full text search query to filter custom decks"
    query: String
  ): CustomDeckConnection!
  depositedEth: Boolean!
  "Can only be retrieved from a confirmed device"
  devices: [UserDevice!]
  directOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,direction: OfferDirection!, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption  ): OfferConnection! @deprecated(reason: "Use tokenOffers")
  "Set to true if the account has been deleted or suspended"
  disabled: Boolean! @deprecated(reason: "Use suspended instead")
  email: String!
  endedDirectOffersReceived(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption  ): OfferConnection! @deprecated(reason: "Use endedTokenOffersReceived")
  endedDirectOffersSent(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption  ): OfferConnection! @deprecated(reason: "Use endedTokenOffersSent")
  endedTokenOffersReceived(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption, sport: [Sport!] = [FOOTBALL, BASEBALL, NBA], states: [OfferState!]  ): TokenOfferConnection!
  endedTokenOffersSent(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption, sport: [Sport!] = [FOOTBALL, BASEBALL, NBA], states: [OfferState!]  ): TokenOfferConnection!
  "The `ended_with_no_buyer_single_sale_offers` field cannot be nested within a list."
  endedWithNoBuyerSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use endedWithNoBuyerSingleSaleTokenOffers instead")
  "The `ended_with_no_buyer_single_sale_token_offers` field cannot be nested within a list."
  endedWithNoBuyerSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  "The `english_auctions` field cannot be nested within a list."
  englishAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): EnglishAuctionConnection! @deprecated(reason: "use tokenAuctions instead")
  ethMigration: EthMigration
  ethVaultId: Int
  ethereumAddress: String
  "Get a starkware conditional transfer request for a fast withdrawal"
  fastWithdrawal(
    "Amount to withdraw, in wei."
    amount: String!,
    "Destination Ethereum address."
    to: String!
  ): FastWithdrawal! @deprecated(reason: "use prepareFastWithdrawal mutation")
  fastWithdrawals: [FastWithdrawal!]!
  fastWithdrawalsWithRates: [FastWithdrawalWithRates!]!
  favoriteCards: [Card!]! @deprecated(reason: "Use `my_subscriptions` instead")
  favoriteClubs: [Club!]! @deprecated(reason: "Use `my_subscriptions` instead")
  favoritePlayers: [Player!]! @deprecated(reason: "Use `my_subscriptions` instead")
  featureFlagCustomAttributes: Json!
  fiatEnabled: Boolean!
  followed: EmailSubscription
  "The `followers` field cannot be nested within a list."
  followers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserWithSubscriptionSlugConnection!
  followersCount: Int!
  "The `following` field cannot be nested within a list."
  following(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserWithSubscriptionSlugConnection!
  followingCount: Int!
  "The `football_card_collections` field cannot be nested within a list."
  footballCardCollections(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,favoriteOnly: Boolean, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Full text search query to filter card collections"
    query: String,
    "Default to playable rarities"
    rarities: [Rarity!],seasonStartYears: [Int!], startedOnly: Boolean, teamSlug: String  ): CardCollectionConnection
  footballLast30DaysLineupsCount: Int!
  footballProfile(variant: UserSportProfileVariant): UserSportProfile
  fromPath: String
  highlightedDeck: HighlightedDeck
  "Typical number of hours the manager takes to answer trades"
  hoursToAnswerTrades: Int
  id: ID!
  "Generate a JWT Token"
  jwtToken(
    """
    Audience claim identifies the intended audience for this token. Consider
    using a value that uniquely identifies your use case.
    """
    aud: String!
  ): JwtToken!
  "The `live_single_sale_offers` field cannot be nested within a list."
  liveSingleSaleOffers(
    "Returns single sale offers sorted by `startDate` in descending order when set."
    newlyListed: Boolean
  ): [SingleSaleOffer!]! @deprecated(reason: "Use the paginated version instead")
  "The `live_single_sale_token_offers` field cannot be nested within a list."
  liveSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  "The `lost_english_auctions` field cannot be nested within a list."
  lostEnglishAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): EnglishAuctionConnection! @deprecated(reason: "use lostTokenAuctions instead")
  "The `lost_token_auctions` field cannot be nested within a list."
  lostTokenAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenAuctionConnection!
  moonpayParams: String!
  mustAcceptTcus: Boolean!
  myFootballManagerTasks: [FootballManagerTask!]!
  myRecentActiveBids: [TokenMyBid!]!
  mySorareAlgoliaKey: String @deprecated(reason: "Not used")
  mySubscriptions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption, types: [SubscribableType!]  ): EmailSubscriptionConnection!
  nbaProfile: UserSportProfile
  nickname: String!
  "If the current user can see the no card routes"
  noCardRouteEnabled: Boolean!
  notifications(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filters notifications by the specified categories when set."
    categories: [NotificationCategoryInput!],
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters notifications by sports"
    sports: [Sport!]
  ): NotificationConnection!
  "Get notifications fields."
  notificationsDetails(
    "Filters notifications by the specified categories when set."
    categories: [NotificationCategoryInput!]
  ): Notifications!
  onboardingStatus: Onboarding!
  otpBackupCodes: [String!] @deprecated(reason: "Security")
  otpProvisioningUri: String!
  otpRequiredForLogin: Boolean!
  "The `paginated_cards` field cannot be nested within a list."
  paginatedCards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,age: Int, assetIds: [String!], 
    "Returns the elements in the list that come before the specified cursor."
    before: String,customCardEditionName: String, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): CardConnection!
  "The `paginated_live_single_sale_offers` field cannot be nested within a list."
  paginatedLiveSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use liveSingleSaleTokenOffers instead")
  paymentMethods(provider: PaymentMethodProvider): [PaymentMethod!]!
  "Pending & recently failed deposits for the current user"
  pendingDeposits: [PendingDeposit!]!
  pendingDirectOffersReceived(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption  ): OfferConnection! @deprecated(reason: "Use pendingTokenOffersReceived")
  pendingDirectOffersSent(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption  ): OfferConnection! @deprecated(reason: "Use pendingTokenOffersSent")
  pendingDirectWithdrawalCount: Int!
  pendingTokenOffersReceived(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption, sport: [Sport!] = [FOOTBALL, BASEBALL, NBA]  ): TokenOfferConnection!
  pendingTokenOffersSent(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption, sport: [Sport!] = [FOOTBALL, BASEBALL, NBA]  ): TokenOfferConnection!
  phoneNumber: String
  phoneNumberVerificationRequested: Boolean!
  phoneNumberVerified: Boolean!
  player: Player
  "The `podium_rankings` field cannot be nested within a list."
  podiumRankings(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,ranking: Int, so5LeaderboardType: So5LeaderboardType  ): So5RankingConnection!
  "The `podiums` field cannot be nested within a list."
  podiums: [So5Podium!]!
  profile: UserProfile!
  rampSupported: Boolean!
  recentActiveBids: [TokenBid!]!
  "The `recommended_managers` field cannot be nested within a list."
  recommendedManagers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserConnection!
  referee: Boolean!
  refereeReward: ReferralReward
  referralAsReferee: Referral
  "Get the list of referral milestone rewards"
  referralMilestoneRewards(sport: Sport!): [ReferralMilestoneReward!]!
  referralRewardsCount: Int!
  referralUrl: String!
  "Get the list of referrals"
  referrals(
    "Page to retrieve. Defaults to 0."
    page: Int,
    "Maximum number of referrals to return. Defaults to 50."
    pageSize: Int,
    "Filters the referrals by sport."
    sport: Sport,
    "Filters the returned referrals by `state` when set."
    state: ReferralState
  ): ReferralPaginated!
  referrer: User
  "The `rewarded_rankings` field cannot be nested within a list."
  rewardedRankings(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,so5LeaderboardType: So5LeaderboardType  ): So5RankingConnection!
  """
  List of scopes the user has access to, returns "all" if the user has access to everything
  """
  scopes: [String!]!
  "The `single_sale_offers` field cannot be nested within a list."
  singleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use singleSaleTokenOffers instead")
  "The `single_sale_token_offers` field cannot be nested within a list."
  singleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  slug: String!
  "If the so5 no card route is open for submission"
  so5NoCardRouteOpened: Boolean!
  "The `sold_single_sale_offers` field cannot be nested within a list."
  soldSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use soldSingleSaleTokenOffers instead")
  "The `sold_single_sale_token_offers` field cannot be nested within a list."
  soldSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  sorareAddress: String
  sorareAddressApprovedBank: Boolean!
  sorareAddressApprovedBankPending: String
  "Can only be retrieved from a confirmed device"
  sorarePrivateKey: SorarePrivateKey
  sorarePrivateKeyRecovery: String
  spentFiatPaymentIntents(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,endDate: ISO8601DateTime, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption, startDate: ISO8601DateTime  ): PaymentConnection!
  sportConversionCredit(sport: Sport!): ConversionCredit
  starkKey: String
  starkKeyRegistered: Boolean! @deprecated(reason: "no longer relevant")
  "Set to true if the user deleted his account or was suspended"
  suspended: Boolean!
  "Time left in seconds to confirm email"
  timeLeftForConfirmation: Int
  "The `token_auctions` field cannot be nested within a list."
  tokenAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenAuctionConnection!
  tokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,direction: OfferDirection!, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption, sport: [Sport!] = [FOOTBALL, BASEBALL, NBA], states: [OfferState!]  ): TokenOfferConnection!
  "Current user total balance, in wei."
  totalBalance: String!
  "The `trophies` field cannot be nested within a list."
  trophies: [So5Trophies!]!
  "The `trophies_summary` field cannot be nested within a list."
  trophiesSummary: So5TrophiesSummary!
  unclaimedActionRewards: [ActionReward!]!
  unclaimedReferralRewardsCount: Int!
  unclaimedSo5Rewards: [So5Reward!]!
  unconfirmedEmail: String
  unreadNotificationsCount(
    "Filters notifications by the specified categories when set."
    categories: [NotificationCategoryInput!],
    "Filters notifications by sports"
    sports: [Sport!]
  ): Int!
  unverifiedPhoneNumber: String
  userSettings: UserSettings!
  wallet: UserWallet
  withdrawals: [Withdrawal!]!
  withdrawalsWithRates: [WithdrawalWithRates!]!
  "The `won_english_auctions` field cannot be nested within a list."
  wonEnglishAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): EnglishAuctionConnection! @deprecated(reason: "use wonTokenAuctions instead")
  "The `won_token_auctions` field cannot be nested within a list."
  wonTokenAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenAuctionConnection!
  nbaCards(first: Int! = 100, after: String, positions: [NBAPlayerPosition!], rarities: [CardRarity!]): NBACardConnection!
  nbaCurrentUserData: NBACurrentUserData!
  nbaUnclaimedLineupRewards: [NBAReward!]!
  nbaCardCounts: CardCountsByRarity!
  nbaLeagues: [NBALeague!]!
  nbaCollections(slugsFilter: [String!]): [NBACollection!]!
  baseballCards(first: Int! = 100, after: String, positions: [BaseballPlayerPosition!], rarities: [CardRarity!]): BaseballCardConnection!
  baseballCardCounts: CardCountsByRarity!
  baseballCardCountsByLineupPosition(rarities: [CardRarity!]): BaseballCardCountsByLineupPosition!
  baseballUnclaimedLineupRewards: [BaseballReward!]!
  baseballScoutingMissions: [BaseballScoutingMission!]! @deprecated(reason: "unsupported")
  baseballCollections(slugsFilter: [String!]): [BaseballCollection!]!
}
"A custom banner"
type CustomBanner implements Node {
  colorLeft: String
  colorRight: String
  id: ID!
}
"A custom deck"
type CustomDeck implements DeckInterface & Node {
  "The `cards` field cannot be nested within a list."
  cards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CardConnection!
  cardsCount: Int!
  deckCards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DeckCardConnection!
  deckCardsCount: Int!
  deckIndex: Int!
  firstCard: Card
  id: ID!
  name: String!
  slug: String!
  user: User
  visible: Boolean!
}
"The connection type for CustomDeck."
type CustomDeckConnection {
  "A list of edges."
  edges: [CustomDeckEdge!]!
  "A list of nodes."
  nodes: [CustomDeck!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CustomDeckEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CustomDeck
}
"A data partner"
type DataPartner implements Node {
  id: ID!
  name: String!
  slug: String!
  termsUrl: String!
}
"Autogenerated return type of deactivateWalletRecovery."
type deactivateWalletRecoveryPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"A decisive action notification"
type DecisiveActionNotification implements Node & NotificationInterface {
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
  read: Boolean!
  rendering: TitleBodyNotificationRendering
  sport: Sport
  user: CurrentUser!
}
"A deck card"
type DeckCard implements Node {
  card: Card!
  cardIndex: Int
  id: ID!
  label: String
}
"The connection type for DeckCard."
type DeckCardConnection {
  "A list of edges."
  edges: [DeckCardEdge!]!
  "A list of nodes."
  nodes: [DeckCard!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type DeckCardEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DeckCard
}
"A card deck with a formation"
type DeckInFormation implements DeckInterface & Node {
  "The `cards` field cannot be nested within a list."
  cards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CardConnection!
  cardsCount: Int!
  category: DeckCategory!
  deckCards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DeckCardConnection!
  deckCardsCount: Int!
  firstCard: Card
  formation: DeckFormation!
  id: ID!
  pictureUrl: String
  slug: String!
  user: User
}
"Autogenerated return type of declareFootballManagerTask."
type declareFootballManagerTaskPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  footballManagerTask: FootballManagerTask
}
"Autogenerated return type of declineSo5NoCardLineup."
type declineSo5NoCardLineupPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  so5NoCardLineup: So5NoCardLineup
}
"Autogenerated return type of deleteCustomDeck."
type deleteCustomDeckPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  deck: CustomDeck
  errors: [UserError!]!
}
"Autogenerated return type of deletePostalAddress."
type deletePostalAddressPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of deleteSo5Lineup."
type deleteSo5LineupPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  so5Leaderboard: So5Leaderboard!
}
"Autogenerated return type of deleteSo5UserGroup."
type deleteSo5UserGroupPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
}
"Autogenerated return type of deleteSubscription."
type deleteSubscriptionPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  subscribable: Subscribable
  subscription: EmailSubscription
}
"Autogenerated return type of deleteUserSo5Lineups."
type deleteUserSo5LineupsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  so5Fixture: So5Fixture
}
"A physical Merch Deliverable buyable through the club shop"
type DeliverableWithNoVariantShopItem implements Node & ShopItemInterface {
  cardCollectionRequirements: [CardCollectionRequirement!]!
  createdAt: ISO8601DateTime!
  currentStockCount: Int!
  description: String
  disabled: Boolean!
  expirationDate: ISO8601DateTime
  id: ID!
  initialStockCount: Int!
  limitPerUser: Int!
  myAvailableTotalPurchasesCount: Int!
  myAvailableUserShopItems: [UserShopItem!]
  myBalance: Int!
  myLimitResetAt: ISO8601DateTime
  myPurchasesCount: Int!
  name: String!
  pictureUrl: String!
  position: ShopItemType!
  price: Int!
  salePrice: Int
  shopItemsRequired: [ShopItem!]!
  unlocked: Boolean!
}
"Autogenerated return type of destroyAccount."
type destroyAccountPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of destroyReferral."
type destroyReferralPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of detachPaymentMethod."
type detachPaymentMethodPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser!
  errors: [UserError!]!
}
"Autogenerated return type of disable2fa."
type disable2faPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of disconnectOmniauthProvider."
type disconnectOmniauthProviderPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  userProfile: UserProfile
}
"A draftable player"
type DraftablePlayer {
  alreadyOwned: Boolean!
  avatarUrl: String!
  id: ID!
  nextGame: Game
  pictureUrl: String!
  player: Player!
  position: Position!
  team: Team!
  value: Int!
}
"The connection type for DraftablePlayer."
type DraftablePlayerConnection {
  "A list of edges."
  edges: [DraftablePlayerEdge!]!
  "A list of nodes."
  nodes: [DraftablePlayer!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type DraftablePlayerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DraftablePlayer
}
"Autogenerated return type of editCardInDeck."
type editCardInDeckPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  deck: DeckInterface
  errors: [UserError!]!
}
"Autogenerated return type of editCustomDeck."
type editCustomDeckPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  deck: CustomDeck
  errors: [UserError!]!
}
"A subscription to a Card/Club/Player/Country/User/CardCollection"
type EmailSubscription implements Node {
  id: ID!
  preferences: EmailSubscriptionPreferences!
  slug: String!
  subscribable: Subscribable @deprecated(reason: "Use `subscribableType` and `subscribableSlug` instead")
  subscribableSlug: String!
  subscribableType: String!
  subscriber: Subscriber
  updatedAt: ISO8601DateTime!
}
"The connection type for EmailSubscription."
type EmailSubscriptionConnection {
  "A list of edges."
  edges: [EmailSubscriptionEdge!]!
  "A list of nodes."
  nodes: [EmailSubscription!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type EmailSubscriptionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: EmailSubscription
}
"A subscription preferences"
type EmailSubscriptionPreferences {
  notifyForRarities: [String!]!
  slug: String!
}
"Autogenerated return type of enable2fa."
type enable2faPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  otpBackupCodes: [String!]
}
"An engine configuration"
type EngineConfiguration {
  captain: Float
  collection: Boolean
  fitness: Float
  grade: Float
  scarcity: Json
  season: Float
  xpMultiplier: Float
}
"An EnglishAuction on a bundle of Cards"
type EnglishAuction implements EnglishAuctionInterface & Node {
  bestBid: BidWithRates
  "The `bids` field cannot be nested within a list."
  bids(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BidConnection!
  bidsCount: Int!
  blockchainId: String!
  cancelled: Boolean!
  cards: [Card!]!
  contentProvider: EnglishAuctionContentProvider
  creditCardFee: Float!
  currency: SupportedCurrency!
  "Current price, in auction currency."
  currentPrice: String!
  endDate: ISO8601DateTime!
  id: ID!
  "Minimum next bid amount, in auction currency."
  minNextBid: String!
  "Best bid if the connected user is the best bidder, null otherwise"
  myBestBid: MyBidWithRates
  open: Boolean!
  slug: String!
  startDate: ISO8601DateTime!
  tokenAuction: TokenAuction!
}
"The connection type for EnglishAuction."
type EnglishAuctionConnection {
  "A list of edges."
  edges: [EnglishAuctionEdge!]!
  "A list of nodes."
  nodes: [EnglishAuction!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}
"An edge in a connection."
type EnglishAuctionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: EnglishAuction
}
"A withdrawal signature"
type EthBankWithdrawalIntent {
  amount: String!
  nonce: Int!
  signature: String!
  user: CurrentUser!
}
"Payload required to make a Starkware deposit"
type EthDeposit {
  assetType: String!
  starkKey: String!
  vaultId: Int!
  weiAmount: WeiAmount!
}
"An Ethereum Account"
type EthereumAccount implements Node {
  address: String!
  id: ID!
  migratorApproved: Boolean
}
"An Ethereum Transaction"
type EthereumTransaction implements Node {
  confirmedAt: ISO8601DateTime!
  id: ID!
  status: TransactionStatus
  transactionHash: String!
}
"An ETH migration"
type EthMigration implements Node {
  aasmState: String!
  id: ID!
  nonce: String!
  weiAmount: String!
}
"A ETH/EUR exchange rate"
type ExchangeRate implements Node {
  id: ID!
  rates: Json!
  time: ISO8601DateTime!
}
"An external deposit notification"
type ExternalDepositNotification implements Node & NotificationInterface {
  amount: String!
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
  read: Boolean!
  sport: Sport
  status: ExternalDepositNotificationStatus!
  user: CurrentUser!
}
"An extra swap shop item to add a swap to a user"
type ExtraSwapShopItem implements Node & ShopItemInterface {
  cardCollectionRequirements: [CardCollectionRequirement!]!
  createdAt: ISO8601DateTime!
  description: String
  disabled: Boolean!
  expirationDate: ISO8601DateTime
  id: ID!
  limitPerUser: Int!
  myAvailableTotalPurchasesCount: Int!
  myAvailableUserShopItems: [UserShopItem!]
  myBalance: Int!
  myLimitResetAt: ISO8601DateTime
  myPurchasesCount: Int!
  name: String!
  pictureUrl: String!
  position: ShopItemType!
  price: Int!
  salePrice: Int
  shopItemsRequired: [ShopItem!]!
  so5Leaderboard: So5Leaderboard
  unlocked: Boolean!
}
"A landmark as detected on a Player picture by face recognition"
type FaceLandmark {
  type: String!
  x: Float!
  xInPx: Float!
  y: Float!
  yInPx: Float!
}
"The starkware fast withdrawal as a ConditionalTransferRequest"
type FastWithdrawal implements Node {
  amount: String!
  condition: String!
  createdAt: ISO8601DateTime!
  expirationTimestamp: Int!
  feeInfoUser: Fee
  id: ID!
  nonce: Int!
  receiverPublicKey: String!
  receiverVaultId: Int!
  salt: String!
  senderVaultId: Int!
  status: WithdrawalStatus!
  to: String!
  token: String!
  transactionHash: String
}
"The starkware fast withdrawal with rates as a ConditionalTransferRequest"
type FastWithdrawalWithRates implements Node {
  amount: String!
  amountInFiat: Fiat!
  condition: String!
  createdAt: ISO8601DateTime!
  expirationTimestamp: Int!
  feeInfoUser: Fee
  id: ID!
  nonce: Int!
  receiverPublicKey: String!
  receiverVaultId: Int!
  salt: String!
  senderVaultId: Int!
  status: WithdrawalStatus!
  to: String!
  token: String!
  transactionHash: String
}
"Starkware fee representation"
type Fee {
  feeLimit: String!
  sourceVaultId: Int!
  tokenId: String!
}
"The connection type for FeedItem."
type FeedItemConnection {
  "A list of edges."
  edges: [FeedItemEdge]
  "A list of nodes."
  nodes: [FeedItem]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type FeedItemEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: FeedItem
}
"Autogenerated return type of fetchEncryptedPrivateKey."
type fetchEncryptedPrivateKeyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  sorarePrivateKey: SorarePrivateKey
}
type Fiat {
  eur: Float!
  gbp: Float!
  usd: Float!
}
"A Fiat Wallet Account"
type FiatWalletAccount implements Node {
  availableBalance: Int!
  countryOfResidence: String
  countryOfResidenceCode: String
  currency: FiatCurrency
  depositBankAccount: BankAccount
  dob: String
  firstName: String
  id: ID!
  kycRefusedReason: FiatWalletKycRefusedReason
  kycStatus: FiatWalletKycState
  lastName: String
  nationality: String
  nationalityCode: String
  state: FiatWalletAccountState!
  status: String! @deprecated(reason: "Use state instead")
  totalBalance: Int!
  withdrawalBankAccounts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BankAccountConnection
}
"Some Sorare: Football Counts"
type FootballCounts {
  auctionsCount: Int!
  managerSalesCount: Int!
  starterPacksCount: Int!
}
"A football Head to Head appearance"
type FootballHeadToHeadAppearance implements Node {
  bonus: Float!
  captain: Boolean!
  card: Card
  id: ID!
  pictureUrl(derivative: String = "tinified"): String
  player: Player!
  position: Position!
  score: Float!
  so5Score: So5Score
}
"Autogenerated return type of footballHeadToHeadAppearanceSubstitute."
type footballHeadToHeadAppearanceSubstitutePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentManager: FootballHeadToHeadCurrentManager
  errors: [UserError!]!
  lineup: FootballHeadToHeadLineup
}
"A Sorare: Football Daily arena request"
type FootballHeadToHeadArenaRequest implements Node {
  aasmState: ArenaRequestState!
  id: ID!
}
"Autogenerated return type of footballHeadToHeadArenaRequestCreate."
type footballHeadToHeadArenaRequestCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentManager: FootballHeadToHeadCurrentManager
  errors: [UserError!]!
  game: FootballHeadToHeadGame
}
"A Sorare: Football Daily challenge"
type FootballHeadToHeadChallenge implements Node {
  aasmState: ChallengeState!
  awayContestant: FootballHeadToHeadContestant
  contestants: [FootballHeadToHeadContestant!]! @deprecated(reason: "Use homeContestant & awayContestant")
  game: FootballHeadToHeadGame!
  homeContestant: FootballHeadToHeadContestant
  id: ID!
  type: ChallengeType!
}
"The connection type for FootballHeadToHeadChallenge."
type FootballHeadToHeadChallengeConnection {
  "A list of edges."
  edges: [FootballHeadToHeadChallengeEdge!]!
  "A list of nodes."
  nodes: [FootballHeadToHeadChallenge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type FootballHeadToHeadChallengeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: FootballHeadToHeadChallenge
}
"A Sorare: Football Head to Head contestant"
type FootballHeadToHeadContestant {
  id: ID!
  lineup: FootballHeadToHeadLineup
  lineups: [FootballHeadToHeadLineup!]! @deprecated(reason: "Use lineup")
  "Manager is the contestant is a manager"
  manager: FootballHeadToHeadManager
  outcome: Outcome
  ranking: Int! @deprecated(reason: "Useless")
  score: Float!
}
"Current Head to Head manager"
type FootballHeadToHeadCurrentManager implements FootballHeadToHeadPublicManagerInterface {
  eloGroup: String!
  eloScore: Int!
  id: ID!
  nextArenaRequestAvailableAt: ISO8601DateTime
  nickname: String!
  "The `past_challenges` field cannot be nested within a list."
  pastChallenges(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,type: ChallengeType  ): FootballHeadToHeadChallengeConnection!
  "The `past_games` field cannot be nested within a list."
  pastGames(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): FootballHeadToHeadGameConnection!
  pictureUrl(derivative: String = "low_res"): String
  records: FootballHeadToHeadManagerRecords!
  remainingArenaRequests: Int!
}
"A Sorare: Football Head to head draftable card"
type FootballHeadToHeadDraftableCard {
  card: Card
  id: ID!
  pictureUrl(derivative: String = "tinified"): String
  player: Player!
  position: Position!
}
"A Sorare: Football Head to Head draftable player"
type FootballHeadToHeadDraftablePlayer {
  id: ID!
  pictureUrl(derivative: String = "full"): String
  player: Player!
  position: Position!
}
"A football Head to Head game"
type FootballHeadToHeadGame implements Node {
  "The `available_challengers` field cannot be nested within a list."
  availableChallengers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,query: String  ): ChallengerConnection!
  "The `available_managers` field cannot be nested within a list."
  availableManagers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,query: String  ): FootballHeadToHeadManagerConnection!
  cap: Int!
  challenges(managerId: ID!, type: ChallengeType): [FootballHeadToHeadChallenge!]!
  "The `draftable_players` field cannot be nested within a list."
  draftablePlayers: [FootballHeadToHeadDraftableObject!]!
  "The `feed_items` field cannot be nested within a list."
  feedItems(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GameFeedItemConnection!
  game: Game!
  id: ID!
  myArenaChallenge: FootballHeadToHeadChallenge
  myArenaRequest: FootballHeadToHeadArenaRequest
  myChallenges: [FootballHeadToHeadChallenge!]! @deprecated(reason: "Use myFriendlyChallenges & myArenaChallenge instead")
  myFriendlyChallenges: [FootballHeadToHeadChallenge!]!
  myInvites: [FootballHeadToHeadInvite!]!
  myLineup: FootballHeadToHeadLineup
  "The `substitutable_players` field cannot be nested within a list."
  substitutablePlayers(appearanceId: ID!): [FootballHeadToHeadDraftableObject!]!
}
"The connection type for FootballHeadToHeadGame."
type FootballHeadToHeadGameConnection {
  "A list of edges."
  edges: [FootballHeadToHeadGameEdge!]!
  "A list of nodes."
  nodes: [FootballHeadToHeadGame!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type FootballHeadToHeadGameEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: FootballHeadToHeadGame
}
"A Sorare: Football Daily invite"
type FootballHeadToHeadInvite implements Node {
  aasmState: String!
  game: Game!
  id: ID!
  invitedBy: FootballHeadToHeadManager!
  manager: FootballHeadToHeadManager!
}
"Autogenerated return type of footballHeadToHeadInviteAccept."
type footballHeadToHeadInviteAcceptPayload {
  challenge: FootballHeadToHeadChallenge
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentManager: FootballHeadToHeadCurrentManager
  errors: [UserError!]!
}
"Autogenerated return type of footballHeadToHeadInviteCreate."
type footballHeadToHeadInviteCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentManager: FootballHeadToHeadCurrentManager
  errors: [UserError!]!
  game: FootballHeadToHeadGame!
  invite: FootballHeadToHeadInvite
}
"A football Head to Head lineup"
type FootballHeadToHeadLineup implements Node {
  appearances: [FootballHeadToHeadAppearance!]!
  canSubstitute: Boolean!
  game: FootballHeadToHeadGame!
  id: ID!
  manager: FootballHeadToHeadManager!
  score: Float!
  tactic: FootballHeadToHeadLineupTactic
  tacticScore: Float!
  tacticStatValue: Float!
}
"A football Head to Head lineup tactic"
type FootballHeadToHeadLineupTactic {
  displayName: String!
  iconUrl: String!
  id: String!
  stat: String!
  statName: String!
  thresholds: [FootballHeadToHeadLineupTacticThreshold!]!
  type: LineupTacticType!
}
"A Football Head to Head Lineup Tactic Threshold"
type FootballHeadToHeadLineupTacticThreshold {
  "The score bonus"
  score: Float!
  "The value to reach to get the score bonus"
  threshold: Float!
}
"Autogenerated return type of footballHeadToHeadLineupUpsert."
type footballHeadToHeadLineupUpsertPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentManager: FootballHeadToHeadCurrentManager
  errors: [UserError!]!
  game: FootballHeadToHeadGame!
  lineup: FootballHeadToHeadLineup
}
"A Head to Head manager"
type FootballHeadToHeadManager implements FootballHeadToHeadPublicManagerInterface & Node {
  eloGroup: String!
  eloScore: Int!
  id: ID!
  myRivalry: FootballHeadToHeadRivalry
  nickname: String!
  "The `past_challenges` field cannot be nested within a list."
  pastChallenges(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,type: ChallengeType  ): FootballHeadToHeadChallengeConnection!
  "The `past_games` field cannot be nested within a list."
  pastGames(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): FootballHeadToHeadGameConnection!
  pictureUrl(derivative: String = "low_res"): String
  records: FootballHeadToHeadManagerRecords!
}
"The connection type for FootballHeadToHeadManager."
type FootballHeadToHeadManagerConnection {
  "A list of edges."
  edges: [FootballHeadToHeadManagerEdge!]!
  "A list of nodes."
  nodes: [FootballHeadToHeadManager!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type FootballHeadToHeadManagerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: FootballHeadToHeadManager
}
"W/D/L records of a manager"
type FootballHeadToHeadManagerRecords {
  draws: Int!
  losses: Int!
  wins: Int!
}
"A rivalry between contestants"
type FootballHeadToHeadRivalry {
  id: ID!
  "The `past_challenges` field cannot be nested within a list."
  pastChallenges(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): FootballHeadToHeadChallengeConnection!
  "The `records` field cannot be nested within a list."
  records: FootballHeadToHeadManagerRecords!
}
"The Football Head to Head fields"
type FootballHeadToHeadRoot {
  currentManager: FootballHeadToHeadCurrentManager
  featuredGames: [FootballHeadToHeadGame!]!
  id: ID!
  lineupTactics: [FootballHeadToHeadLineupTactic!]!
  liveGames: [FootballHeadToHeadGame!]!
  "Nearest next game"
  nextGame: FootballHeadToHeadGame
  "Past 50 games"
  pastGames: [FootballHeadToHeadGame!]!
  pastGamesPaginated(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): FootballHeadToHeadGameConnection!
  totalArenaRequests: Int!
  upcomingGames: [FootballHeadToHeadGame!]!
}
"A football manager task"
type FootballManagerTask implements Node {
  aasmState: FootballManagerTaskState!
  claimedAt: ISO8601DateTime
  coinAmount: Int!
  id: ID!
  taskSlug: FootballManagerTaskSlug!
}
"The Football fields"
type FootballRoot {
  "Get a list of all cards"
  allCards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,age: Int, assetIds: [String!], 
    "Returns the elements in the list that come before the specified cursor."
    before: String,customCardEditionName: String, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): CardConnection!
  "Get a card"
  card(slug: String!): Card!
  "Get a card with its asset ID"
  cardByAssetId(assetId: String!): Card!
  "Get a card with its blockchain ID"
  cardByBlockchainId(blockchainId: String!): Card!
  cardCollection(slug: String!): CardCollection!
  "Get a list of cards"
  cards(age: Int, assetIds: [String!], customCardEditionName: String, owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): [Card!]!
  "Get a club"
  club(slug: String!): Club!
  "Get a list of clubs"
  clubs(slugs: [String!]!): [Club!]!
  "Get the list of clubs that are released and minted"
  clubsReady: [Club!]!
  "Get a Competition"
  competition(slug: String!): Competition!
  "Get a CustomDeck"
  customDeck(name: String, slug: String): CustomDeck!
  "Get a DeckInFormation"
  deckInFormation(slug: String!): DeckInFormation!
  "Get a list of cards owned by an ethereum account"
  ethereumCards(address: String!): [Card!]!
  "Get a Game"
  game(id: ID!): Game!
  headToHead: FootballHeadToHeadRoot!
  id: ID!
  leaguesOpenForGameStats: [Competition!]!
  "Get a national team"
  nationalTeam(slug: String!): NationalTeam!
  "Get a list of national teams"
  nationalTeams(slugs: [String!]!): [NationalTeam!]!
  "Get a player"
  player(slug: String!): Player!
  "Get a list of players"
  players(slugs: [String!]!): [Player!]!
  "Get a season"
  season(startYear: Int!): Season!
  "Get paginated available shop items"
  shopItems(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: ShopItemsSortInput, types: [ShopItemType!], unlockedOnly: Boolean  ): ClubShopItemConnection!
  so5: So5Root!
  sorareDaily: SorareDailyRoot!
  userCardCollection(id: String!): UserCardCollection!
}
"Autogenerated return type of footballSorareDailyAppearanceSubstitute."
type footballSorareDailyAppearanceSubstitutePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentManager: CurrentManager
  errors: [UserError!]!
  lineup: SorareDailyLineup
}
"Autogenerated return type of footballSorareDailyClanCreate."
type footballSorareDailyClanCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentManager: CurrentManager
  errors: [UserError!]!
}
"Autogenerated return type of footballSorareDailyClanJoin."
type footballSorareDailyClanJoinPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentManager: CurrentManager
  errors: [UserError!]!
}
"Autogenerated return type of footballSorareDailyClanLeave."
type footballSorareDailyClanLeavePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentManager: CurrentManager
  errors: [UserError!]!
}
"Autogenerated return type of footballSorareDailyLineupCreate."
type footballSorareDailyLineupCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentManager: CurrentManager
  errors: [UserError!]!
  game: SorareDailyGame!
  lineup: SorareDailyLineup
}
"Autogenerated return type of footballSorareDailyManagerClaimDailyCoins."
type footballSorareDailyManagerClaimDailyCoinsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentManager: CurrentManager
  errors: [UserError!]!
}
"Autogenerated return type of footballSorareDailyPackPurchase."
type footballSorareDailyPackPurchasePayload {
  boosts: [SorareDailyBoost!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentManager: CurrentManager
  errors: [UserError!]!
}
"Autogenerated return type of footballSorareDailyReact."
type footballSorareDailyReactPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  lineup: SorareDailyLineup!
}
"Autogenerated return type of footballSorareDailyRewardClaim."
type footballSorareDailyRewardClaimPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentManager: CurrentManager
  errors: [UserError!]!
  reward: SorareDailyReward!
}
"Autogenerated return type of footballSorareDailyRewardsClaim."
type footballSorareDailyRewardsClaimPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentManager: CurrentManager
  errors: [UserError!]!
  lineup: SorareDailyLineup!
}
"Autogenerated return type of footballSorareDailySquadCreate."
type footballSorareDailySquadCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  game: SorareDailyGame
}
"Autogenerated return type of footballSorareDailySquadJoin."
type footballSorareDailySquadJoinPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  game: SorareDailyGame
}
"Autogenerated return type of footballSorareDailySquadLeave."
type footballSorareDailySquadLeavePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  game: SorareDailyGame
}
"The starkware Full withdrawal"
type FullWithdrawalRequest implements Node {
  id: ID!
  served: Boolean!
  valid: Boolean!
}
"A professional football game"
type Game implements Node {
  "The `away_formation` field cannot be nested within a list."
  awayFormation: TeamFormation!
  awayGoals: Int
  awayTeam: Team
  competition: Competition!
  coverageStatus: GameCoverageStatus!
  date: ISO8601DateTime!
  extraTimeScoreAway: Int
  extraTimeScoreHome: Int
  "The `home_formation` field cannot be nested within a list."
  homeFormation: TeamFormation!
  homeGoals: Int!
  homeTeam: Team
  id: ID!
  lowCoverage: Boolean!
  minute: Int!
  penaltyScoreAway: Int
  penaltyScoreHome: Int
  periodType: Period!
  scored: Boolean!
  so5Fixture: So5Fixture
  "Available statuses: scheduled | playing | played | cancelled | postponed | suspended."
  status: String!
  venue: String
  winner: Team
}
"The connection type for Game."
type GameConnection {
  "A list of edges."
  edges: [GameEdge!]!
  "A list of nodes."
  nodes: [Game!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type GameEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Game
}
"A Game feed item type"
type GameFeedItem implements FeedItemInterface & Node {
  gameTime: Int!
  id: ID!
  itemDate: ISO8601DateTime!
  itemType: GameFeedItemType!
  period: Period
  player: Player
  statPreviousValue: Int
  statType: DecisiveStatType
  statValue: Int
}
"The connection type for GameFeedItem."
type GameFeedItemConnection {
  "A list of edges."
  edges: [GameFeedItemEdge!]!
  "A list of nodes."
  nodes: [GameFeedItem!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type GameFeedItemEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GameFeedItem
}
"A Mangopay GB bank account type"
type GbBankAccount implements BankAccountInterface & Node {
  "Account number (last 4 digits)"
  accountNumber: String!
  country: Country!
  id: ID!
  ownerAddress: MangopayBankAccountOwnerAddress
  ownerName: String
  "Sort code"
  sortCode: String!
}
"Autogenerated return type of generateAccountingExtract."
type generateAccountingExtractPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of generateActionRewardPickablePlayers."
type generateActionRewardPickablePlayersPayload {
  actionReward: ActionReward
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of generateOtpBackupCodes."
type generateOtpBackupCodesPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  otpBackupCodes: [String!]
}
"Autogenerated return type of generateSo5NoCardLineup."
type generateSo5NoCardLineupPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Hero banner metadata for the home page"
type HeroBanner {
  background: String
  colorLeft: String
  colorRight: String
  href: String!
  hrefColor: String
  hrefLabel: String!
  id: String!
  pictureDesktopUrl: String
  secondaryHref: String
  secondaryHrefColor: String
  secondaryHrefLabel: String
  subtitle: String
  title: String!
  videoDesktopUrl: String
}
"Collection of hero banners for the home page"
type HeroBannersSet {
  heroBanners: [HeroBanner!]!
  id: String!
  title: String!
}
"A highlighted deck"
type HighlightedDeck implements DeckInterface & Node {
  "The `cards` field cannot be nested within a list."
  cards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CardConnection!
  cardsCount: Int!
  deckCards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DeckCardConnection!
  deckCardsCount: Int!
  firstCard: Card
  id: ID!
  slug: String!
  user: User
}
"A Mangopay IBAN bank account type"
type IbanBankAccount implements BankAccountInterface & Node {
  "Bank Identifier Code"
  bic: String!
  country: Country!
  "IBAN"
  iban: String!
  id: ID!
  ownerAddress: MangopayBankAccountOwnerAddress
  ownerName: String
}
"A player injury"
type Injury implements Node {
  active: Boolean!
  expectedEndDate: ISO8601DateTime
  id: ID!
  kind: String
  startDate: ISO8601DateTime
}
type IRLPrize {
  headlineText: String!
  detailText: String
  type: IRLPrizeType!
}
"A physical Jersey buyable through the club shop"
type JerseyShopItem implements Node & ShopItemInterface {
  cardCollectionRequirements: [CardCollectionRequirement!]!
  createdAt: ISO8601DateTime!
  currentStockCount: Int
  description: String
  disabled: Boolean!
  expirationDate: ISO8601DateTime
  id: ID!
  initialStockCount: Int
  limitPerUser: Int!
  myAvailableTotalPurchasesCount: Int!
  myAvailableUserShopItems: [UserShopItem!]
  myBalance: Int!
  myLimitResetAt: ISO8601DateTime
  myPurchasesCount: Int!
  name: String!
  pictureUrl: String!
  position: ShopItemType!
  price: Int!
  salePrice: Int
  shopItemsRequired: [ShopItem!]!
  unlocked: Boolean!
  variantStockCounts: [VariantStockCount!]!
  variantType: VariantStockCountType
}
"Autogenerated return type of joinSo5UserGroup."
type joinSo5UserGroupPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  so5UserGroup: So5UserGroup
}
"Represents a jwt token"
type JwtToken {
  "JWT token expiration time."
  expiredAt: ISO8601DateTime!
  "JWT token, usable through a `Authorization: Bearer <token>` HTTP header."
  token: String!
}
"A Mangopay KYC Document requirement"
type KycDocumentRequirement {
  documentType: KycDocumentType!
  nbPages: Int!
}
"An KYC request notification"
type KycRequestNotification implements Node & NotificationInterface {
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
  read: Boolean!
  refusedReason: FiatWalletKycRefusedReason
  sport: Sport
  status: KycRequestNotificationStatus!
  user: CurrentUser!
}
"A club on the landing page"
type LandingClub {
  league: String!
  logo: String!
  name: String!
}
"A landing theme"
type LandingTheme implements Node {
  cards: [String!]!
  id: ID!
  slug: String!
  sport: Sport
  subtitle: String
  userSource: UserSource
}
type LeaderboardPrizePool {
  commonCardsMaxThreshold: Int
  commonCardsCount: Int!
  limitedCardsCount: Int!
  rareCardsCount: Int!
  superRareCardsCount: Int!
  uniqueCardsCount: Int!
  podium: [PrizePoolPodiumPrize!]!
  participation: [PrizeLevel!]!
}
"A So5 Leaderboard rewards config"
type LeaderboardRewardsConfig {
  conditional: [So5RewardConfig!]
  prizePoolCurrency: PaymentCurrency
  ranking: [So5RewardConfig!]
}
type LeaderboardRulesMinimumRarityRequirement {
  rarity: CardRarity!
  minCount: Int!
}
type League {
  id: String!
  slug: String!
  name: String!
  sport: GoSport
  memberCount: Int!
  members(offset: Int! = 0, limit: Int! = 100): [User!]!
}
type LeagueLeaderboard {
  league: League!
  leaderboard: LeaderboardInterface!
  lineupCount: Int!
  lineups(offset: Int! = 0, limit: Int! = 100): [LeagueLineup!]!
}
type LeagueLineup {
  rank: Int!
  lineup: LineupInterface!
  leaderboard: LeagueLeaderboard!
}
"A level up shop item to level up the xp of a card"
type LevelUpShopItem implements Node & ShopItemInterface & XPBoosterShopItemInterface {
  cardCollectionRequirements: [CardCollectionRequirement!]!
  createdAt: ISO8601DateTime!
  description: String
  disabled: Boolean!
  endLevel: Int!
  expirationDate: ISO8601DateTime
  id: ID!
  limitPerUser: Int!
  myAvailableTotalPurchasesCount: Int!
  myAvailableUserShopItems: [UserShopItem!]
  myBalance: Int!
  myLimitResetAt: ISO8601DateTime
  myPurchasesCount: Int!
  name: String!
  pictureUrl: String!
  position: ShopItemType!
  price: Int!
  rarity: Rarity!
  salePrice: Int
  shopItemsRequired: [ShopItem!]!
  startLevel: Int!
  unlocked: Boolean!
}
"The limit order representation of one side of a Deal (Auction or Offer)"
type LimitOrder {
  amountBuy: String!
  amountSell: String!
  expirationTimestamp: Int!
  feeInfo: Fee
  id: String @deprecated(reason: "Will be removed soon")
  nonce: Int!
  tokenBuy: String!
  tokenSell: String!
  vaultIdBuy: Int!
  vaultIdSell: Int!
}
"Autogenerated return type of linkEthereumAddress."
type linkEthereumAddressPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"A location"
type Location implements Node {
  countryCode: String
  id: ID!
  regionCode: String
}
"A Loom Account"
type LoomAccount implements Node {
  address: String!
  id: ID!
}
"A Mangopay bank account owner address type"
type MangopayBankAccountOwnerAddress {
  addressLine1: String
  addressLine2: String
  city: String
  country: String
  postalCode: String
  region: String
}
"A Mangopay credit card authorization request"
type MangopayCreditCardAuthorizationRequest {
  id: String!
}
"The Mangopay fields"
type MangopayRoot {
  bankAccountType(countryCode: String!): BankAccountType!
  countryCurrency(countryCode: String!): FiatCurrency
  id: ID!
  kycDocumentRequirements(countryCode: String!): [KycDocumentRequirement!]!
  ownerRegionRequired(countryCode: String!): Boolean!
}
"A Mangopay wallet transfer authorization request"
type MangopayWalletTransferAuthorizationRequest {
  amount: Int!
  currency: FiatCurrency!
  mangopayWalletId: String!
  nonce: Int!
  operationHash: String!
}
"A Mangopay Withdrawal"
type MangopayWithdrawal implements Node {
  aasmState: WithdrawalState! @deprecated(reason: "Use status instead")
  amounts: MonetaryAmount!
  bankAccount: BankAccount!
  id: ID!
  status: WithdrawalState!
  to: String!
}
"A single marketplace preference"
type MarketplacePreference {
  defaultValue: Json
  name: String!
  value: Json!
  values: [Json!]!
}
"A set of cards being promoted in the market place"
type MarketplacePromotionalEvent {
  name: String!
  objectIds: [String!]!
  rewardDetailsHref: String
}
"A set of events being promoted in the market place for a sport"
type MarketplacePromotionalEvents {
  events: [MarketplacePromotionalEvent!]!
  sport: Sport!
}
"Marketplace preferences specific to a sport"
type MarketplaceSportPreferences {
  preferences: [MarketplacePreference!]!
  sport: Sport!
}
"Autogenerated return type of markNotificationsAsRead."
type markNotificationsAsReadPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Enforces restrictions on the number of card that own the user of submitted lineups"
type MaximumCardsCountOwnedByUser {
  maximumCards: Int!
  scarcity: String
}
"An object representing a club for which a player has played during a certain time."
type Membership implements Node {
  aggregatedStats: Stats!
  club: Club
  endDate: ISO8601DateTime
  id: ID!
  membershipTeam: Team!
  player: Player!
  startDate: ISO8601DateTime!
  stats: [Stats!]!
}
"The connection type for Membership."
type MembershipConnection {
  "A list of edges."
  edges: [MembershipEdge!]!
  "A list of nodes."
  nodes: [Membership!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type MembershipEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Membership
}
"Represents a quota of Cards that can be minted on demand by a User"
type MintingQuota implements Node {
  allocated(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MintingQuotaAllocationConnection!
  endDate: ISO8601DateTime!
  id: ID!
  playerPool: PlayerPool
  startDate: ISO8601DateTime!
  units: [MintingQuotaUnit!]!
  user: User!
}
"Represents a quota of Cards of a certain tiers and rarity that can be minted on demand by a User"
type MintingQuotaAllocation implements Node {
  card: Card!
  id: ID!
  tier: Int!
  user: User!
}
"The connection type for MintingQuotaAllocation."
type MintingQuotaAllocationConnection {
  "A list of edges."
  edges: [MintingQuotaAllocationEdge!]!
  "A list of nodes."
  nodes: [MintingQuotaAllocation!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type MintingQuotaAllocationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MintingQuotaAllocation
}
"Represents a quota of Cards of a certain tier and rarity that can be minted on demand by a User"
type MintingQuotaUnit implements Node {
  allocations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MintingQuotaAllocationConnection!
  id: ID!
  mintingQuota: MintingQuota!
  quantity: Int!
  rarity: Rarity!
  remaining: Int!
  tier: CardQuality
}
type MonetaryAmount {
  eur: Int
  gbp: Int
  referenceCurrency: SupportedCurrency!
  usd: Int
  wei: WeiAmount
}
type Mutation {
  "Accept an offer"
  acceptOffer(
    "Parameters for acceptOffer"
    input: acceptOfferInput!
  ): acceptOfferPayload
  "Accept a So5NoCardLineup"
  acceptSo5NoCardLineup(
    "Parameters for acceptSo5NoCardLineup"
    input: acceptSo5NoCardLineupInput!
  ): acceptSo5NoCardLineupPayload
  "Accept terms of service"
  acceptTerms(
    "Parameters for acceptTerms"
    input: acceptTermsInput!
  ): acceptTermsPayload
  activateWalletRecovery(
    "Parameters for activateWalletRecovery"
    input: activateWalletRecoveryInput!
  ): activateWalletRecoveryPayload
  "Allows a user to add cards to a Deck."
  addCardsToDeck(
    "Parameters for addCardsToDeck"
    input: addCardsToDeckInput!
  ): addCardsToDeckPayload
  addDevice(
    "Parameters for addDevice"
    input: addDeviceInput!
  ): addDevicePayload
  "Allows a user to subscribe to the waiting list"
  addEmailToList(
    "Parameters for addEmailToList"
    input: addEmailToListInput!
  ): addEmailToListPayload
  "Add favourite clubs during the onboarding process"
  addFavouriteClubs(
    "Parameters for addFavouriteClubs"
    input: addFavouriteClubsInput!
  ): addFavouriteClubsPayload @deprecated(reason: "Not used anymore")
  addWalletRecovery(
    "Parameters for addWalletRecovery"
    input: addWalletRecoveryInput!
  ): addWalletRecoveryPayload
  "Approve Migrator contract"
  approveMigrator(
    "Parameters for approveMigrator"
    input: approveMigratorInput!
  ): approveMigratorPayload
  "Bid on an auction"
  bid(
    "Parameters for bid"
    input: bidInput!
  ): bidPayload
  "Block another user from sending offers"
  blockUserOffers(
    "Parameters for blockUserOffers"
    input: blockUserOffersInput!
  ): blockUserOffersPayload
  "Buy a shop item for a manager"
  buyDeliverableShopItem(
    "Parameters for buyDeliverableShopItem"
    input: buyDeliverableShopItemInput!
  ): buyDeliverableShopItemPayload
  "Buy a shop item for your club"
  buyShopItem(
    "Parameters for buyShopItem"
    input: buyShopItemInput!
  ): buyShopItemPayload
  cancelEthBankWithdrawals(
    "Parameters for cancelEthBankWithdrawals"
    input: cancelEthBankWithdrawalsInput!
  ): cancelEthBankWithdrawalsPayload
  cancelFastWithdrawal(
    "Parameters for cancelFastWithdrawal"
    input: cancelFastWithdrawalInput!
  ): cancelFastWithdrawalPayload
  "Cancel an offer"
  cancelOffer(
    "Parameters for cancelOffer"
    input: cancelOfferInput!
  ): cancelOfferPayload
  cancelWithdrawal(
    "Parameters for cancelWithdrawal"
    input: cancelWithdrawalInput!
  ): cancelWithdrawalPayload
  changePassword(
    "Parameters for changePassword"
    input: changePasswordInput!
  ): changePasswordPayload
  "Check phone number verification code"
  checkPhoneNumberVerificationCode(
    "Parameters for checkPhoneNumberVerificationCode"
    input: checkPhoneNumberVerificationCodeInput!
  ): checkPhoneNumberVerificationCodePayload
  "Claim an award"
  claimAward(
    "Parameters for claimAward"
    input: claimAwardInput!
  ): claimAwardPayload @deprecated(reason: "Not used anymore")
  "Allows a user to claim a card drop"
  claimCardDrop(
    "Parameters for claimCardDrop"
    input: claimCardDropInput!
  ): claimCardDropPayload
  claimConversionCredit(
    "Parameters for claimConversionCredit"
    input: claimConversionCreditInput!
  ): claimConversionCreditPayload
  "Claim an football manager task"
  claimFootballManagerTask(
    "Parameters for claimFootballManagerTask"
    input: claimFootballManagerTaskInput!
  ): claimFootballManagerTaskPayload
  "Claim a referral reward"
  claimReferralReward(
    "Parameters for claimReferralReward"
    input: claimReferralRewardInput!
  ): claimReferralRewardPayload
  "Claim a reward"
  claimReward(
    "Parameters for claimReward"
    input: claimRewardInput!
  ): claimRewardPayload
  "Claim rewards"
  claimRewards(
    "Parameters for claimRewards"
    input: claimRewardsInput!
  ): claimRewardsPayload
  "Allows a user to mark an onboarding task as complete"
  completeOnboardingTask(
    "Parameters for completeOnboardingTask"
    input: completeOnboardingTaskInput!
  ): completeOnboardingTaskPayload
  "Confirm Device"
  confirmDevice(
    "Parameters for confirmDevice"
    input: confirmDeviceInput!
  ): confirmDevicePayload
  "Confirm Email address"
  confirmEmail(
    "Parameters for confirmEmail"
    input: confirmEmailInput!
  ): confirmEmailPayload
  "Confirms user Lineups"
  confirmSo5Lineups(
    "Parameters for confirmSo5Lineups"
    input: confirmSo5LineupsInput!
  ): confirmSo5LineupsPayload
  "Confirm a So5NoCardLineup"
  confirmSo5NoCardLineup(
    "Parameters for confirmSo5NoCardLineup"
    input: confirmSo5NoCardLineupInput!
  ): confirmSo5NoCardLineupPayload
  "Consume your card booster"
  consumeCardBooster(
    "Parameters for consumeCardBooster"
    input: consumeCardBoosterInput!
  ): consumeCardBoosterPayload
  "Consume Ephemeral Token"
  consumeEphemeralToken(
    "Parameters for consumeEphemeralToken"
    input: consumeEphemeralTokenInput!
  ): consumeEphemeralTokenPayload
  "Consume your recovery kit"
  consumeRecoveryKit(
    "Parameters for consumeRecoveryKit"
    input: consumeRecoveryKitInput!
  ): consumeRecoveryKitPayload
  "Create a Mangopay credit card authorization"
  createCardAuthorization(
    "Parameters for createCardAuthorization"
    input: createCardAuthorizationInput!
  ): createCardAuthorizationPayload
  "Deposit fund to a Cash wallet with credit card"
  createCardDeposit(
    "Parameters for createCardDeposit"
    input: createCardDepositInput!
  ): createCardDepositPayload
  "Create a Mangopay Card Registration"
  createCardRegistration(
    "Parameters for createCardRegistration"
    input: createCardRegistrationInput!
  ): createCardRegistrationPayload
  "Withdraw a card to Ethereum"
  createCardWithdrawal(
    "Parameters for createCardWithdrawal"
    input: createCardWithdrawalInput!
  ): createCardWithdrawalPayload
  "Creates a common draft swap"
  createCommonDraftSwap(
    "Parameters for createCommonDraftSwap"
    input: createCommonDraftSwapInput!
  ): createCommonDraftSwapPayload
  "Allows a user to create a custom deck."
  createCustomDeck(
    "Parameters for createCustomDeck"
    input: createCustomDeckInput!
  ): createCustomDeckPayload
  "Create a dedicated bank account to enable user deposits"
  createDepositBankAccount(
    "Parameters for createDepositBankAccountMutation"
    input: createDepositBankAccountMutationInput!
  ): createDepositBankAccountMutationPayload
  "Send a Direct Offer to another manager"
  createDirectOffer(
    "Parameters for createDirectOffer"
    input: createDirectOfferInput!
  ): createDirectOfferPayload
  "Create a user draft and Lineup"
  createDraftAndSo5Lineup(
    "Parameters for createDraftAndSo5Lineup"
    input: createDraftAndSo5LineupInput!
  ): createDraftAndSo5LineupPayload
  "Creates an ephemeral link"
  createEphemeralLink(
    "Parameters for createEphemeralLink"
    input: createEphemeralLinkInput!
  ): createEphemeralLinkPayload
  createEthBankWithdrawalIntent(
    "Parameters for createEthBankWithdrawalIntent"
    input: createEthBankWithdrawalIntentInput!
  ): createEthBankWithdrawalIntentPayload
  "Store user-initiated ETH deposits"
  createEthDeposit(
    "Parameters for createEthDeposit"
    input: createEthDepositInput!
  ): createEthDepositPayload
  "Creates an ETH migration"
  createEthMigration(
    "Parameters for createEthMigration"
    input: createEthMigrationInput!
  ): createEthMigrationPayload
  "Creates an eth vault"
  createEthVault(
    "Parameters for createEthVault"
    input: createEthVaultInput!
  ): createEthVaultPayload
  createFastWithdrawal(
    "Parameters for createFastWithdrawal"
    input: createFastWithdrawalInput!
  ): createFastWithdrawalPayload
  createFiatPayer(
    "Parameters for createFiatPayer"
    input: createFiatPayerInput!
  ): createFiatPayerPayload
  createFiatWallet(
    "Parameters for createFiatWallet"
    input: createFiatWalletInput!
  ): createFiatWalletPayload
  "Create a fiat withdrawal to a bank account"
  createFiatWithdrawal(
    "Parameters for createFiatWithdrawal"
    input: createFiatWithdrawalInput!
  ): createFiatWithdrawalPayload
  "create an identity verification session"
  createIdentityVerificationSession(
    "Parameters for createIdentityVerificationSession"
    input: createIdentityVerificationSessionInput!
  ): createIdentityVerificationSessionPayload
  "Fix a minimum price for a card or token"
  createOrUpdateSingleBuyOfferMinPrice(
    "Parameters for createOrUpdateSingleBuyOfferMinPrice"
    input: createOrUpdateSingleBuyOfferMinPriceInput!
  ): createOrUpdateSingleBuyOfferMinPricePayload
  "Create or update a user Lineup"
  createOrUpdateSo5Lineup(
    "Parameters for createOrUpdateSo5Lineup"
    input: createOrUpdateSo5LineupInput!
  ): createOrUpdateSo5LineupPayload
  "Offer to buy a single card for a fixed price"
  createSingleBuyOffer(
    "Parameters for createSingleBuyOffer"
    input: createSingleBuyOfferInput!
  ): createSingleBuyOfferPayload @deprecated(reason: "Use CreateDirectOffer instead")
  "Sell a single card for a fixed price"
  createSingleSaleOffer(
    "Parameters for createSingleSaleOffer"
    input: createSingleSaleOfferInput!
  ): createSingleSaleOfferPayload
  "Create a User Group"
  createSo5UserGroup(
    "Parameters for createSo5UserGroup"
    input: createSo5UserGroupInput!
  ): createSo5UserGroupPayload
  "Add Cards, Players, Clubs, Countries, Users or CardCollection as favourites"
  createSubscription(
    "Parameters for createSubscription"
    input: createSubscriptionInput!
  ): createSubscriptionPayload
  createWallet(
    "Parameters for createWallet"
    input: createWalletInput!
  ): createWalletPayload
  "Deposit funds to a Cash wallet with a wire transfer"
  createWireTransferDeposit(
    "Parameters for createWireTransferDeposit"
    input: createWireTransferDepositInput!
  ): createWireTransferDepositPayload
  createWithdrawal(
    "Parameters for createWithdrawal"
    input: createWithdrawalInput!
  ): createWithdrawalPayload
  "Create a bank account to withdraw to"
  createWithdrawalBankAccount(
    "Parameters for createWithdrawalBankAccount"
    input: createWithdrawalBankAccountInput!
  ): createWithdrawalBankAccountPayload
  deactivateWalletRecovery(
    "Parameters for deactivateWalletRecovery"
    input: deactivateWalletRecoveryInput!
  ): deactivateWalletRecoveryPayload
  "Declare a football manager task"
  declareFootballManagerTask(
    "Parameters for declareFootballManagerTask"
    input: declareFootballManagerTaskInput!
  ): declareFootballManagerTaskPayload
  "Decline a So5NoCardLineup"
  declineSo5NoCardLineup(
    "Parameters for declineSo5NoCardLineup"
    input: declineSo5NoCardLineupInput!
  ): declineSo5NoCardLineupPayload
  "Allows a user to delete a custom deck."
  deleteCustomDeck(
    "Parameters for deleteCustomDeck"
    input: deleteCustomDeckInput!
  ): deleteCustomDeckPayload
  "Delete postal address"
  deletePostalAddress(
    "Parameters for deletePostalAddress"
    input: deletePostalAddressInput!
  ): deletePostalAddressPayload
  "Deletes a user Lineup"
  deleteSo5Lineup(
    "Parameters for deleteSo5Lineup"
    input: deleteSo5LineupInput!
  ): deleteSo5LineupPayload
  "Delete a User Group"
  deleteSo5UserGroup(
    "Parameters for deleteSo5UserGroup"
    input: deleteSo5UserGroupInput!
  ): deleteSo5UserGroupPayload
  "Delete a subscription to new auctions on a Card, a Player, a Club or a Country"
  deleteSubscription(
    "Parameters for deleteSubscription"
    input: deleteSubscriptionInput!
  ): deleteSubscriptionPayload
  "Deletes user Lineups by leagues"
  deleteUserSo5Lineups(
    "Parameters for deleteUserSo5Lineups"
    input: deleteUserSo5LineupsInput!
  ): deleteUserSo5LineupsPayload
  "Destroy my Sorare account"
  destroyAccount(
    "Parameters for destroyAccount"
    input: destroyAccountInput!
  ): destroyAccountPayload
  "Destroy an expired referral"
  destroyReferral(
    "Parameters for destroyReferral"
    input: destroyReferralInput!
  ): destroyReferralPayload
  detachPaymentMethod(
    "Parameters for detachPaymentMethod"
    input: detachPaymentMethodInput!
  ): detachPaymentMethodPayload
  "Disable 2FA requirement for login"
  disable2Fa(
    "Parameters for disable2fa"
    input: disable2faInput!
  ): disable2faPayload
  "Disconnect from a social auth"
  disconnectOmniauthProvider(
    "Parameters for disconnectOmniauthProvider"
    input: disconnectOmniauthProviderInput!
  ): disconnectOmniauthProviderPayload
  "Allows a user to edit a card position in a Deck."
  editCardInDeck(
    "Parameters for editCardInDeck"
    input: editCardInDeckInput!
  ): editCardInDeckPayload
  "Allows a user to edit a custom deck."
  editCustomDeck(
    "Parameters for editCustomDeck"
    input: editCustomDeckInput!
  ): editCustomDeckPayload
  "Enable 2FA requirement for login"
  enable2Fa(
    "Parameters for enable2fa"
    input: enable2faInput!
  ): enable2faPayload
  "Fetch encrypted private key"
  fetchEncryptedPrivateKey(
    "Parameters for fetchEncryptedPrivateKey"
    input: fetchEncryptedPrivateKeyInput!
  ): fetchEncryptedPrivateKeyPayload
  "Swap players at half time"
  footballHeadToHeadAppearanceSubstitute(
    "Parameters for footballHeadToHeadAppearanceSubstitute"
    input: footballHeadToHeadAppearanceSubstituteInput!
  ): footballHeadToHeadAppearanceSubstitutePayload
  "Create an Arena Request"
  footballHeadToHeadArenaRequestCreate(
    "Parameters for footballHeadToHeadArenaRequestCreate"
    input: footballHeadToHeadArenaRequestCreateInput!
  ): footballHeadToHeadArenaRequestCreatePayload
  "Accept a challenge invite"
  footballHeadToHeadInviteAccept(
    "Parameters for footballHeadToHeadInviteAccept"
    input: footballHeadToHeadInviteAcceptInput!
  ): footballHeadToHeadInviteAcceptPayload
  "Create an invite"
  footballHeadToHeadInviteCreate(
    "Parameters for footballHeadToHeadInviteCreate"
    input: footballHeadToHeadInviteCreateInput!
  ): footballHeadToHeadInviteCreatePayload
  "Create or update lineup"
  footballHeadToHeadLineupUpsert(
    "Parameters for footballHeadToHeadLineupUpsert"
    input: footballHeadToHeadLineupUpsertInput!
  ): footballHeadToHeadLineupUpsertPayload
  "Swap players at half time"
  footballSorareDailyAppearanceSubstitute(
    "Parameters for footballSorareDailyAppearanceSubstitute"
    input: footballSorareDailyAppearanceSubstituteInput!
  ): footballSorareDailyAppearanceSubstitutePayload
  "Create a clan"
  footballSorareDailyClanCreate(
    "Parameters for footballSorareDailyClanCreate"
    input: footballSorareDailyClanCreateInput!
  ): footballSorareDailyClanCreatePayload
  "Join a Clan"
  footballSorareDailyClanJoin(
    "Parameters for footballSorareDailyClanJoin"
    input: footballSorareDailyClanJoinInput!
  ): footballSorareDailyClanJoinPayload
  "Leave a clan"
  footballSorareDailyClanLeave(
    "Parameters for footballSorareDailyClanLeave"
    input: footballSorareDailyClanLeaveInput!
  ): footballSorareDailyClanLeavePayload
  "Create or update lineup"
  footballSorareDailyLineupCreate(
    "Parameters for footballSorareDailyLineupCreate"
    input: footballSorareDailyLineupCreateInput!
  ): footballSorareDailyLineupCreatePayload
  "Claim daily coins"
  footballSorareDailyManagerClaimDailyCoins(
    "Parameters for footballSorareDailyManagerClaimDailyCoins"
    input: footballSorareDailyManagerClaimDailyCoinsInput!
  ): footballSorareDailyManagerClaimDailyCoinsPayload
  "Purchase a pack"
  footballSorareDailyPackPurchase(
    "Parameters for footballSorareDailyPackPurchase"
    input: footballSorareDailyPackPurchaseInput!
  ): footballSorareDailyPackPurchasePayload
  "React to a lineup"
  footballSorareDailyReact(
    "Parameters for footballSorareDailyReact"
    input: footballSorareDailyReactInput!
  ): footballSorareDailyReactPayload
  "Claim a reward"
  footballSorareDailyRewardClaim(
    "Parameters for footballSorareDailyRewardClaim"
    input: footballSorareDailyRewardClaimInput!
  ): footballSorareDailyRewardClaimPayload
  "Claim lineup rewards"
  footballSorareDailyRewardsClaim(
    "Parameters for footballSorareDailyRewardsClaim"
    input: footballSorareDailyRewardsClaimInput!
  ): footballSorareDailyRewardsClaimPayload
  "Create a squad"
  footballSorareDailySquadCreate(
    "Parameters for footballSorareDailySquadCreate"
    input: footballSorareDailySquadCreateInput!
  ): footballSorareDailySquadCreatePayload @deprecated(reason: "Not used anymore")
  "Join a squad"
  footballSorareDailySquadJoin(
    "Parameters for footballSorareDailySquadJoin"
    input: footballSorareDailySquadJoinInput!
  ): footballSorareDailySquadJoinPayload @deprecated(reason: "Not used anymore")
  "Leave a squad"
  footballSorareDailySquadLeave(
    "Parameters for footballSorareDailySquadLeave"
    input: footballSorareDailySquadLeaveInput!
  ): footballSorareDailySquadLeavePayload @deprecated(reason: "Not used anymore")
  "Request a CSV accounting extract by email"
  generateAccountingExtract(
    "Parameters for generateAccountingExtract"
    input: generateAccountingExtractInput!
  ): generateAccountingExtractPayload
  "Generate the pickable players of an action reward"
  generateActionRewardPickablePlayers(
    "Parameters for generateActionRewardPickablePlayers"
    input: generateActionRewardPickablePlayersInput!
  ): generateActionRewardPickablePlayersPayload
  "Generate OTP backup codes"
  generateOtpBackupCodes(
    "Parameters for generateOtpBackupCodes"
    input: generateOtpBackupCodesInput!
  ): generateOtpBackupCodesPayload
  "Create a So5NoCardLineup"
  generateSo5NoCardLineup(
    "Parameters for generateSo5NoCardLineup"
    input: generateSo5NoCardLineupInput!
  ): generateSo5NoCardLineupPayload
  "Join a User Group"
  joinSo5UserGroup(
    "Parameters for joinSo5UserGroup"
    input: joinSo5UserGroupInput!
  ): joinSo5UserGroupPayload
  "Link an Ethereum address to your Sorare account"
  linkEthereumAddress(
    "Parameters for linkEthereumAddress"
    input: linkEthereumAddressInput!
  ): linkEthereumAddressPayload
  "Mark notifications as read"
  markNotificationsAsRead(
    "Parameters for markNotificationsAsRead"
    input: markNotificationsAsReadInput!
  ): markNotificationsAsReadPayload
  "Pick the players of an action reward"
  pickActionRewardPlayers(
    "Parameters for pickActionRewardPlayers"
    input: pickActionRewardPlayersInput!
  ): pickActionRewardPlayersPayload
  "Get the limit orders that need to be signed in order to accept an offer"
  prepareAcceptOffer(
    "Parameters for prepareAcceptOffer"
    input: prepareAcceptOfferInput!
  ): prepareAcceptOfferPayload
  "Get the authorizations that need to be signed in order to bid on an english auction"
  prepareBid(
    "Parameters for prepareBid"
    input: prepareBidInput!
  ): prepareBidPayload
  "Get transfer request that needs to be signed in order to withdraw a card"
  prepareCardWithdrawal(
    "Parameters for prepareCardWithdrawal"
    input: prepareCardWithdrawalInput!
  ): prepareCardWithdrawalPayload
  "Get the payload to make an ETH deposit"
  prepareEthDeposit(
    "Parameters for prepareEthDeposit"
    input: prepareEthDepositInput!
  ): prepareEthDepositPayload
  prepareFastWithdrawal(
    "Parameters for prepareFastWithdrawal"
    input: prepareFastWithdrawalInput!
  ): prepareFastWithdrawalPayload
  "Get the limit orders that need to be signed in order to be able to create an offer"
  prepareOffer(
    "Parameters for prepareOffer"
    input: prepareOfferInput!
  ): prepareOfferPayload
  "Get the payload to deposit an NFT into Layer 2"
  prepareTokenDeposit(
    "Parameters for prepareTokenDeposit"
    input: prepareTokenDepositInput!
  ): prepareTokenDepositPayload
  "Refresh an award"
  refreshAward(
    "Parameters for refreshAward"
    input: refreshAwardInput!
  ): refreshAwardPayload @deprecated(reason: "Not used anymore")
  "Reject an Offer"
  rejectOffer(
    "Parameters for rejectOffer"
    input: rejectOfferInput!
  ): rejectOfferPayload
  relayCall(
    "Parameters for relayCall"
    input: relayCallInput!
  ): relayCallPayload
  "Allows a user to remove a card from a deck."
  removeCardFromDeck(
    "Parameters for removeCardFromDeck"
    input: removeCardFromDeckInput!
  ): removeCardFromDeckPayload
  "Remove a User from a User Group"
  removeUserFromSo5UserGroup(
    "Parameters for removeUserFromSo5UserGroup"
    input: removeUserFromSo5UserGroupInput!
  ): removeUserFromSo5UserGroupPayload
  "For web and mobile clients to report metrics"
  reportTelemetry(
    "Parameters for reportTelemetry"
    input: reportTelemetryInput!
  ): reportTelemetryPayload
  "Request a receipt from Stripe"
  requestPaymentReceipt(
    "Parameters for requestReceipt"
    input: requestReceiptInput!
  ): requestReceiptPayload
  "Request to choose another leaderboard for a So5NoCardLineup"
  requestSo5NoCardLineupEligibleLeaderboards(
    "Parameters for requestSo5NoCardLineupEligibleLeaderboards"
    input: requestSo5NoCardLineupEligibleLeaderboardsInput!
  ): requestSo5NoCardLineupEligibleLeaderboardsPayload
  resendConfirmationInstructions(
    "Parameters for resendConfirmationInstructions"
    input: resendConfirmationInstructionsInput!
  ): resendConfirmationInstructionsPayload
  resendVerificationCode(
    "Parameters for resendVerificationCode"
    input: resendVerificationCodeInput!
  ): resendVerificationCodePayload
  resetPrivateKey(
    "Parameters for resetPrivateKey"
    input: resetPrivateKeyInput!
  ): resetPrivateKeyPayload
  restoreWallet(
    "Parameters for restoreWallet"
    input: restoreWalletInput!
  ): restoreWalletPayload
  "Allows a user to restart a skipped onboarding process"
  resumeOnboarding(
    "Parameters for resumeOnboarding"
    input: resumeOnboardingInput!
  ): resumeOnboardingPayload
  "Revoke Device"
  revokeDevice(
    "Parameters for revokeDevice"
    input: revokeDeviceInput!
  ): revokeDevicePayload
  "Revokes the specified token"
  revokeOAuthAccessToken(
    "Parameters for revokeOAuthAccessToken"
    input: revokeOAuthAccessTokenInput!
  ): revokeOAuthAccessTokenPayload
  sendWalletRecovery(
    "Parameters for sendWalletRecovery"
    input: sendWalletRecoveryInput!
  ): sendWalletRecoveryPayload
  "Add or update the given device token for push notifications"
  setDeviceToken(
    "Parameters for setDeviceToken"
    input: setDeviceTokenInput!
  ): setDeviceTokenPayload
  "Add or remove the given activity token for push notification"
  setLiveActivityToken(
    "Parameters for setLiveActivityToken"
    input: setLiveActivityTokenInput!
  ): setLiveActivityTokenPayload
  "Sign in"
  signIn(
    "Parameters for signIn"
    input: signInInput!
  ): signInPayload
  "Sign in with OAuth"
  signInWithOauth(
    "Parameters for signInWithOAuth"
    input: signInWithOAuthInput!
  ): signInWithOAuthPayload
  "Sign out from all sessions except the current one"
  signOutFromAllDevices(
    "Parameters for signOutFromAllDevices"
    input: signOutFromAllDevicesInput!
  ): signOutFromAllDevicesPayload
  "Sign up"
  signUp(
    "Parameters for signUp"
    input: signUpInput!
  ): signUpPayload
  "Allows a user to skip his onboarding process"
  skipOnboarding(
    "Parameters for skipOnboarding"
    input: skipOnboardingInput!
  ): skipOnboardingPayload
  "Allow a user to specify they started onboarding"
  startOnboarding(
    "Parameters for startOnboarding"
    input: startOnboardingInput!
  ): startOnboardingPayload
  "Stop current auto bid on an auction"
  stopAutoBid(
    "Parameters for stopAutoBid"
    input: stopAutoBidInput!
  ): stopAutoBidPayload
  "Unblock email"
  unblockEmail(
    "Parameters for UnblockEmail"
    input: UnblockEmailInput!
  ): UnblockEmailPayload
  "Unblock another user from sending offers"
  unblockUserOffers(
    "Parameters for unblockUserOffers"
    input: unblockUserOffersInput!
  ): unblockUserOffersPayload
  "Set filters for the current user"
  updateCardFilters(
    "Parameters for updateCardFilters"
    input: updateCardFiltersInput!
  ): updateCardFiltersPayload
  "Set an external deposit ETH transaction hash"
  updateExternalEthDeposit(
    "Parameters for updateExternalEthDeposit"
    input: updateExternalEthDepositInput!
  ): updateExternalEthDepositPayload
  updateFiatWallet(
    "Parameters for updateFiatWallet"
    input: updateFiatWalletInput!
  ): updateFiatWalletPayload
  "Update the highlightedCard in a collection"
  updateHighlightedCard(
    "Parameters for updateHighlightedCard"
    input: updateHighlightedCardInput!
  ): updateHighlightedCardPayload
  "Update partner offers agreement"
  updatePartnerOffersAgreement(
    "Parameters for updatePartnerOffersAgreement"
    input: updatePartnerOffersAgreementInput!
  ): updatePartnerOffersAgreementPayload
  "Update a User Group"
  updateSo5UserGroup(
    "Parameters for updateSo5UserGroup"
    input: updateSo5UserGroupInput!
  ): updateSo5UserGroupPayload
  "Update a subscription notification preferences"
  updateSubscription(
    "Parameters for updateSubscription"
    input: updateSubscriptionInput!
  ): updateSubscriptionPayload
  "Update user email"
  updateUserEmail(
    "Parameters for updateUserEmail"
    input: updateUserEmailInput!
  ): updateUserEmailPayload
  "Update user profile"
  updateUserProfile(
    "Parameters for updateUserProfile"
    input: updateUserProfileInput!
  ): updateUserProfilePayload
  "Update user settings"
  updateUserSettings(
    "Parameters for updateUserSettings"
    input: updateUserSettingsInput!
  ): updateUserSettingsPayload
  "Creates a common draft"
  upsertCommonDraft(
    "Parameters for upsertCommonDraft"
    input: upsertCommonDraftInput!
  ): upsertCommonDraftPayload
  validateFiatWallet(
    "Parameters for validateFiatWallet"
    input: validateFiatWalletInput!
  ): validateFiatWalletPayload
  "Verify phone number"
  verifyPhoneNumber(
    "Parameters for verifyPhoneNumber"
    input: verifyPhoneNumberInput!
  ): verifyPhoneNumberPayload
  deleteLineup(input: BaseballDeleteLineupInput, id: UUID): Boolean @deprecated(reason: "use deleteBaseballLineup")
  claimCardRewards(ids: [UUID!]!): [CardReward!]
  claimNBARewards(ids: [UUID!]!): [NBAReward!]
  claimNBAReferralRewards(referralIDs: [UUID!]!): [NBAReferralReward!]!
  completeNBAOnboardingTask(input: NBACompleteOnboardingTaskInput!): NBACompleteOnboardingTaskResponse!
  createOrUpdateNBALineup(input: NBACreateOrUpdateLineupInput!): NBACreateOrUpdateLineupResponse!
  deleteNBALineup(id: UUID!): Boolean
  claimBaseballRewards(ids: [UUID!]!): [BaseballReward!]
  claimBaseballReferralRewards(referralIDs: [UUID!]!): [BaseballReferralReward!]
  createOrUpdateBaseballLineup(input: BaseballCreateOrUpdateLineupInput!): BaseballCreateOrUpdateLineupResponse!
  deleteBaseballLineup(id: UUID!): Boolean
}
"My bid with conversion rates"
type MyBidWithRates implements Node {
  "Bid amount, in auction currency."
  amount: String!
  amountInFiat: Fiat!
  amounts: MonetaryAmount!
  bidder: BlockchainUser
  createdAt: ISO8601DateTime!
  englishAuction: BundledAuction! @deprecated(reason: "use tokenAuction instead")
  fiatPayment: Boolean!
  id: ID!
  tokenAuction: TokenAuction!
}
type NationalTeam implements Node & TeamInterface & WithSubscriptionsInterface {
  activeCompetitions: [Competition!]!
  "The `active_memberships` field cannot be nested within a list."
  activeMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MembershipConnection!
  "The `active_players` field cannot be nested within a list."
  activePlayers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PlayerConnection!
  "The `cards` field cannot be nested within a list."
  cards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,age: Int, assetIds: [String!], 
    "Returns the elements in the list that come before the specified cursor."
    before: String,customCardEditionName: String, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): CardConnection!
  code: String
  country: Country!
  currentUserSubscription: EmailSubscription
  customBanner: CustomBanner
  dataPartner: DataPartner
  founded: String
  "The `games` field cannot be nested within a list."
  games(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "End time (inclusive) of the game."
    endDate: ISO8601DateTime!,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Start time (inclusive) of the game."
    startDate: ISO8601DateTime!
  ): GameConnection!
  id: ID!
  internationalCompetition: Competition
  lastFiveGames: [Game!]!
  "The `latest_games` field cannot be nested within a list."
  latestGames(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GameConnection!
  name: String!
  optaId: String
  pictureSecondaryUrl: String
  pictureUrl(derivative: String = "low_res"): String
  "The `players` field cannot be nested within a list."
  players(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PlayerConnection!
  ready: Boolean!
  "The `recent_departures` field cannot be nested within a list."
  recentDepartures(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PlayerConnection!
  shortName: String!
  slug: String!
  subscriptionsCount: Int!
  upcomingGames(first: Int!): [Game]!
}
"A NBA card"
type NBACard implements CardInterface {
  assetId: ID!
  token: Token
  id: UUID!
  slug: String!
  owner: User
  player: NBAPlayer!
  team: NBATeam
  rarity: CardRarity!
  season: String!
  serialNumber: Int!
  positions: [NBAPlayerPosition!]!
  fullImageUrl: String!
  avatarImageUrl: String!
  backImageUrl: String!
  cardLevel: Int!
  xpThresholdForCurrentCardLevel: Int!
  xpThresholdForNextCardLevel: Int
  xp: Int!
  seasonBonus: Float!
  rarityBonus: Float!
  xpBonus: Float!
  totalBonus: Float!
  bonusLossAfterTransfer: Float!
}
type NBACardBundleOffer implements CardBundleOffer {
  id: String!
  priceUSDCents: Int!
  cards: [NBACard!]!
  expiresAt: Time!
  leaderboard: NBALeaderboard
  rewardPlayerName: String!
  rank: Int!
}
type NBACardConnection {
  nodes: [NBACard!]!
  pageInfo: PageInfo!
}
type NBACardForComposeLineup {
  card: NBACard!
  usedInOtherLineup: NBALineup
  tenGameAverageForComposeLineup: Int!
  totalBonusInLineup: Float!
}
type NBACardForComposeLineupConnection {
  nodes: [NBACardForComposeLineup!]!
  pageInfo: PageInfo!
}
type NBACardInLineup implements CardInLineupInterface {
  lineup: NBALineup!
  card: NBACard!
  playerInFixture: NBAPlayerInFixture!
  score: Float!
  totalBonus: Float!
  isMvp: Boolean!
  gameScores: [NBACardInLineupGameScore!]
}
type NBACardInLineupGameScore implements CardInLineupGameScoreInterface {
  score: Float!
  gameStats: NBAPlayerGameStats!
  detailedGameScores: NBAPlayerGameDetailedScores!
}
type NBACardsPaginated {
  currentPage: Int!
  pages: Int!
  cards: [NBACard!]!
}
type NBACardTrade implements CardTradeInterface {
  id: UUID!
  expiresAfter: Time
  userGiveCard: NBACard!
  userGiveCardUsedInLineup: NBALineup
  userReceiveCardChoices: [NBACommonCardSample!]!
  userReceiveCard: NBACard
  isComplete: Boolean!
}
type NBACollection implements CollectionInterface {
  slug: String!
  isComplete: Boolean!
  slots: [NBACollectionSlot!]!
  slotsCount: Int!
  filledSlots: Int!
  team: NBATeam
  season: String
}
type NBACollectionSlot implements CollectionSlotInterface {
  requiredPlayer: NBAPlayer!
  ownedCards: [NBACard!]
  displayCard: NBACard
}
type NBACommonCardDrop {
  id: UUID!
  cardChoices: [NBACommonCardSample!]!
  claimedCard: NBACard
}
type NBACommonCardSample implements CommonCardSampleInterface {
  id: UUID!
  player: NBAPlayer!
  commonCardImageUrl: String!
}
type NBACompleteOnboardingTaskResponse {
  currentSportsUser: CurrentSportsUser @deprecated(reason: "use NBACompleteOnboardingTaskResponse.currentUser")
  currentUser: CurrentUser
}
type NBACreateOrUpdateLineupResponse {
  createdLineup: NBALineup
  lineupValidationErrors: [NBACreateOrUpdateLineupValidationError!]!
}
type NBACurrentUserData {
  onboardingState: NBAOnboarding!
}
type NBAFixture implements FixtureInterface {
  id: UUID!
  slug: String!
  fixtureState: FixtureState!
  gameWeek: Int!
  startDate: Time!
  endDate: Time!
  games: [NBAGame!]!
  leaderboards(includeTraining: Boolean): [NBALeaderboard!]!
  myEligibleGames: [NBAGame!]!
  myLiveLineupGames: [NBAGameWithCardInLineup!]!
  myLineups: [NBALineup!]!
  playerFixtureStats(first: Int! = 20, after: String, hideUnownedPlayers: Boolean, playerOwnershipFilter: PlayerOwnershipFilter, order: PlayerFixtureStatsSortOrder): NBAPlayerFixtureStatsConnection!
  rewardPool(rarity: BaseballCardRarity, cardRarity: CardRarity, tier: Int!): [NBAPlayer!]!
  nextFixture: NBAFixture
  previousFixture: NBAFixture
}
type NBAFixtureConnection {
  nodes: [NBAFixture!]!
  pageInfo: PageInfo!
}
type NBAGame implements GameInterface {
  id: UUID!
  status: GameStatus!
  startDate: Time!
  homeTeam: NBATeam!
  awayTeam: NBATeam!
  homeScore: Int!
  awayScore: Int!
  quarter: Int!
  isHalftime: Boolean!
  pastPlayerPerformance(playerSlug: String!, last: Int! = 5): [NBAPlayerGameStats!]!
  gameWeek: Int!
}
type NBAGameWithCardInLineup implements GameWithCardInLineupInterface {
  game: NBAGame!
  homeCardsInLineups: [NBACardInLineup!]!
  awayCardsInLineups: [NBACardInLineup!]!
}
type NBALeaderboard implements SportsNode & LeaderboardInterface {
  id: UUID!
  slug: String!
  displayName: String!
  displayNameWithoutRarity: String!
  descriptions: [String]!
  lineups(first: Int! = 20, after: String, userId: ID): NBALineupConnection!
  myLineups: [NBALineup!]!
  lineupsCount: Int!
  fixture: NBAFixture!
  prizePool: LeaderboardPrizePool!
  requirements: NBALeaderboardRequirements!
  leaderboardRarity: LeaderboardRarity!
  isUserEligible: Boolean!
  isTraining: Boolean!
  iconImageUrl: String!
  monochromeIconImageUrl: String!
  myComposeLineupCards(query: String, lineupId: UUID, first: Int! = 20, after: String, includeUsed: Boolean!, includeOverTenGameAverageTotalLimit: Boolean, indexInLineup: Int!, cardsInLineupPartial: [ID!]!): NBACardForComposeLineupConnection!
  scoringStrategy: String!
}
type NBALeaderboardRequirements implements LeaderboardRequirementsInterface {
  allowedRarities: [CardRarity!]!
  minRarity: LeaderboardRulesMinimumRarityRequirement
  minRookieCount: Int!
  tenGameAverageTotalLimit: Int!
  allowMVP: Boolean!
  allowedConference: NBAConference
  playerAgeRequirements: PlayerAgeRequirements
  marketplaceQueryParameters: String
}
type NBALeaderboardRuleRange {
  min: Int!
  max: Int!
}
type NBALeaderboardRulesRarityRange {
  common: NBALeaderboardRuleRange
  limited: NBALeaderboardRuleRange
  rare: NBALeaderboardRuleRange
  superRare: NBALeaderboardRuleRange
  unique: NBALeaderboardRuleRange
}
type NBALeague implements LeagueInterface {
  id: String!
  slug: String!
  name: String!
  members: [User!]!
}
type NBALeagueLeaderboard implements LeagueLeaderboardInterface {
  league: NBALeague!
  leaderboard: NBALeaderboard!
  lineupCount: Int!
  lineups: [NBALeagueLineup!]!
  participants: [User!]!
}
type NBALeagueLineup implements LeagueLineupInterface {
  rank: Int!
  lineup: NBALineup!
  leaderboard: NBALeagueLeaderboard!
}
type NBALineup implements LineupInterface {
  id: UUID!
  leaderboard: NBALeaderboard!
  cards: [NBACardInLineup!]!
  games: [NBAGameWithCardInLineup!]!
  score: Float!
  rank: Int!
  user: User!
  xpScore: Float! @deprecated(reason: "No longer supported")
  projectedReward: ProjectedReward
  reward: NBAReward
}
type NBALineupConnection {
  nodes: [NBALineup!]!
  pageInfo: PageInfo!
}
type NBAOnboarding {
  nextTask: NBAOnboardingTask!
  selectCardOptions: [NBAOnboardingCardOption!]!
  leaderboard: NBALeaderboard
}
type NBAOnboardingCardOption {
  player: NBAPlayer!
  commonCardImageUrl: String!
}
type NBAPlayer implements PlayerInterface {
  id: UUID!
  slug: String!
  birthDate: Time!
  age: Int!
  birthPlaceCountry: String!
  displayName: String!
  firstName: String!
  lastName: String!
  shirtNumber: Int!
  positions: [NBAPlayerPosition!]!
  team: NBATeam
  avatarImageUrl: String!
  latestFinalGameStats(last: Int!): [NBAPlayerGameStats!]!
  latestFinalFixtureStats(last: Int!): [NBAPlayerInFixture!]! @deprecated(reason: "use latestFixtureStats")
  latestFixtureStats(last: Int!): [NBAPlayerInFixture!]!
  fixtureGames(fixtureSlug: String!): [NBAGame!]! @deprecated(reason: "use PlayerInFixture.upcomingGames")
  upcomingGames(next: Int!): [NBAGame!]!
  inFixture(fixtureSlug: String!): NBAPlayerInFixture
  tenGameAverage: Int! @deprecated(reason: "use NBAPlayer.tenGameAverageGameStats.score")
  tenGameAverageGameStats: NBAPlayerAverageGameStats!
  isActive: Boolean!
  playerInjury: PlayerInjury
  cards(first: Int! = 100, after: String, positions: [NBAPlayerPosition!], rarities: [CardRarity!]): NBACardConnection!
  pictureUrl: String!
}
type NBAPlayerAverageGameDetailedStats {
  points: Float!
  rebounds: Float!
  assists: Float!
  blocks: Float!
  steals: Float!
  turnovers: Float!
  made3PointFGs: Float!
  doubleDoubles: Float!
  tripleDoubles: Float!
  secondsPlayed: Float!
}
type NBAPlayerAverageGameStats {
  score: Float!
  detailedStats: NBAPlayerAverageGameDetailedStats
  detailedScores: NBAPlayerGameDetailedScores
}
type NBAPlayerFixtureStatsConnection {
  nodes: [NBAPlayerInFixture!]!
  pageInfo: PageInfo!
}
type NBAPlayerGameDetailedScores {
  points: Float!
  rebounds: Float!
  assists: Float!
  blocks: Float!
  steals: Float!
  turnovers: Float!
  fieldGoalAttempts: Float!
  freeThrowAttempts: Float!
  made3PointFGs: Float!
  doubleDoubles: Float!
  tripleDoubles: Float!
}
type NBAPlayerGameDetailedStats {
  points: Int!
  rebounds: Int!
  assists: Int!
  blocks: Int!
  steals: Int!
  turnovers: Int!
  made3PointFGs: Int!
  doubleDoubles: Int!
  tripleDoubles: Int!
  minutes: String @deprecated(reason: "use secondsPlayed")
  secondsPlayed: Int!
}
type NBAPlayerGameStats implements PlayerGameStatsInterface {
  score: Float!
  playedInGame: Boolean!
  detailedStats: NBAPlayerGameDetailedStats
  detailedScores: NBAPlayerGameDetailedScores
  game: NBAGame!
  team: NBATeam!
  againstTeam: NBATeam!
  scoreForScoringStrategy(strategy: String): Float!
}
type NBAPlayerInFixture implements PlayerInFixtureInterface {
  fixture: NBAFixture!
  player: NBAPlayer!
  score: Float!
  status: NBAPlayerInFixtureStatus!
  tenGameAverage: Int!
}
type NBAPlayerInFixtureStatus implements PlayerInFixtureStatusInterface {
  gameStats: [NBAPlayerGameStats!]!
  upcomingGames: [NBAGame!]!
  inGame: Boolean!
  isScoreFinal: Boolean!
  statusIconType: PlayerInFixtureStatusIconType!
  hasTBDGames: Boolean!
}
type NBAReferralReward implements SportsNode & ReferralRewardInterface {
  id: UUID!
  card: NBACard!
  state: RewardState!
}
type NBAReward implements RewardInterface {
  id: UUID!
  card: NBACard!
  backImageUrl: String!
  tier: Int!
  lineup: NBALineup!
  state: RewardState!
}
type NBATeam implements SportsTeamInterface {
  id: UUID!
  name: String!
  market: String!
  fullName: String!
  slug: String!
  svgUrl: String!
  monochromeSvgUrl: String!
  teamStyleGuidePrimaryColor: HexColorCode!
  players: [NBAPlayer!]!
  abbreviation: String!
}
"So5 No Card Route Config"
type NoCardRoute {
  cardCountsByRarity: CardCount!
  emailAddress: String!
  id: ID!
  maxLineupsPerUser: Int!
  nextCloseDate: ISO8601DateTime
  nextOpenDate: ISO8601DateTime
}
type NoCardRouteInfo {
  emailAddress: String!
  isRouteOpen: Boolean!
  maxLineupsPerUser: Int!
  gameWeek: Int!
  cardCountsByRarity: CardCountsByRarity!
}
"The connection type for Notification."
type NotificationConnection {
  "A list of edges."
  edges: [NotificationEdge]
  "A list of nodes."
  nodes: [Notification]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type NotificationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Notification
}
"A Sorare user notification preference"
type NotificationPreference {
  defaultValue: Json!
  name: String!
  value: Json
  values: [Json!]!
}
"The entrypoint for notifications information"
type Notifications {
  notifications(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NotificationConnection!
  unreadCount: Int!
}
"An OAuth access token"
type OAuthAccessToken {
  application: OAuthApplication!
  createdAt: ISO8601DateTime!
  expiresAt: ISO8601DateTime
  id: String!
  scopes: [String!]!
}
"An OAuth application"
type OAuthApplication {
  name: String!
  pictureUrl(derivative: String = null): String
  scopes: String
}
"An Offer"
type Offer implements Node & OfferInterface {
  aasmState: String!
  acceptedAt: ISO8601DateTime
  blockchainId: String
  cancelledAt: ISO8601DateTime
  counteredOffer: Offer
  createdAt: ISO8601DateTime!
  creditCardFee: Float!
  endDate: ISO8601DateTime!
  id: ID!
  marketFeeWeiAmount: WeiAmount!
  receiveCards: [Card!]!
  receiveWeiAmount: String
  "Receive Amount in fiat currencies. Not broadcastable for performance reasons."
  receiveWeiAmountInFiat: Fiat
  receiver: Ownerable
  sendCards: [Card!]!
  sendWeiAmount: String
  "Send Amount in fiat currencies. Not broadcastable for performance reasons."
  sendWeiAmountInFiat: Fiat
  sender: Ownerable!
  startDate: ISO8601DateTime!
  tokenOffer: TokenOffer!
  trade: TokenTrade
}
"The connection type for Offer."
type OfferConnection {
  "A list of edges."
  edges: [OfferEdge!]!
  "A list of nodes."
  nodes: [Offer!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}
"An edge in a connection."
type OfferEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Offer
}
"A user notification regarding an Offer"
type OfferNotification implements Node & NotificationInterface {
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
  offer: Offer! @deprecated(reason: "Use tokenOffer instead")
  read: Boolean!
  sport: Sport
  tokenOffer: TokenOffer!
  user: CurrentUser!
}
"An object representing the state of a user onboarding"
type Onboarding {
  completed: Boolean!
  enabled: Boolean!
  id: ID!
  skipped: Boolean!
  specialEventCompleted: Boolean! @deprecated(reason: "Was used for global cup 22")
  specialEventStarted: Boolean! @deprecated(reason: "Was used for global cup 22")
  tasks: [OnboardingTask!]!
}
"A competition draftable during onboarding"
type OnboardingCompetition {
  commonDraftCampaign: CommonDraftCampaign
  competition: Competition!
  slug: String!
}
"An object representing the state of a task in the user onboarding"
type OnboardingTask {
  drop: [CardDrop!]
  forced: Boolean!
  id: ID!
  name: OnboardingTaskEnum!
  state: OnboardingTaskState!
  steps: [OnboardingStepEnum!]!
}
"A list of best So5Score by position"
type OrderedSo5Scores {
  position: String!
  positionTyped: Position!
  so5Scores: [So5Score!]!
}
"A Mangopay other bank account type"
type OtherBankAccount implements BankAccountInterface & Node {
  "Account number (last 4 digits)"
  accountNumber: String!
  "Bank Identifier Code"
  bic: String!
  country: Country!
  id: ID!
  ownerAddress: MangopayBankAccountOwnerAddress
  ownerName: String
}
"An object representing the past or present ownership of a card by a user or a contract"
type Owner implements Node & OwnerInterface {
  account: Account
  address: String!
  blockchain: String!
  card: Card!
  from: ISO8601DateTime!
  id: ID!
  optimistic: Boolean!
  "Card price, in wei."
  price: String!
  referenceId: String
  settleAt: ISO8601DateTime
  transferType: String!
}
"An owner with conversion rates"
type OwnerWithRates implements Node & OwnerInterface {
  account: Account
  address: String!
  blockchain: String!
  card: Card!
  from: ISO8601DateTime!
  id: ID!
  optimistic: Boolean!
  "Card price, in wei."
  price: String!
  priceInFiat: Fiat!
  referenceId: String
  settleAt: ISO8601DateTime
  transferType: String!
}
"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}
type PasswordEncryptedPrivateKey {
  iv: String!
  payload: String!
  salt: String!
}
"A payment intent"
type Payment implements Node {
  aasmState: PaymentIntentState!
  amount: String!
  amountInFiat: Fiat! @deprecated(reason: "Use fiatAmount instead")
  creditCardReceiptAvailable: Boolean!
  creditCardReceiptSent: Boolean!
  fiat: Boolean!
  fiatAmount: Int
  fiatCurrency: FiatCurrency
  fiatReceiptUrl: String
  id: ID!
  operation: PaymentIntentOperation @deprecated(reason: "Use tokenOperation instead")
  spentAt: ISO8601DateTime!
  tokenOperation: PaymentIntentTokenOperation
  user: User!
}
"The connection type for Payment."
type PaymentConnection {
  "A list of edges."
  edges: [PaymentEdge!]!
  "A list of nodes."
  nodes: [Payment!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type PaymentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Payment
}
"Payment Method"
type PaymentMethod {
  card: CreditCard!
  id: String!
}
"A pending deposit to user's wallet"
type PendingDeposit {
  amount: String!
  amountInFiat: Fiat!
  amounts: MonetaryAmount!
  date: ISO8601DateTime!
  feeAmounts: MonetaryAmount
  id: String!
  providerType: DepositProvider!
  status: DepositStatus!
  "Will be null if deposit is not external"
  transactionHash: String
}
"A pickable player"
type PickablePlayer {
  id: ID!
  pictureUrl: String!
  player: Player!
}
"Autogenerated return type of pickActionRewardPlayers."
type pickActionRewardPlayersPayload {
  actionReward: ActionReward
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"A professional football player"
type Player implements Node & WithMemberships & WithPublicCardsInterface & WithSubscriptionsInterface {
  activeClub: Club
  activeClubMembership: Membership
  activeInjuries: [Injury!]!
  activeNationalTeam: NationalTeam
  activeSuspensions: [Suspension!]!
  age: Int!
  "All player So5Scores ordered by descending game date"
  allSo5Scores(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,position: Position  ): So5ScoreConnection!
  appearances: Int!
  averageScore(position: Position, type: AveragePlayerScore!): Float
  beforeLastOwningMembership: Membership
  bestFoot: String
  birthDate: ISO8601DateTime
  cardPositions: [Position!]!
  "Cards of this player that are owned by a manager. Updated once a day."
  cardSupply: [CardSeasonSupply!]!
  "The `cards` field cannot be nested within a list."
  cards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,age: Int, assetIds: [String!], 
    "Returns the elements in the list that come before the specified cursor."
    before: String,customCardEditionName: String, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): CardConnection!
  careerSeasons(
    "If defined only return seasons for competitions of that type"
    type: CompetitionType = null
  ): [Season!]!
  clubMemberships: [Membership!]!
  country: Country!
  currentSeason: Season
  currentUserSubscription: EmailSubscription
  displayName: String!
  firstName: String!
  gameForLeaderboard(so5LeaderboardSlug: String!): Game
  gameStats(last: Int!, lowCoverage: Boolean = true): [PlayerGameStats]!
  gamesForLeaderboard(so5LeaderboardSlug: String!): [Game!]!
  height: Int
  id: ID!
  injuries: [Injury!]!
  lastClub: Club
  lastFifteenSo5Appearances: Int
  lastFiveSo5Appearances: Int
  lastName: String!
  matchName: String!
  memberships: [Membership!]!
  optaId: String
  pictureUrl(derivative: String = "tinified"): String
  playingStatus: PlayerPlayingStatus
  position: Position!
  positionTyped: Position!
  "Returns the 3 most followed players in the player's club The `related_players` field cannot be nested within a list."
  relatedPlayers: [Player!]!
  shirtNumber: Int
  slug: String!
  "So5Score of a player with his current position for a specific Game"
  so5Score(gameId: ID!, position: Position): So5Score
  "Up to 10 last So5Scores used in a So5Fixture"
  so5Scores(last: Int!, lowCoverage: Boolean = true, position: Position): [So5Score]!
  stats(seasonStartYear: Int!): Stats
  status: PlayerStatus! @deprecated(reason: "Use fields on player directly")
  subscriptionsCount: Int!
  suspensions: [Suspension!]!
  user: User
  weight: Int
}
type PlayerAgeRequirements {
  minAge: Int
  maxAge: Int
}
"The connection type for Player."
type PlayerConnection {
  "A list of edges."
  edges: [PlayerEdge!]!
  "A list of nodes."
  nodes: [Player!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type PlayerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Player
}
"Stats of a player for a game"
type PlayerGameStats implements Node {
  accuratePass: Int
  cleanSheet: Int
  crossAccuracy: Int
  duelWon: Int
  effectiveClearance: Int
  formationPlace: Int
  fouls: Int
  game: Game!
  gameStarted: Int
  goalAssist: Int
  goalKicks: Int
  goals: Int
  goalsConceded: Int
  id: ID!
  live: Boolean!
  lostCorners: Int
  minsPlayed: Int
  onGameSheet: Boolean!
  ontargetScoringAtt: Int
  ownGoals: Int
  parries: Int
  passAccuracy: Int
  penaltiesSaved: Int
  penaltyKickMissed: Int
  penaltySave: Int
  player: Player!
  redCard: Int
  reviewed: Boolean!
  saves: Int
  shotAccuracy: Int
  shotEfficiency: Int
  singleGoalGame: Int
  so5Score(
    "Position of the so5Score"
    position: String
  ): So5Score
  team: Team!
  totalClearance: Int
  totalPass: Int
  totalScoringAtt: Int
  totalTackle: Int
  wasFouled: Int
  wonContest: Int
  yellowCard: Int
}
type PlayerInjury {
  status: String!
  description: String!
  comment: String!
  startDate: String!
  updateDate: String! @deprecated(reason: "use updateDateTime")
  updateDateTime: Time
}
"Represents a list of players available for a minting quota"
type PlayerPool {
  common: TieredPlayerPool
  computedAt: ISO8601DateTime!
  customSeries: TieredPlayerPool
  limited: TieredPlayerPool
  rare: TieredPlayerPool
  superRare: TieredPlayerPool
  unique: TieredPlayerPool
}
"Player status based on latest games he has played"
type PlayerStatus implements Node {
  id: ID!
  lastFifteenSo5Appearances: Int
  lastFifteenSo5AverageScore: Float
  lastFiveSo5Appearances: Int
  lastFiveSo5AverageScore: Float
  playingStatus: String
}
"A professional football player with current season supply"
type PlayerWithSupply {
  availableSupply: Int
  player: Player!
  slug: String!
}
"A Sorare user postal address"
type PostalAddress {
  additionalAddress: String
  city: String
  company: String
  countryCode: String
  firstName: String
  lastName: String
  streetAddress: String
  zipcode: String
}
"An object representing the breakdown of the power of a Card"
type PowerBreakdown {
  captain: String!
  collection: String!
  fidelity: String!
  fitness: String!
  scarcity: String!
  season: String!
  version: Int!
  xp: String!
}
"Autogenerated return type of prepareAcceptOffer."
type prepareAcceptOfferPayload {
  authorizations: [AuthorizationRequest!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  limitOrders: [LimitOrder!]
}
"Autogenerated return type of prepareBid."
type prepareBidPayload {
  authorizations: [AuthorizationRequest!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  limitOrders: [LimitOrder!]
}
"Autogenerated return type of prepareCardWithdrawal."
type prepareCardWithdrawalPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  transferRequest: TransferRequest
}
"Autogenerated return type of prepareEthDeposit."
type prepareEthDepositPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  ethDeposit: EthDeposit
}
"Autogenerated return type of prepareFastWithdrawal."
type prepareFastWithdrawalPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  fastWithdrawal: FastWithdrawal
}
"Autogenerated return type of prepareOffer."
type prepareOfferPayload {
  authorizations: [AuthorizationRequest!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  "List of LimitOrder objects used as payload to sign for the `createSingleSaleOffer` or `createDirectOffer` mutations."
  limitOrders: [LimitOrder!]
}
"Autogenerated return type of prepareTokenDeposit."
type prepareTokenDepositPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  tokenDeposit: TokenDeposit
}
"A Mangopay Pre Registration Data"
type PreRegistrationData {
  accessKey: String!
  cardRegistrationUrl: String!
  data: String!
  id: String!
}
"Recovery option for a UserWallet."
type PrivateKeyRecoveryOption implements Node {
  destination: String!
  id: ID!
  method: PrivateKeyRecoveryOptionMethodEnum!
  status: PrivateKeyRecoveryOptionStatusEnum!
}
type PrivateKeyRecoveryPayload {
  encryptionKey: String!
  iv: String!
  ivTemp: String!
  payload: String!
}
type PrizeCreditsLevel {
  from: PrizePoolPrizeLevelBoundary!
  to: PrizePoolPrizeLevelBoundary!
  fromLineup: CumulativeLeaderboardRank
  toLineup: CumulativeLeaderboardRank
  prizeCredits: Int!
  irlPrizes: [IRLPrize!]!
}
type PrizeLevel {
  from: PrizePoolPrizeLevelBoundary!
  to: PrizePoolPrizeLevelBoundary!
  rarity: CardRarity! @deprecated(reason: "use cardRarity")
  cardRarity: CardRarity
  tier: Int! @deprecated(reason: "use cardTier")
  cardTier: Int
  cashRewardOnly: Boolean!
}
type PrizePoolPodiumPrize {
  rank: Int!
  rarity: CardRarity! @deprecated(reason: "use cardRarity")
  cardRarity: CardRarity
  tier: Int! @deprecated(reason: "use cardTier")
  cardTier: Int
  cashRewardOnly: Boolean!
}
type PrizePoolPrizeLevelBoundary {
  rank: Int!
  isPercent: Boolean!
}
type ProjectedReward {
  rarity: CardRarity!
  tier: Int!
}
type Query {
  "Get a list of all cards"
  allCards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,age: Int, assetIds: [String!], 
    "Returns the elements in the list that come before the specified cursor."
    before: String,customCardEditionName: String, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): CardConnection!
  "Get latest announcements"
  announcements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filters announcements by ids"
    announcementIds: [String!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters announcements by sports"
    sports: [Sport!]
  ): AnnouncementConnection!
  "Get a bundled auction"
  bundledAuction(slug: String!): BundledAuction! @deprecated(reason: "use tokens.auction")
  "Get a card"
  card(slug: String!): Card! @deprecated(reason: "Use the field on Football type instead")
  "Get a card with its asset ID"
  cardByAssetId(assetId: String!): Card! @deprecated(reason: "Use the field on Football type instead")
  "Get a card with its blockchain ID"
  cardByBlockchainId(blockchainId: String!): Card! @deprecated(reason: "Use the field on Football type instead")
  "Get a list of cards"
  cards(age: Int, assetIds: [String!], customCardEditionName: String, owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): [Card!]!
  "Get a club"
  club(slug: String!): Club! @deprecated(reason: "Use the field on Football type instead")
  "Get a list of clubs"
  clubs(slugs: [String!]!): [Club!]! @deprecated(reason: "Use the field on Football type instead")
  "Get the list of clubs that are released and minted"
  clubsReady: [Club!]! @deprecated(reason: "Use the field on Football type instead")
  "Get a Competition"
  competition(slug: String!): Competition! @deprecated(reason: "Use the field on Football type instead")
  "Get config"
  config: Config!
  "Get a list of countries"
  countries(slugs: [String!]!): [Country!]!
  "Get a country"
  country(slug: String!): Country!
  "Get the current block height of Ethereum blockchain"
  currentBlockHeight: Int!
  "Fetch the current user."
  currentUser: CurrentUser
  "Get a CustomDeck"
  customDeck(name: String, slug: String): CustomDeck!
  "Get a DeckInFormation"
  deckInFormation(slug: String!): DeckInFormation!
  "Get an english auction"
  englishAuction(slug: String!): BundledAuction! @deprecated(reason: "use tokens.auction")
  "Get a list of cards owned by an ethereum account"
  ethereumCards(address: String!): [Card!]! @deprecated(reason: "Use the field on Football type instead")
  "Get a list of tokens owned by an ethereum account"
  ethereumTokens(address: String!): [Token!]!
  featuredSo5Fixtures(first: Int): [So5Fixture!]! @deprecated(reason: "Moved into so5")
  football: FootballRoot!
  "Get a potential referrer for a given name"
  fullReferrer(name: String!): Referrer
  "Get a Game"
  game(id: ID!): Game! @deprecated(reason: "Use the field on Football type instead")
  leaguesOpenForGameStats: [Competition!]! @deprecated(reason: "Use the field on Football type instead")
  mangopay: MangopayRoot!
  "Get a national team"
  nationalTeam(slug: String!): NationalTeam! @deprecated(reason: "Use the field on Football type instead")
  "Get a list of national teams"
  nationalTeams(slugs: [String!]!): [NationalTeam!]! @deprecated(reason: "Use the field on Football type instead")
  "Get the next batch nonce for a given address"
  nextRelayBatchNonce(address: String!): Int!
  "Fetches an object given its ID."
  node(
    "ID of the object."
    id: ID!
  ): Node
  "Fetches a list of objects given a list of IDs."
  nodes(
    "IDs of the objects."
    ids: [ID!]!
  ): [Node]!
  "Get an OAuth application from the client id"
  oauthApplication(clientId: String!): OAuthApplication!
  "Get a player"
  player(slug: String!): Player! @deprecated(reason: "Use the field on Football type instead")
  "Get a list of players"
  players(slugs: [String!]!): [Player!]! @deprecated(reason: "Use the field on Football type instead")
  "Get a potential referrer for a given name"
  referrer(name: String!): String
  "Get information needed to screenshot a card"
  screenshottableCard(id: ID!, serialNumber: Int): ScreenshottableCard!
  "Get a season"
  season(startYear: Int!): Season! @deprecated(reason: "Use the field on Football type instead")
  "Get paginated available shop items"
  shopItems(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: ShopItemsSortInput, types: [ShopItemType!], unlockedOnly: Boolean  ): ClubShopItemConnection!
  so5: So5Root! @deprecated(reason: "use football.so5")
  "Get an So5Appearance"
  so5Appearance(id: ID!): So5Appearance! @deprecated(reason: "Use the field on football.so5 instead")
  so5Fixture(id: ID, slug: String, type: So5State): So5Fixture @deprecated(reason: "Moved into so5")
  "Get a So5Leaderboard"
  so5Leaderboard(slug: String!): So5Leaderboard! @deprecated(reason: "Use the field on football.so5 instead")
  "Get a So5League"
  so5League(slug: String!): So5League! @deprecated(reason: "Use the field on football.so5 instead")
  "Get a So5Lineup"
  so5Lineup(id: ID!): So5Lineup! @deprecated(reason: "Use the field on football.so5 instead")
  "Get a So5Ranking"
  so5Ranking(id: ID!): So5Ranking! @deprecated(reason: "Use the field on football.so5 instead")
  "Get a So5Reward"
  so5Reward(slug: String!): So5Reward! @deprecated(reason: "Use the field on football.so5 instead")
  "Get a So5Score"
  so5Score(id: ID!): So5Score! @deprecated(reason: "Use the field on football.so5 instead")
  "Get a Starkware account."
  starkwareAccount(starkKey: String!): StarkwareAccount!
  "Get subscription statistics for a subscribable, like a Player or a Card"
  subscriptionStats(subscribable: SubscribableInput!): SubscriptionStats!
  tokens: TokenRoot!
  transferMarket: TransferMarket! @deprecated(reason: "use tokens")
  "Get a user."
  user(slug: String!): User!
  "Get a user by ID."
  userById(id: String!): User!
  "Get a list of users."
  users(slugs: [String!]!): [User!]!
  currentSportsUser: CurrentSportsUser @deprecated(reason: "use currentUser")
  sportsUser(id: UUID!): User
  cumulativeLeaderboardRank(id: UUID!): CumulativeLeaderboardRank
  currentNBAUser: CurrentNBAUser @deprecated(reason: "use currentSportsUser")
  nbaCard(slug: String!): NBACard
  nbaCards(ids: [ID!], assetIds: [ID!], input: NBACardsInput, slugs: [String!]): [NBACard!]!
  nbaFixture(slug: String!): NBAFixture
  nbaLeaderboard(slug: String!): NBALeaderboard
  nbaLineup(id: UUID!): NBALineup
  nbaLiveFixture: NBAFixture
  nbaOpenFixture: NBAFixture
  nbaPastFixtures(first: Int! = 100, after: String): NBAFixtureConnection!
  nbaPlayer(slug: String!): NBAPlayer
  nbaPlayers(slugs: [String!]): [NBAPlayer!]!
  nbaReferralRewards(referralIDs: [UUID!]!): [NBAReferralReward!]!
  nbaTeam(slug: String!): NBATeam
  baseballCard(slug: String!): BaseballCard
  baseballCards(slugs: [String!], ids: [String!], assetIds: [String!]): [BaseballCard!]!
  baseballFixture(slug: String!): BaseballFixture
  baseballLeaderboard(slug: String!): BaseballLeaderboard
  baseballLiveFixture: BaseballFixture
  baseballOpenFixture: BaseballFixture
  baseballPastFixtures(first: Int! = 100, after: String): BaseballFixtureConnection!
  baseballPlayer(slug: String!): BaseballPlayer
  baseballPlayers(slugs: [String!]): [BaseballPlayer!]!
  baseballReferralRewards(referralIDs: [UUID!]!): [BaseballReferralReward!]
  baseballTeam(slug: String!): BaseballTeam
  baseballLineup(id: UUID!): BaseballLineup
}
type Range {
  "Max price, in wei."
  max: String!
  "Min price, in wei."
  min: String!
}
type RarityCount {
  count: Int!
  rarity: Rarity!
}
"A recovery kit shop item to give back fitness bonus to a card"
type RecoveryKitShopItem implements Node & ShopItemInterface {
  cardCollectionRequirements: [CardCollectionRequirement!]!
  createdAt: ISO8601DateTime!
  description: String
  disabled: Boolean!
  expirationDate: ISO8601DateTime
  id: ID!
  limitPerUser: Int!
  myAvailableTotalPurchasesCount: Int!
  myAvailableUserShopItems: [UserShopItem!]
  myBalance: Int!
  myLimitResetAt: ISO8601DateTime
  myPurchasesCount: Int!
  name: String!
  pictureUrl: String!
  position: ShopItemType!
  price: Int!
  quantity: Int!
  salePrice: Int
  shopItemsRequired: [ShopItem!]!
  unlocked: Boolean!
}
"A referral"
type Referral implements Node {
  aasmState: String!
  completedAt: ISO8601DateTime
  expirationDate: ISO8601DateTime!
  id: ID!
  referee: User!
  refereeCardsBoughtAtAuctionCount: Int!
  refereeConfirmedAt: ISO8601DateTime
  refereeIdentification: String
  refereeInvitationSentAt: ISO8601DateTime
  refereeSportCardsBoughtAtAuctionCount(sport: Sport!): Int! @deprecated(reason: "Use refereeSportCardsBoughtFromPrimaryMarketCount instead")
  refereeSportCardsBoughtFromPrimaryMarketCount(sport: Sport!): Int!
  referrer: Referrer!
  referrerReward: ReferralReward
  sport: Sport
}
"A Referral campaign"
type ReferralCampaign implements Node {
  cardsCount: Int
  competitions: [Competition!]!
  endDate: ISO8601DateTime!
  id: ID!
  playerPoolUrl: String
  playingStatuses: [String!]
  startDate: ISO8601DateTime!
  teams: [Team!]!
  tiers: [CardQuality!]
}
"A referral milestone reward"
type ReferralMilestoneReward implements Node {
  id: ID!
  referralNumber: Int!
  reward: ReferralReward
  rewardRarity: Rarity!
  rewardTier: CardQuality
  sport: Sport!
}
type ReferralPaginated {
  currentPage: Int!
  id: String!
  pages: Int!
  referrals: [Referral!]!
  totalCount: Int!
}
"A referral reward"
type ReferralReward implements Node {
  card: Card
  conversionCredit: ConversionCredit
  conversionCreditId: String
  id: ID!
  shippingState: ShippingState!
  token: Token
}
"A user notification regarding a referral reward"
type ReferralRewardNotification implements Node & NotificationInterface {
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
  read: Boolean!
  referralReward: ReferralReward!
  sport: Sport
  user: CurrentUser!
}
"Autogenerated return type of refreshAward."
type refreshAwardPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of rejectOffer."
type rejectOfferPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  offer: Offer @deprecated(reason: "Use tokenOffer instead")
  "The sport-agnostic offer"
  tokenOffer: TokenOffer
}
"Autogenerated return type of relayCall."
type relayCallPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser!
  errors: [UserError!]!
  transaction: EthereumTransaction
}
"Autogenerated return type of removeCardFromDeck."
type removeCardFromDeckPayload {
  card: Card
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  deck: DeckInterface
  errors: [UserError!]!
}
"Autogenerated return type of removeUserFromSo5UserGroup."
type removeUserFromSo5UserGroupPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  so5UserGroup: So5UserGroup
}
"Autogenerated return type of reportTelemetry."
type reportTelemetryPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
}
"Autogenerated return type of requestReceipt."
type requestReceiptPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  payment: Payment
}
"Autogenerated return type of requestSo5NoCardLineupEligibleLeaderboards."
type requestSo5NoCardLineupEligibleLeaderboardsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  so5NoCardLineup: So5NoCardLineup
}
"Autogenerated return type of resendConfirmationInstructions."
type resendConfirmationInstructionsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of resendVerificationCode."
type resendVerificationCodePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of resetPrivateKey."
type resetPrivateKeyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser!
  errors: [UserError!]!
}
"ResponsiveBanner metadata"
type ResponsiveBanner {
  auctionDrop: AuctionDrop
  backgroundImageUrl: String!
  dark: Boolean
  description: String!
  id: String!
  mobileBackgroundImageUrl: String!
  primaryButton: String!
  primaryButtonLabel: String!
  secondaryButton: String
  secondaryButtonLabel: String
  title: String!
}
"A collection of responsive banners"
type ResponsiveBannersSet {
  id: String!
  responsiveBanners: [ResponsiveBanner!]!
  title: String!
}
"Autogenerated return type of restoreWallet."
type restoreWalletPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser!
  errors: [UserError!]!
}
"Autogenerated return type of resumeOnboarding."
type resumeOnboardingPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of revokeDevice."
type revokeDevicePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of revokeOAuthAccessToken."
type revokeOAuthAccessTokenPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"A rewarded card"
type RewardCard implements Node {
  backPictureUrl: String
  card: Card
  id: ID!
  pictureUrl: String
  quality: String
  so5Reward: So5Reward
  upgradedQuality: String
}
"Aggregated rewards overview"
type RewardsOverview {
  cards: Json!
  experiences: Json
  experiencesDetails: [So5RewardExperience!]!
  prizePool: Float!
  prizePoolCurrency: PaymentCurrency!
}
"A user notification regarding a Sale"
type SaleNotification implements Node & NotificationInterface {
  buyer: User
  card: Card
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
  priceInWei: String!
  read: Boolean!
  seller: User!
  sport: Sport
  token: Token!
  user: CurrentUser!
}
"Information needed for a card screenshot"
type ScreenshottableCard {
  age: Int!
  baseballPositions: [BaseballPosition!]
  birthPlaceCountry: String!
  cardEditionName: String!
  cropped: Boolean!
  footballPosition: FootballPosition
  layout: CardLayout!
  nbaPositions: [NBAPosition!]
  playerDisplayName: String!
  playerPicture: SeasonPicture!
  position: String @deprecated(reason: "Use baseballPositions, footballPosition or nbaPositions")
  rarity: Rarity!
  rookie: Boolean!
  season: Int!
  serialNumber: Int!
  shirtNumber: Int!
  singleCivilYear: Boolean!
  sport: Sport!
  teamPictureUrl: String!
  teamShortName: String!
}
"A football season"
type Season implements Node & WithPublicCardsInterface {
  "The `cards` field cannot be nested within a list."
  cards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,age: Int, assetIds: [String!], 
    "Returns the elements in the list that come before the specified cursor."
    before: String,customCardEditionName: String, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): CardConnection!
  id: ID!
  name: String!
  startYear: Int!
}
type SeasonCount {
  count: Int!
  season: Season!
}
"A player season picture"
type SeasonPicture implements Node {
  backgroundUrl: String
  chinY: Float
  chinYTarget: Int
  eyeLeft: FaceLandmark!
  eyeRight: FaceLandmark!
  height: Int!
  id: ID!
  kit: String
  nose: FaceLandmark!
  offsetX: Int!
  offsetY: Int!
  pictureUrl(derivative: String = "tinified"): String
  positioning: PicturePositioning!
  width: Int!
  zoom: Float
}
"Autogenerated return type of sendWalletRecovery."
type sendWalletRecoveryPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of setDeviceToken."
type setDeviceTokenPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
}
"Autogenerated return type of setLiveActivityToken."
type setLiveActivityTokenPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
}
"A shop item to customize a user gallery"
type ShopItem implements Node & ShopItemInterface {
  cardCollectionRequirements: [CardCollectionRequirement!]!
  color: String
  createdAt: ISO8601DateTime!
  description: String
  disabled: Boolean!
  expirationDate: ISO8601DateTime
  id: ID!
  limitPerUser: Int!
  myAvailableTotalPurchasesCount: Int!
  myAvailableUserShopItems: [UserShopItem!]
  myBalance: Int!
  myLimitResetAt: ISO8601DateTime
  myPurchasesCount: Int!
  name: String!
  pictureUrl: String!
  position: ShopItemType!
  price: Int!
  salePrice: Int
  shopItemsRequired: [ShopItem!]!
  unlocked: Boolean!
}
"Autogenerated return type of signIn."
type signInPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  otpSessionChallenge: String
  "tcuToken is returned when the user must accept the TCUs before signing in"
  tcuToken: String
}
"Autogenerated return type of signInWithOAuth."
type signInWithOAuthPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of signOutFromAllDevices."
type signOutFromAllDevicesPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
}
"Autogenerated return type of signUp."
type signUpPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"An Single Sale Offer on a Card"
type SingleSaleOffer implements Node & OfferInterface {
  aasmState: String!
  acceptedAt: ISO8601DateTime
  acceptor: User
  blockchainId: String
  cancelledAt: ISO8601DateTime
  card: Card @deprecated(reason: "Use token instead")
  createdAt: ISO8601DateTime!
  creditCardFee: Float!
  endDate: ISO8601DateTime!
  id: ID!
  marketFeeWeiAmount: WeiAmount!
  open: Boolean!
  price: WeiAmount!
  priceInFiat: Fiat!
  sender: Ownerable!
  startDate: ISO8601DateTime!
  token: Token!
  tokenOffer: TokenOffer!
  trade: TokenTrade
}
"The connection type for SingleSaleOffer."
type SingleSaleOfferConnection {
  "A list of edges."
  edges: [SingleSaleOfferEdge!]!
  "A list of nodes."
  nodes: [SingleSaleOffer!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}
"An edge in a connection."
type SingleSaleOfferEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SingleSaleOffer
}
type SkinShopItem implements Node & ShopItemInterface {
  cardCollectionRequirements: [CardCollectionRequirement!]!
  color: String
  createdAt: ISO8601DateTime!
  description: String
  disabled: Boolean!
  expirationDate: ISO8601DateTime
  id: ID!
  limitPerUser: Int!
  myAvailableTotalPurchasesCount: Int!
  myAvailableUserShopItems: [UserShopItem!]
  myBalance: Int!
  myLimitResetAt: ISO8601DateTime
  myPurchasesCount: Int!
  name: String!
  pictureUrl: String!
  position: ShopItemType!
  price: Int!
  salePrice: Int
  shopItemsRequired: [ShopItem!]!
  unlocked: Boolean!
}
"Autogenerated return type of skipOnboarding."
type skipOnboardingPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"A SO5 Appearance - a card selected in a team for a SO5 fixture"
type So5Appearance implements Node {
  bonus: Float
  captain: Boolean!
  card: Card!
  cleanScore: Float
  eligibleSo5Scores: [So5Score!]!
  game: Game
  id: ID!
  playerGameStats: PlayerGameStats
  relevantStats: Json!
  so5Fixture: So5Fixture!
  so5Lineup: So5Lineup!
  so5Score: So5Score
  status: String!
}
"The at least of clubs rule of a So5Leaderboard"
type So5AtLeastOfClubs {
  clubs: [Club!]!
  min: Int!
}
"The at least of competitions rule of a So5Leaderboard"
type So5AtLeastOfCompetitions {
  competitions: [Competition!]!
  min: Int!
}
"Common draft validation errors"
type So5CommonDraftError {
  code: Int!
  error: String!
  message: String!
  printablePlayers: [DraftablePlayer!]!
}
"Common draft swap validation errors"
type So5CommonDraftSwapError {
  code: Int!
  error: String!
  message: String!
}
"So5 Global Config"
type So5Config {
  cardCollections: [CardCollection!]!
  id: ID!
  managerHomeContentUnitsSets: [ContentUnitsSet!]!
  "Fetch teams playing in the upcoming So5 Fixture"
  nextSo5FixtureTeams: [Team!]!
  noCardRoute: NoCardRoute!
  noCardRouteEmail: String! @deprecated(reason: "noCardRoute.emailAddress")
  so5LeaguesAlgoliaFilters: Json!
  "List of all the possible tournament rarity types"
  tournamentRarityTypes: [String!]!
  "List of all the possible tournament types"
  tournamentTypes: [String!]!
}
"A SO5 fixture"
type So5Fixture implements Node {
  aasmState: String!
  canCompose: Boolean!
  cutOffDate: ISO8601DateTime!
  displayName: String!
  endDate: ISO8601DateTime!
  eventType: String!
  gameWeek: Int!
  "The `games` field cannot be nested within a list."
  games: [Game!]!
  hashedSalt: String
  id: ID!
  "The `my_so5_games` field cannot be nested within a list."
  mySo5Games: [Game!]!
  mySo5Lineups(draft: Boolean, so5LeaderboardSlug: String, sortType: CustomSortingOption, withTraining: Boolean): [So5Lineup!]!
  "The `my_so5_lineups_count` field cannot be nested within a list."
  mySo5LineupsCount(draft: Boolean, so5LeaderboardSlug: String, training: Boolean): Int!
  mySo5LineupsPaginated(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,draft: Boolean, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,so5LeaderboardSlug: String, sortType: CustomSortingOption, withTraining: Boolean  ): So5LineupConnection!
  mySo5Rankings(withDraft: Boolean, withTraining: Boolean): [So5Ranking!]!
  mySo5Rewards: [So5Reward!]!
  "The `my_so5_user_groups` field cannot be nested within a list."
  mySo5UserGroups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,statuses: [So5UserGroupStatus!]  ): So5UserGroupConnection!
  myTotalXpWon: Int!
  "The `next` field cannot be nested within a list."
  next: So5Fixture
  "The `onboarding_so5_leaderboard` field cannot be nested within a list."
  onboardingSo5Leaderboard: So5Leaderboard
  "The `ordered_so5_scores` field cannot be nested within a list."
  orderedSo5Scores(first: Int!): [OrderedSo5Scores!]!
  "Get ordered So5Score by position"
  orderedSo5ScoresByPosition(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,minScore: Int, position: String!  ): So5ScoreConnection!
  "The `previous` field cannot be nested within a list."
  previous: So5Fixture
  replayedFixture: So5Fixture
  rewardsDeliveryDate: ISO8601DateTime!
  salt: String
  shortDisplayName: String!
  slug: String!
  "The `so5_leaderboards` field cannot be nested within a list."
  so5Leaderboards(sortType: CustomSortingOption): [So5Leaderboard!]!
  "The `so5_leaderboards_paginated` field cannot be nested within a list."
  so5LeaderboardsPaginated(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: CustomSortingOption  ): So5LeaderboardConnection!
  "The `so5_leagues` field cannot be nested within a list."
  so5Leagues: [So5League!]!
  "The `so5_lineups_from_restriction_group` field cannot be nested within a list."
  so5LineupsFromRestrictionGroup(restrictionGroup: RestrictionGroup!): Boolean!
  specialWeeklyBanner: SpecialWeeklyBanner
  startDate: ISO8601DateTime!
}
"The connection type for So5Fixture."
type So5FixtureConnection {
  "A list of edges."
  edges: [So5FixtureEdge!]!
  "A list of nodes."
  nodes: [So5Fixture!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type So5FixtureEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: So5Fixture
}
"A So5 Leaderboard"
type So5Leaderboard implements Node & So5LeaderboardRulesInterface {
  algoliaFilters: String
  canCompose: Validity!
  challenges: [Challenge!]! @deprecated(reason: "Not used anymore")
  commonDraftCampaign: CommonDraftCampaign
  commonDraftCampaigns: [CommonDraftCampaign!]
  cutOffDate: ISO8601DateTime!
  defaultAverageScore: AveragePlayerScore
  description: String
  displayName(short: Boolean): String!
  displayedRules: So5Rules
  division: Int!
  enabled: Boolean! @deprecated(reason: "Use teamsCap instead")
  endDate: ISO8601DateTime!
  engineConfiguration: EngineConfiguration!
  gameWeek: Int!
  hasFeaturedStarterPacks: Boolean!
  iconUrl: String
  id: ID!
  mainRarityType: Rarity
  "The `my_eligible_cards` field cannot be nested within a list."
  myEligibleCards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,deckId: String, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Whether to include cards with no game in this fixture (default false)"
    includeNoGame: Boolean,
    "Whether to include cards already used in this fixture (default false)"
    includeUsed: Boolean,
    "Returns the last _n_ elements from the list."
    last: Int,lastFifteenSo5AverageScore: RangeInput, 
    "The card position to filter on or empty for the extra positions"
    position: Position,
    "Full text search query to filter cards"
    query: String,
    "The card rarities to filter on (default to all rarities)"
    rarities: [Rarity!],
    "Cards (slugs) already selected in the current lineup. They will not filtered out."
    selectedCards: [String!]!,so5LineupId: String, sortType: EligibleCardsSort  ): CardConnection!
  myFeaturedStarterPacks: [StarterPack!]!
  mySo5Lineups: [So5Lineup!]!
  mySo5Rankings(so5UserGroupSlug: String): [So5Ranking!]!
  "The `my_so5_user_groups` field cannot be nested within a list."
  mySo5UserGroups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,statuses: [So5UserGroupStatus!]  ): So5UserGroupConnection!
  powerCap: Float
  rarityType: String!
  rewardedLineupsCount: Int!
  rewardsConfig: LeaderboardRewardsConfig!
  rules: So5Rules
  slug: String!
  so5Fixture: So5Fixture!
  so5LeaderboardType: So5LeaderboardType!
  so5League: So5League!
  so5Lineup(id: String): So5Lineup
  so5LineupsCount: Int!
  "The `so5_lineups_paginated` field cannot be nested within a list."
  so5LineupsPaginated(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): So5LineupConnection!
  """
  Get associated rankings, sorted by rank in ascending order. Empty until
  fixture has started. The `so5_rankings` field cannot be nested within a list.
  """
  so5Rankings(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Show only followed users rankings"
    onlyFollowed: Boolean
  ): So5RankingConnection!
  """
  Get associated rankings, sorted by rank in ascending order. Empty until
  fixture has started. The `so5_rankings_paginated` field cannot be nested within a list.
  """
  so5RankingsPaginated(
    "Show only followed users rankings"
    onlyFollowed: Boolean,page: Int, pageSize: Int, so5UserGroupSlug: String  ): So5RankingsPaginated!
  """
  Get associated rankings, sorted by rank in ascending order. Unlike
  so5Rankings, it is nestable, though limited to 5. Empty until fixture has started.
  """
  so5RankingsPreview(size: Int = 3): [So5Ranking!]!
  "Get associated rewards. Empty until fixture is closed. The `so5_rewards` field cannot be nested within a list."
  so5Rewards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): So5RewardConnection!
  so5TournamentType: So5Tournament!
  startDate: ISO8601DateTime!
  svgLogoUrl: String!
  teamsCap: Int
  title: String
  "High level overview of the rewards for the leaderboard"
  totalRewards: RewardsOverview!
  tournamentType: String!
  trainingCenter: Boolean!
  universalSo5UserGroups: [So5UserGroup!]!
}
"The connection type for So5Leaderboard."
type So5LeaderboardConnection {
  "A list of edges."
  edges: [So5LeaderboardEdge!]!
  "A list of nodes."
  nodes: [So5Leaderboard!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type So5LeaderboardEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: So5Leaderboard
}
"A So5 league"
type So5League implements Node {
  category: String!
  displayName: String!
  "The `games` field cannot be nested within a list."
  games: [Game!]!
  id: ID!
  "The `my_so5_games` field cannot be nested within a list."
  mySo5Games: [Game!]!
  name: String!
  restrictionGroup: RestrictionGroup
  rewardPool(quality: String!, rarity: String!): [PlayerWithSupply!]!
  rewardPoolComputedAt: ISO8601DateTime
  rewardedRarities: [Rarity!]!
  shortDisplayName: String!
  slug: String!
  so5Fixture: So5Fixture!
  so5Leaderboards: [So5Leaderboard!]!
}
"A SO5 lineup"
type So5Lineup implements Node & SocialPicturesInterface {
  cancelledAt: ISO8601DateTime
  confirmable: Boolean!
  draft: Boolean!
  id: ID!
  missingCaptain: Boolean!
  name: String
  so5Appearances: [So5Appearance!]!
  so5Fixture: So5Fixture!
  so5Leaderboard: So5Leaderboard
  "Only 1 ranking is returned. An array because a lineup could be played in multiple leaderboards previously."
  so5Rankings: [So5Ranking!]!
  socialPictureUrls: SocialPictureDerivative!
  user: User!
}
"The connection type for So5Lineup."
type So5LineupConnection {
  "A list of edges."
  edges: [So5LineupEdge!]!
  "A list of nodes."
  nodes: [So5Lineup!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}
"An edge in a connection."
type So5LineupEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: So5Lineup
}
"A user notification regarding a So5Lineup"
type So5LineupNotification implements Node & NotificationInterface {
  card: Card
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
  read: Boolean!
  so5Lineup: So5Lineup!
  sport: Sport
  user: CurrentUser!
}
"An Appearance of a So5NoCardLineup"
type So5NoCardAppearance {
  player: Player
  position: Position
  so5Score: So5Score
}
"A So5NoCardLineup"
type So5NoCardLineup implements Node {
  appearances: [So5NoCardAppearance!]!
  id: ID!
  ranking: Int!
  score: Float!
  so5Fixture: So5Fixture!
  so5Leaderboard: So5Leaderboard
  user: User!
}
"A podium in a So5 Leaderboard"
type So5Podium {
  count: Int!
  displayName(short: Boolean): String!
  ranking: Int!
  so5LeaderboardType: So5LeaderboardType!
  svgLogoUrl: String!
}
"A SO5 Ranking"
type So5Ranking implements Node {
  eligibleForReward: Boolean!
  eligibleRewards: [So5RewardConfig!]!
  id: ID!
  ranking: Int
  score: Float!
  so5Fixture: So5Fixture!
  so5Leaderboard: So5Leaderboard!
  so5Lineup: So5Lineup!
  so5Rewards: [So5Reward!]!
  tiebreakerScore: Float!
}
"The connection type for So5Ranking."
type So5RankingConnection {
  "A list of edges."
  edges: [So5RankingEdge!]!
  "A list of nodes."
  nodes: [So5Ranking!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type So5RankingEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: So5Ranking
}
type So5RankingsPaginated {
  currentPage: Int!
  id: String!
  pages: Int!
  so5Rankings: [So5Ranking!]!
  totalCount: Int!
}
"The rarity rule of a So5Leaderboard"
type So5Rarity {
  common: ValueBoundaries!
  customSeries: ValueBoundaries!
  limited: ValueBoundaries!
  rare: ValueBoundaries!
  superRare: ValueBoundaries!
  unique: ValueBoundaries!
}
"A SO5 Reward"
type So5Reward implements Node {
  aasmState: String!
  amount: MonetaryAmount
  coinAmount: Int!
  id: ID!
  rewardCards: [RewardCard!]!
  slug: String!
  so5Fixture: So5Fixture!
  so5Leaderboard: So5Leaderboard!
  so5Ranking: So5Ranking
  so5UserGroupMembership: So5UserGroupMembership
  weiAmount: String!
}
"A So5 Reward card config"
type So5RewardCardConfig {
  cardEdition: CardEdition @deprecated(reason: "replace by custom_card_edition_name")
  customCardEditionName: String
  displayEdition: String
  player: Player
  quality: CardQuality
  quantity: Int!
  rarity: Rarity!
}
"A So5 Reward config"
type So5RewardConfig {
  cards: [So5RewardCardConfig!]
  coinAmount: Int
  "Rewarded amount in ETH when fixed in ETH"
  ethAmount: Float
  experiences: [So5RewardExperience!]
  id: String @deprecated(reason: "useless")
  "Minimum USD amount guaranteed when prizes are in ETH"
  minimumGuaranteedUsdAmount: Float
  rankPct: Float
  ranks: Int
  score: Float
  "Rewarded amount in USD when fixed in USD"
  usdAmount: Float
}
"The connection type for So5Reward."
type So5RewardConnection {
  "A list of edges."
  edges: [So5RewardEdge!]!
  "A list of nodes."
  nodes: [So5Reward!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type So5RewardEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: So5Reward
}
"A So5 Leaderboard experience rewards config"
type So5RewardExperience {
  description: String
  pictureUrl: String
  type: CustomRewardExperience!
}
"The So5 fields"
type So5Root {
  cardCollection(slug: String!): CardCollection! @deprecated(reason: "moved to football")
  eligibleTournamentTypesForSo5UserGroups: [So5Tournament!]!
  eligibleTournamentsForSo5UserGroups: [So5UserGroupTournament!]!
  featuredSo5Fixtures(first: Int): [So5Fixture!]!
  "Returns all the future leaderboards"
  futureLeaderboardsPaginated(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,rarities: [So5LeaderboardRarity!]  ): So5LeaderboardConnection!
  id: ID!
  "Live StarterPacks on the marketplace"
  liveStarterPacks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): StarterPackConnection!
  managerHomeContentUnitsSets: [ContentUnitsSet!]!
  myPodiums: [So5Podium!]! @deprecated(reason: "Use field on user instead")
  myPodiumsDetails(ranking: Int!, rarityType: So5LeaderboardRarity!, tournamentType: So5LeaderboardTournament!): [So5Ranking!]! @deprecated(reason: "Use field on user instead")
  "The `my_so5_user_groups` field cannot be nested within a list."
  mySo5UserGroups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,statuses: [So5UserGroupStatus!]  ): So5UserGroupConnection!
  myUpcomingLineupsPaginated(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,draft: Boolean, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,so5LeaderboardSlug: String, training: Boolean  ): So5LineupConnection!
  onboardingCommonDraftCampaigns: [CommonDraftCampaign!]!
  onboardingCompetitions: [OnboardingCompetition!]!
  "Get an So5Appearance"
  so5Appearance(id: ID!): So5Appearance!
  "Get a So5Fixture"
  so5Fixture(id: ID, slug: String, type: So5State): So5Fixture
  "Get a list of So5Fixture"
  so5Fixtures(aasmStates: [String!], 
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): So5FixtureConnection!
  "Get a So5Leaderboard"
  so5Leaderboard(slug: String!): So5Leaderboard!
  "Get a So5League"
  so5League(slug: String!): So5League!
  "Get a So5Lineup"
  so5Lineup(id: ID!): So5Lineup!
  "Get a So5NoCardLineup"
  so5NoCardLineup(id: ID!): So5NoCardLineup
  "Get a So5Ranking"
  so5Ranking(id: ID!): So5Ranking!
  "Get a So5Reward"
  so5Reward(slug: String!): So5Reward!
  "Get a list of rewards"
  so5Rewards(ids: [String!]!): [So5Reward!]!
  "Get a So5Score"
  so5Score(id: ID!): So5Score!
  "Get a So5UserGroup"
  so5UserGroup(joinSecret: String, slug: String): So5UserGroup!
  "Get a So5UserGroupMembership"
  so5UserGroupMembership(id: String!): So5UserGroupMembership!
  "The `universal_so5_user_groups` field cannot be nested within a list."
  universalSo5UserGroups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,statuses: [So5UserGroupStatus!]  ): So5UserGroupConnection!
  "Returns all the opened leaderboards"
  upcomingLeaderboards(rarities: [So5LeaderboardRarity!]): [So5Leaderboard!]!
  "Returns all the opened leaderboards"
  upcomingLeaderboardsPaginated(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,rarities: [So5LeaderboardRarity!]  ): So5LeaderboardConnection!
  userCardCollection(id: String!): UserCardCollection! @deprecated(reason: "moved to football")
}
"The rule set of a So5Leaderboard"
type So5Rules {
  activeClubs: [Club!]
  age: Age
  allowLegend: Boolean!
  atLeastOfClubs: So5AtLeastOfClubs
  atLeastOfCompetitions: So5AtLeastOfCompetitions
  averageScore: ValueOpenBoundaries @deprecated(reason: "No longer maintained")
  captain: Json
  captainRarities: [String!]
  "Enforces restrictions on the card's editions in this leaderboard when set."
  cardEditionsCount: CardEditionsCount
  cardTeams: [Team!]
  cardsCountOfCurrentUser: MaximumCardsCountOwnedByUser
  competitions: [Competition!]
  currentEditedSeason: [String!]
  draftTeams: [Team!]
  id: String!
  internationalCompetitions: [Competition!]
  leagues: [Competition!]
  maximumPlayersAverageScore: AverageScoreOpenBoundaries
  minimumPlayersAverageScore: AverageScoreOpenBoundaries
  nationalities: [Country!]
  noClassicCommon: Boolean
  notDomesticCompetitions: [Competition!]
  notNationalities: [Country!]
  rarities: [String!]
  rarityLimits: So5Rarity
  sameActiveClub: ValueOpenBoundaries
  sameNationality: Boolean
  seasons: [Season!]
  serialNumber: String
  sumOfAverageScores: Int
}
"A SO5 Score"
type So5Score implements Node {
  allAroundStats: [StatScore!]!
  decisiveScore: StatScore
  detailedScore: [StatScore!]!
  game: Game!
  id: ID!
  negativeDecisiveStats: [StatScore!]!
  player: Player!
  playerGameStats: PlayerGameStats!
  position: String!
  positionTyped: Position!
  positiveDecisiveStats: [StatScore!]!
  score: Float
  scoringVersion: Int!
}
"The connection type for So5Score."
type So5ScoreConnection {
  "A list of edges."
  edges: [So5ScoreEdge!]!
  "A list of nodes."
  nodes: [So5Score!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type So5ScoreEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: So5Score
}
type So5Tournament {
  displayName(short: Boolean): String!
  id: ID!
  so5LeaderboardType: So5LeaderboardType!
  svgLogoUrl: String!
}
"A trophy (card reward and/or podium) in a So5 Leaderboard"
type So5Trophies {
  cardRewards(rarity: Rarity): Int!
  podiumRankings(ranking: Int): Int!
  so5TournamentType: So5Tournament!
}
"A summary of a user trophies (card reward and/or podium)"
type So5TrophiesSummary {
  cardRewards(rarity: Rarity): Int!
  podiumRankings(ranking: Int): Int!
}
"A SO5 User Group"
type So5UserGroup implements Node {
  administrator: User!
  description: String
  displayName: String!
  endGameWeek: Int
  endSo5Fixture: So5Fixture
  id: ID!
  joinDisabled: Boolean!
  joinSecret: String!
  latestSo5Leaderboard: So5Leaderboard
  liveSo5Leaderboard: So5Leaderboard
  logo: SkinShopItem
  mainRarityType: Rarity
  membershipsCount: Int!
  membershipsPaginated(page: Int, pageSize: Int): So5UserGroupMembershipsPaginated!
  myMembership: So5UserGroupMembership
  "The `past_so5_leaderboards` field cannot be nested within a list."
  pastSo5Leaderboards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): So5LeaderboardConnection!
  rarityType: String!
  rewardsConfig: LeaderboardRewardsConfig!
  slug: String!
  so5LeaderboardType: So5LeaderboardType!
  so5TournamentType: So5Tournament!
  startGameWeek: Int!
  startSo5Fixture: So5Fixture
  status: So5UserGroupStatus!
  svgLogoUrl: String!
  topScoresCount: Int
  "High level overview of the rewards"
  totalRewards: RewardsOverview!
  tournament: So5UserGroupTournament!
  tournamentType: String!
  upcomingSo5Leaderboard: So5Leaderboard
}
"The connection type for So5UserGroup."
type So5UserGroupConnection {
  "A list of edges."
  edges: [So5UserGroupEdge!]!
  "A list of nodes."
  nodes: [So5UserGroup!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}
"An edge in a connection."
type So5UserGroupEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: So5UserGroup
}
"A SO5 User Group membership"
type So5UserGroupMembership implements Node {
  administrator: Boolean!
  createdAt: ISO8601DateTime!
  eligibleRewards: [So5RewardConfig!]!
  id: ID!
  "So5Rankings for the last N game weeks ordered by descending game week, null if not existing"
  lastSo5Rankings(size: Int = 5): [So5Ranking]!
  liveSo5Ranking: So5Ranking
  ranking: Int!
  score: Int!
  "So5Rankings ordered by descending game week The `so5_rankings` field cannot be nested within a list."
  so5Rankings(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): So5RankingConnection!
  so5UserGroup: So5UserGroup!
  user: User!
}
type So5UserGroupMembershipsPaginated {
  currentPage: Int!
  id: String!
  memberships: [So5UserGroupMembership!]!
  pages: Int!
  totalCount: Int!
}
"A user notification regarding a so5 user group"
type So5UserGroupNotification implements Node & NotificationInterface {
  createdAt: ISO8601DateTime!
  id: ID!
  membership: So5UserGroupMembership
  name: String!
  otherMembershipsCount: Int!
  read: Boolean!
  so5UserGroup: So5UserGroup!
  sport: Sport
  user: CurrentUser!
}
"A SO5 User Group tournament"
type So5UserGroupTournament {
  displayName: String! @deprecated(reason: "Use so5Tournament")
  division: Int! @deprecated(reason: "Use so5LeaderboardType")
  id: ID!
  so5LeaderboardType: So5LeaderboardType! @deprecated(reason: "Use so5Tournament")
  so5TournamentType: So5Tournament!
  tournamentType: String! @deprecated(reason: "Use so5LeaderboardType")
}
"A Social picture with all its derivative"
type SocialPictureDerivative {
  post: String
  square: String
  story: String
}
"A football Sorare Daily appearance"
type SorareDailyAppearance implements Node {
  boost: SorareDailyBoost
  captain: Boolean
  card: Card
  id: ID!
  period: Period!
  pictureUrl(derivative: String = "tinified"): String
  player: Player!
  score: Float!
  so5Score: So5Score
  substituteOfAppearance: SorareDailyAppearance
}
"A football Sorare Daily boost"
type SorareDailyBoost implements Node {
  id: ID!
  pictureUrl(derivative: String = null): String
  player: Player!
}
"A Sorare: Football Daily clan"
type SorareDailyClan implements Node {
  displayName: String!
  endDate: ISO8601DateTime!
  id: ID!
  joinSecret: String!
  managers: [SorareDailyManager!]! @deprecated(reason: "Use memberships")
  "The `memberships` field cannot be nested within a list."
  memberships: [SorareDailyClanMembership!]!
  milestones: [SorareDailyClanMilestone!]!
  score: Float!
  startDate: ISO8601DateTime!
}
"The connection type for SorareDailyClan."
type SorareDailyClanConnection {
  "A list of edges."
  edges: [SorareDailyClanEdge!]!
  "A list of nodes."
  nodes: [SorareDailyClan!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type SorareDailyClanEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SorareDailyClan
}
"A Sorare: Football Daily clan membership"
type SorareDailyClanMembership implements Node {
  id: ID!
  manager: SorareDailyManager!
  ranking: Int
  score: Float!
}
"A Sorare: Football Daily clan milestone"
type SorareDailyClanMilestone {
  coinsReward: Int!
  goal: Float!
}
"A Sorare: Football Daily division leaderboard"
type SorareDailyDivisionLeaderboard implements Node {
  division: Int!
  divisionRankings: [SorareDailyDivisionRanking!]!
  endDate: ISO8601DateTime!
  id: ID!
  startDate: ISO8601DateTime!
}
"A Sorare: Football Daily division ranking"
type SorareDailyDivisionRanking implements Node {
  id: ID!
  manager: SorareDailyManager!
  ranking: Int
  score: Float!
}
"A Sorare: Football Daily draftable card"
type SorareDailyDraftableCard {
  card: Card
  id: ID!
  pictureUrl(derivative: String = "tinified"): String
  player: Player!
  position: Position!
}
"A Sorare: Football Daily draftable player"
type SorareDailyDraftablePlayer {
  availableBoosts: [SorareDailyBoost!]!
  id: ID!
  pictureUrl(derivative: String = "full"): String
  player: Player!
  position: Position!
}
"A Sorare: Football Daily game"
type SorareDailyGame implements Node {
  coinsReward: Int! @deprecated(reason: "No game rewards anymore")
  "The `draftable_players` field cannot be nested within a list."
  draftablePlayers: [DraftableObject!]!
  entryFee: Int!
  "The `feed_items` field cannot be nested within a list."
  feedItems(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): FeedItemConnection!
  game: Game!
  id: ID!
  lineupsCount: Int!
  myClan: SorareDailyClan
  myClanLineups: [SorareDailyLineup!]
  myLineup: SorareDailyLineup
  mySquad: SorareDailySquad @deprecated(reason: "Replaced by clans")
  "The `squads` field cannot be nested within a list."
  squads(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SorareDailySquadConnection! @deprecated(reason: "Replaced by clans")
  "The `substitutable_players` field cannot be nested within a list."
  substitutablePlayers(appearanceId: ID!): [SorareDailySubstitutablePlayer!]!
}
"A football Sorare Daily lineup"
type SorareDailyLineup implements Node {
  appearances: [SorareDailyAppearance!]!
  canSubstitute: Boolean!
  game: SorareDailyGame!
  id: ID!
  manager: SorareDailyManager!
  ranking: Int
  reactions: [SorareDailyReaction!]!
  reward: SorareDailyReward @deprecated(reason: "No game rewards anymore")
  rewards: [SorareDailyReward!] @deprecated(reason: "No game rewards anymore")
  room: SorareDailyRoom
  score: Float!
}
"An edge in a connection."
type SorareDailyLineupEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SorareDailyLineup
}
"The connection type for SorareDailyLineup."
type SorareDailyLineupRankingSetConnection {
  "A list of edges."
  edges: [SorareDailyLineupEdge!]!
  "A list of nodes."
  nodes: [SorareDailyLineup!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}
"A Sorare Daily manager"
type SorareDailyManager implements Node & PublicManagerInterface {
  division: Int!
  id: ID!
  nickname: String!
  pictureUrl(derivative: String = "low_res"): String
}
"A football Sorare Daily pack"
type SorareDailyPack {
  nextAvailableAt: ISO8601DateTime
  price: Int!
  size: Int!
  slug: String!
}
"A football Sorare Daily reaction"
type SorareDailyReaction implements Node {
  emoji: String!
  id: ID!
  manager: SorareDailyManager!
}
"A football Sorare Daily reward"
type SorareDailyReward implements Node {
  aasmState: String!
  category: RewardCategory!
  coinAmount: Int!
  id: ID!
}
"A Sorare: Football Daily game room"
type SorareDailyRoom {
  id: ID!
  lineups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SorareDailyLineupRankingSetConnection!
}
"The Football Sorare Daily fields"
type SorareDailyRoot {
  "The `available_clans` field cannot be nested within a list."
  availableClans(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SorareDailyClanConnection!
  currentManager: CurrentManager
  emojiAllowlist: [String!]!
  games(gameDay: Int): [SorareDailyGame!]!
  id: ID!
  liveGames: [SorareDailyGame!]!
  pastGames: [SorareDailyGame!]!
  upcomingGames: [SorareDailyGame!]!
}
"A Sorare: Football Daily squad"
type SorareDailySquad implements Node {
  id: ID!
  joinSecret: String!
  lineups: [SorareDailyLineup!]!
  managers: [SorareDailyManager!]!
  milestones: [SorareDailySquadMilestone!]!
  score: Float!
}
"The connection type for SorareDailySquad."
type SorareDailySquadConnection {
  "A list of edges."
  edges: [SorareDailySquadEdge!]!
  "A list of nodes."
  nodes: [SorareDailySquad!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type SorareDailySquadEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SorareDailySquad
}
"A Sorare: Football Daily squad milestone"
type SorareDailySquadMilestone {
  coinsReward: Int!
  goal: Float!
}
"A Sorare: Football Daily substitutable player"
type SorareDailySubstitutablePlayer {
  draftablePlayer: DraftableObject!
  id: ID!
  price: Int!
  score: Float!
}
"An encrypted private key"
type SorarePrivateKey {
  encryptedPrivateKey: String!
  iv: String!
  salt: String!
}
"A special weekly banner"
type SpecialWeeklyBanner implements Node {
  background: String
  cardUrl: String
  href: String
  hrefLabel: String
  id: ID!
  logoUrl: String
  pictureUrl(derivative: String = null): String
  prizeLabel: String
  sectionName: String
  slug: String!
  subtitle: String
  title: String!
}
"A Squad feed item type"
type SquadFeedItem implements FeedItemInterface & Node {
  appearance: SorareDailyAppearance
  id: ID!
  itemDate: ISO8601DateTime!
  itemType: SquadFeedItemType!
  lineup: SorareDailyLineup!
}
"A StarkEx limit order authorization request"
type StarkexLimitOrderAuthorizationRequest {
  amountBuy: String!
  amountSell: String!
  expirationTimestamp: Int!
  feeInfo: Fee
  nonce: Int!
  tokenBuy: String!
  tokenSell: String!
  vaultIdBuy: Int!
  vaultIdSell: Int!
}
"A StarkEx transfer authorization request"
type StarkexTransferAuthorizationRequest {
  amount: String!
  condition: String
  expirationTimestamp: Int!
  feeInfoUser: Fee
  nonce: Int!
  receiverPublicKey: String!
  receiverVaultId: Int!
  senderVaultId: Int!
  token: String!
}
"A Starkware Account"
type StarkwareAccount implements Node {
  availableBalance: String!
  availableBalanceForWithdrawal: String!
  id: ID!
  starkKey: String!
  totalBalance: String!
  user: User
}
"Withdrawal of a token to Ethereum"
type StarkwareWithdrawal implements Node {
  aasmState: String!
  card: Card
  destination: String
  ethereumTransaction: EthereumTransaction
  id: ID!
}
"A starter pack of cards"
type StarterPack implements Node {
  aasmState: StarterPackState!
  bestRankingPercentage: Float
  cards: [Card!]!
  competitionName: String
  endDate: ISO8601DateTime!
  id: ID!
  price: MonetaryAmount!
  priceInFiat: Fiat!
  primaryOfferId: String!
  slug: String! @deprecated(reason: "Equivalent to using id")
}
"The connection type for StarterPack."
type StarterPackConnection {
  "A list of edges."
  edges: [StarterPackEdge!]!
  "A list of nodes."
  nodes: [StarterPack!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type StarterPackEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: StarterPack
}
"Autogenerated return type of startOnboarding."
type startOnboardingPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Stats of a player for a competition"
type Stats {
  appearances: Int!
  assists: Int!
  goals: Int!
  id: String!
  minutesPlayed: Int!
  player: Player @deprecated(reason: "Use the player in the upper context instead")
  redCards: Int!
  season: Season
  substituteIn: Int!
  substituteOut: Int!
  yellowCards: Int!
}
"Score contribution of a given stat"
type StatScore {
  category: StatCategory!
  points: Float!
  stat: String!
  statValue: Float!
  totalScore: Float!
}
"Autogenerated return type of stopAutoBid."
type stopAutoBidPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  "The sport-agnostic bid"
  tokenBid: TokenBid
}
"A Stripe credit card authorization request"
type StripeCreditCardAuthorizationRequest {
  amount: Int!
  clientSecret: String!
  id: String!
  paymentMethod: String
}
type Subscription {
  aCardWasUpdated(ages: [Int!], cardEditions: [String!], events: [CardWasUpdatedEvent!], owned: Boolean, playerSlugs: [String!], positions: [Position!], rarities: [Rarity!], seasonStartYears: [Int!], serialNumbers: [Int!], shirtNumbers: [Int!], slugs: [String!]): CardSubscription
  aGameWasUpdated(id: ID!): Game
  bundledAuctionWasUpdated: BundledAuction @deprecated(reason: "Prefer using tokenAuctionWasUpdated instead")
  currentUserWasUpdated: CurrentUser
  "Triggered on device update"
  deviceWasUpdated: UserDeviceEvent
  gameWasUpdated: Game
  offerWasUpdated: Offer @deprecated(reason: "Use tokenOfferWasUpdated instead")
  "Triggered on primary offer opened/accepted/cancelled/ended"
  primaryOfferWasUpdated(sports: [Sport!]): TokenPrimaryOffer
  "Triggered on new bid or card sold on the public market"
  publicMarketWasUpdated: Card @deprecated(reason: "Prefer using tokenAuctionWasUpdated or tokenOfferWasUpdated instead")
  "Triggered on new bid or ended auction"
  tokenAuctionWasUpdated(sports: [Sport!]): TokenAuction
  "Triggered on offer accepted/cancelled/ended"
  tokenOfferWasUpdated(sports: [Sport!]): TokenOffer
}
"Subscription statistics for a subscribable, like a Player or a Card"
type SubscriptionStats {
  subscribersCount: Int!
}
"A player suspension"
type Suspension implements Node {
  active: Boolean!
  competition: Competition!
  endDate: ISO8601DateTime
  id: ID!
  kind: String
  matches: Int
  reason: String
  startDate: ISO8601DateTime!
}
"Player related to a common_draft"
type SwappablePlayer {
  avatarUrl: String!
  cardSlug: String!
  id: ID!
  pictureUrl: String!
  player: Player!
  position: String! @deprecated(reason: "Use positionTyped instead")
  positionTyped: Position!
  value: Int!
  xp: Int!
}
"A representation of team formation for a specific game"
type TeamFormation implements Node {
  bench: [Player!]!
  id: ID!
  startingLineup: [[Player!]!]!
}
"Represents a list of players available for a minting quota organized by tiers"
type TieredPlayerPool {
  tier0: [String!]!
  tier1: [String!]!
  tier2: [String!]!
  tier3: [String!]!
  tier4: [String!]!
  tier5: [String!]!
}
"A title body notification rendered for mobile"
type TitleBodyNotificationMobileRendering {
  body: String!
  deepLinkUrl: String!
  iconUrl: String
  title: String!
}
"A title body notification rendering instruction"
type TitleBodyNotificationRendering {
  mobile: TitleBodyNotificationMobileRendering
}
type Token implements Node {
  assetId: String!
  collection: Collection!
  collectionName: String @deprecated(reason: "use collection instead")
  contractAddress: String!
  ethereumId: String!
  ethereumOwner: TokenOwner
  id: ID!
  ipfsPictureUrl: String
  ipfsUrl: String
  latestEnglishAuction: TokenAuction
  latestPrimaryOffer: TokenPrimaryOffer
  liveSingleBuyOffers: [TokenOffer!]!
  liveSingleSaleOffer: TokenOffer
  metadata: TokenMetadata!
  myMintedSingleSaleOffer: TokenOffer
  name: String!
  owner: TokenOwner
  ownershipHistory: [TokenOwner!]!
  pendingWithdrawal: TokenWithdrawal
  pictureUrl(derivative: String): String
  priceRange: Range
  privateMinPrice: String
  privateMinPrices: MonetaryAmount
  publicMinPrice: String
  publicMinPrices: MonetaryAmount
  secondaryMarketFeeEnabled: Boolean!
  """
  Returns all live or minted offers where this token is included in the sender
  side. Returns only if authenticated and sender of the offers.
  """
  sentInLiveOffers: [TokenOffer!]
  slug: String!
  sport: Sport!
  tradeableStatus: Tradeable!
  walletStatus: WalletStatus!
}
"An auction in the Token service"
type TokenAuction implements Node & SocialPicturesInterface & TokenOperationTradeInterface {
  autoBid: Boolean!
  bestBid: TokenBid
  "The `bids` field cannot be nested within a list."
  bids(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TokenBidConnection!
  bidsCount: Int!
  blockchainId: String!
  cancelled: Boolean!
  creditCardFee: Float!
  currency: SupportedCurrency!
  "Current price, in auction currency."
  currentPrice: String!
  endDate: ISO8601DateTime!
  hasTrade: Boolean!
  id: ID!
  "Minimum next bid amount, in auction currency."
  minNextBid: String!
  "Best bid if the connected user is the best bidder, null otherwise"
  myBestBid: TokenMyBid
  "Last bid of the connected user if there is a connected user, null otherwise"
  myLastBid: TokenMyBid
  nfts: [Token!]!
  open: Boolean!
  privateCurrentPrice: String!
  privateMinNextBid: String!
  socialPictureUrls: SocialPictureDerivative!
  startDate: ISO8601DateTime!
  "Team of all tokens if they all belong to the same team, null otherwise"
  team: String
}
"The connection type for TokenAuction."
type TokenAuctionConnection {
  "A list of edges."
  edges: [TokenAuctionEdge!]!
  "A list of nodes."
  nodes: [TokenAuction!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}
"An edge in a connection."
type TokenAuctionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TokenAuction
}
"Baseball token metadata"
type TokenBaseballMetadata implements TokenCardMetadataInterface {
  id: ID!
  playerDisplayName: String!
  playerPositions: [String!]!
  playerSlug: String!
  rarity: Rarity!
  seasonStartYear: Int!
  serialNumber: Int!
  singleCivilYear: Boolean!
  supply: Int!
  teamSlug: String!
}
"A bid on an TokenAuction"
type TokenBid implements Node {
  "Bid amount, in auction currency."
  amount: String!
  amountInFiat: Fiat!
  amounts: MonetaryAmount!
  auction: TokenAuction!
  bidder: BlockchainUser
  conversionCredit: ConversionCredit
  createdAt: ISO8601DateTime!
  fiatPayment: Boolean!
  id: ID!
  maximumAmount: String
  maximumAmountInFiat: Fiat
  maximumAmounts: MonetaryAmount!
}
"The connection type for TokenBid."
type TokenBidConnection {
  "A list of edges."
  edges: [TokenBidEdge!]!
  "A list of nodes."
  nodes: [TokenBid!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}
"An edge in a connection."
type TokenBidEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TokenBid
}
"The connection type for Token."
type TokenConnection {
  "A list of edges."
  edges: [TokenEdge!]!
  "A list of nodes."
  nodes: [Token!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Payload required to make a Starkware NFT deposit"
type TokenDeposit {
  assetType: String!
  starkKey: String!
  tokenId: String!
  vaultId: Int!
}
"An edge in a connection."
type TokenEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Token
}
"Football token metadata"
type TokenFootballMetadata implements TokenCardMetadataInterface {
  id: ID!
  playerDisplayName: String!
  playerPosition: String!
  playerSlug: String!
  rarity: Rarity!
  seasonStartYear: Int!
  serialNumber: Int!
  singleCivilYear: Boolean!
  supply: Int!
  teamSlug: String!
}
"A monetary reward in the Token service"
type TokenMonetaryReward implements Node {
  amount: WeiAmount!
  amounts: MonetaryAmount!
  id: ID!
  rewardId: String!
  sport: Sport!
}
"My bid on an TokenAuction"
type TokenMyBid implements Node {
  "Bid amount, in auction currency."
  amount: String!
  amountInFiat: Fiat!
  amounts: MonetaryAmount!
  auction: TokenAuction!
  bidder: BlockchainUser
  conversionCredit: ConversionCredit
  createdAt: ISO8601DateTime!
  fiatPayment: Boolean!
  id: ID!
  maximumAmount: String
  maximumAmountInFiat: Fiat
  maximumAmounts: MonetaryAmount!
}
"An offer in the Token service"
type TokenOffer implements Node & TokenOperationTradeInterface {
  acceptedAt: ISO8601DateTime
  actualReceiver: BlockchainUser
  blockchainId: String
  cancelledAt: ISO8601DateTime
  counteredOffer: TokenOffer
  createdAt: ISO8601DateTime!
  creditCardFee: Float!
  endDate: ISO8601DateTime!
  hasTrade: Boolean!
  id: ID!
  marketFeeAmountFiat: Fiat!
  marketFeeAmountWei: WeiAmount
  marketFeeAmounts: MonetaryAmount
  owners: [TokenOwner!]
  priceFiat: Fiat!
  priceWei: WeiAmount!
  receiver: BlockchainUser
  receiverSide: TokenOfferSide!
  sender: BlockchainUser!
  senderSide: TokenOfferSide!
  settlementCurrencies: [SupportedCurrency!]!
  startDate: ISO8601DateTime!
  status: String!
  type: OfferType!
}
"The connection type for TokenOffer."
type TokenOfferConnection {
  "A list of edges."
  edges: [TokenOfferEdge!]!
  "A list of nodes."
  nodes: [TokenOffer!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}
"An edge in a connection."
type TokenOfferEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TokenOffer
}
"One side of an Offer"
type TokenOfferSide {
  amounts: MonetaryAmount!
  fiat: Fiat!
  id: String!
  nfts: [Token!]!
  wei: String!
}
type TokenOwner implements Node {
  account: Account
  address: String!
  blockchain: Blockchain!
  deal: TokenDeal
  from: ISO8601DateTime!
  id: ID!
  optimistic: Boolean!
  price: MonetaryAmount!
  priceFiat: Fiat!
  priceWei: String!
  referenceId: String @deprecated(reason: "Use transfer_type and deal fields instead")
  settleAt: ISO8601DateTime
  settlementDelayReason: SettlementDelayReason
  token: Token!
  transferType: OwnerTransfer!
  user: User
}
"A recorded market price for a Token"
type TokenPrice implements Node {
  amount: String!
  amountInFiat: Fiat!
  amounts: MonetaryAmount!
  date: ISO8601DateTime!
  deal: TokenDeal!
  id: ID!
}
"A primary offer in the Token service"
type TokenPrimaryOffer implements Node & TokenOperationTradeInterface {
  buyer: User
  cancelledAt: ISO8601DateTime
  endDate: ISO8601DateTime!
  hasTrade: Boolean!
  id: ID!
  nfts: [Token!]!
  price: MonetaryAmount!
  priceFiat: Fiat!
  priceWei: WeiAmount!
  settledAt: ISO8601DateTime
  startDate: ISO8601DateTime!
  status: String!
}
"The Tokens queries"
type TokenRoot {
  allNfts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sport: [Sport!] = null  ): TokenConnection!
  auction(id: String!): TokenAuction!
  auctions(ids: [String!]!): [TokenAuction!]!
  "Get a conversion credit campaign"
  conversionCreditCampaign(code: String!): ConversionCreditCampaign
  nft(assetId: String!): Token!
  nfts(assetIds: [String!]!): [Token!]!
  offer(id: String!): TokenOffer!
  offers(ids: [String!]!): [TokenOffer!]!
  primaryOffer(id: String!): TokenPrimaryOffer!
  primaryOffers(ids: [String!]!): [TokenPrimaryOffer!]!
  tokenPrices(collection: Collection!, playerSlug: String!, rarity: Rarity!): [TokenPrice!]!
  topGainers(days: FeaturedPageDuration!, sport: Sport!): [TopGainers!]
  topSales(days: FeaturedPageDuration!, sport: Sport!): [TokenOwner!]
  topVolume(days: FeaturedPageDuration!, sport: Sport!): [TopVolume!]
}
"A trade"
type TokenTrade implements Node {
  id: ID!
}
"Withdrawal of an NFT to Ethereum"
type TokenWithdrawal implements Node {
  aasmState: String!
  destination: String
  id: ID!
}
"Player with its performance for a given period"
type TopGainers {
  footballPlayer: Player
  performance: Int!
  playerSlug: String!
}
"Player with its number of trades for a given period"
type TopVolume {
  footballPlayer: Player
  numberOfTrades: Int!
  playerSlug: String!
}
"The Transfer Market queries"
type TransferMarket {
  bundledAuction(slug: String!): BundledAuction
  bundledAuctionsWithCards(slugs: [String!]!): [BundledAuction!]!
  cardWeiMinPrice: String!
  englishAuction(slug: String!): BundledAuction!
  englishAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter on single or multi card auctions or get all auctions by omitting this argument"
    bundled: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,playerSlugs: [String!]  ): EnglishAuctionConnection!
  featuredBundledAuctions(size: Int): [BundledAuction!]!
  id: String!
  offer(id: String!): Offer!
  powerHourStartDate: ISO8601DateTime
  "Last 500 SingleSaleOffer, sorted by `endDate` in descending order."
  singleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sport: Sport  ): SingleSaleOfferConnection!
}
"Signable payload for a Starkware transfer request"
type TransferRequest {
  amount: String!
  condition: String
  expirationTimestamp: Int!
  feeInfoUser: Fee
  nonce: Int!
  receiverPublicKey: String!
  receiverVaultId: Int!
  senderVaultId: Int!
  token: String!
}
"Autogenerated return type of UnblockEmail."
type UnblockEmailPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of unblockUserOffers."
type unblockUserOffersPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of updateCardFilters."
type updateCardFiltersPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of updateExternalEthDeposit."
type updateExternalEthDepositPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of updateFiatWallet."
type updateFiatWalletPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of updateHighlightedCard."
type updateHighlightedCardPayload {
  cardCollectionCard: CardCollectionCard
  cardCollectionSlot: CardCollectionSlot
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
}
"Autogenerated return type of updatePartnerOffersAgreement."
type updatePartnerOffersAgreementPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser!
  errors: [UserError!]!
}
"Autogenerated return type of updateSo5UserGroup."
type updateSo5UserGroupPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  so5UserGroup: So5UserGroup
}
"Autogenerated return type of updateSubscription."
type updateSubscriptionPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  subscribable: Subscribable
  subscription: EmailSubscription
}
"Autogenerated return type of updateUserEmail."
type updateUserEmailPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"Autogenerated return type of updateUserProfile."
type updateUserProfilePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  errors: [UserError!]!
  userProfile: UserProfile
}
"Autogenerated return type of updateUserSettings."
type updateUserSettingsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
  userSettings: UserSettings
}
"Autogenerated return type of upsertCommonDraft."
type upsertCommonDraftPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  draftError: So5CommonDraftError
  errors: [UserError!]!
}
"A Mangopay US bank account type"
type UsBankAccount implements BankAccountInterface & Node {
  "Account number (last 4 digits)"
  accountNumber: String!
  country: Country!
  id: ID!
  ownerAddress: MangopayBankAccountOwnerAddress
  ownerName: String
  "American Banking Association routing number"
  routingNumber: String!
}
"A Sorare user"
type User implements Node & PublicUserInfoInterface & UserInterface {
  accounts: [Account!]!
  active: Boolean
  awards(category: AwardCategory): [UserAward!]! @deprecated(reason: "Use football manager tasks instead")
  baseballProfile: UserSportProfile
  "The `bought_single_sale_offers` field cannot be nested within a list."
  boughtSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use boughtSingleSaleTokenOffers instead")
  "The `bought_single_sale_token_offers` field cannot be nested within a list."
  boughtSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  "The `buying_english_auctions` field cannot be nested within a list."
  buyingEnglishAuctions(
    "Returns auctions sorted by `startDate` in descending order when set."
    newlyListed: Boolean
  ): [EnglishAuction!]! @deprecated(reason: "use buyingTokenAuctions instead")
  "The `buying_token_auctions` field cannot be nested within a list."
  buyingTokenAuctions(
    "Returns auctions sorted by `startDate` in descending order when set."
    newlyListed: Boolean,sport: [Sport!]  ): [TokenAuction!]!
  cardCounts: CardCount!
  cardsCount: Int!
  createdAt: ISO8601DateTime!
  "The `custom_decks` field cannot be nested within a list."
  customDecks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Full text search query to filter custom decks"
    query: String
  ): CustomDeckConnection!
  "Set to true if the account has been deleted or suspended"
  disabled: Boolean! @deprecated(reason: "Use suspended instead")
  "The `ended_with_no_buyer_single_sale_offers` field cannot be nested within a list."
  endedWithNoBuyerSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use endedWithNoBuyerSingleSaleTokenOffers instead")
  "The `ended_with_no_buyer_single_sale_token_offers` field cannot be nested within a list."
  endedWithNoBuyerSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  "The `english_auctions` field cannot be nested within a list."
  englishAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): EnglishAuctionConnection! @deprecated(reason: "use tokenAuctions instead")
  ethVaultId: Int
  ethereumAddress: String
  followed: EmailSubscription
  "The `followers` field cannot be nested within a list."
  followers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserWithSubscriptionSlugConnection!
  followersCount: Int!
  "The `following` field cannot be nested within a list."
  following(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserWithSubscriptionSlugConnection!
  followingCount: Int!
  "The `football_card_collections` field cannot be nested within a list."
  footballCardCollections(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,favoriteOnly: Boolean, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Full text search query to filter card collections"
    query: String,
    "Default to playable rarities"
    rarities: [Rarity!],seasonStartYears: [Int!], startedOnly: Boolean, teamSlug: String  ): CardCollectionConnection
  footballProfile(variant: UserSportProfileVariant): UserSportProfile
  highlightedDeck: HighlightedDeck
  "Typical number of hours the manager takes to answer trades"
  hoursToAnswerTrades: Int
  id: ID!
  "The `live_single_sale_offers` field cannot be nested within a list."
  liveSingleSaleOffers(
    "Returns single sale offers sorted by `startDate` in descending order when set."
    newlyListed: Boolean
  ): [SingleSaleOffer!]! @deprecated(reason: "Use the paginated version instead")
  "The `live_single_sale_token_offers` field cannot be nested within a list."
  liveSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  "The `lost_english_auctions` field cannot be nested within a list."
  lostEnglishAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): EnglishAuctionConnection! @deprecated(reason: "use lostTokenAuctions instead")
  "The `lost_token_auctions` field cannot be nested within a list."
  lostTokenAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenAuctionConnection!
  nbaProfile: UserSportProfile
  nickname: String!
  "The `paginated_cards` field cannot be nested within a list."
  paginatedCards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,age: Int, assetIds: [String!], 
    "Returns the elements in the list that come before the specified cursor."
    before: String,customCardEditionName: String, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): CardConnection!
  "The `paginated_live_single_sale_offers` field cannot be nested within a list."
  paginatedLiveSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use liveSingleSaleTokenOffers instead")
  player: Player
  "The `podium_rankings` field cannot be nested within a list."
  podiumRankings(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,ranking: Int, so5LeaderboardType: So5LeaderboardType  ): So5RankingConnection!
  "The `podiums` field cannot be nested within a list."
  podiums: [So5Podium!]!
  profile: UserProfile!
  "The `recommended_managers` field cannot be nested within a list."
  recommendedManagers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserConnection!
  "The `rewarded_rankings` field cannot be nested within a list."
  rewardedRankings(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,so5LeaderboardType: So5LeaderboardType  ): So5RankingConnection!
  "The `single_sale_offers` field cannot be nested within a list."
  singleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use singleSaleTokenOffers instead")
  "The `single_sale_token_offers` field cannot be nested within a list."
  singleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  slug: String!
  "The `sold_single_sale_offers` field cannot be nested within a list."
  soldSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use soldSingleSaleTokenOffers instead")
  "The `sold_single_sale_token_offers` field cannot be nested within a list."
  soldSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  sorareAddress: String
  starkKey: String
  starkKeyRegistered: Boolean! @deprecated(reason: "no longer relevant")
  "Set to true if the user deleted his account or was suspended"
  suspended: Boolean!
  "The `token_auctions` field cannot be nested within a list."
  tokenAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenAuctionConnection!
  "The `trophies` field cannot be nested within a list."
  trophies: [So5Trophies!]!
  "The `trophies_summary` field cannot be nested within a list."
  trophiesSummary: So5TrophiesSummary!
  "The `won_english_auctions` field cannot be nested within a list."
  wonEnglishAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): EnglishAuctionConnection! @deprecated(reason: "use wonTokenAuctions instead")
  "The `won_token_auctions` field cannot be nested within a list."
  wonTokenAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenAuctionConnection!
  avatarUrl: String!
  nbaCollections(slugsFilter: [String!]): [NBACollection!]!
  nbaCards(first: Int! = 100, after: String, positions: [NBAPlayerPosition!], rarities: [CardRarity!]): NBACardConnection!
  baseballScoutingMissions: [BaseballScoutingMission!]! @deprecated(reason: "unsupported")
  baseballCollections(slugsFilter: [String!]): [BaseballCollection!]!
  baseballCards(first: Int! = 100, after: String, positions: [BaseballPlayerPosition!], rarities: [CardRarity!]): BaseballCardConnection!
}
"A user account entry"
type UserAccountEntry implements Node {
  aasmState: UserAccountEntryState!
  account: Account
  amount: String!
  amountInFiat: Fiat!
  amounts: MonetaryAmount!
  date: ISO8601DateTime!
  entryType: UserAccountEntryEntry!
  id: ID!
  operation: UserAccountEntryOperation @deprecated(reason: "Use tokenOperation instead")
  provisional: Boolean!
  tokenOperation: UserAccountEntryTokenOperation
  user: User!
}
"The connection type for UserAccountEntry."
type UserAccountEntryConnection {
  "A list of edges."
  edges: [UserAccountEntryEdge!]!
  "A list of nodes."
  nodes: [UserAccountEntry!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type UserAccountEntryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UserAccountEntry
}
"A user award"
type UserAward implements Node {
  award: Award!
  category: AwardCategory!
  claimableReward: Int
  claimedLevel: Int
  completed: Boolean!
  id: ID!
  level: Int!
  maxLevel: Int!
  nextLevel: Int!
  nextRequirement: String
  nextReward: Int
  progression: String
  rewards: [Int!]!
  slug: String!
  updatedAt: ISO8601DateTime
}
"A user notification regarding an Award event"
type UserAwardNotification implements Node & NotificationInterface {
  amount: Int
  award: UserAward
  createdAt: ISO8601DateTime!
  id: ID!
  level: Int
  name: String!
  read: Boolean!
  sport: Sport
  user: CurrentUser!
}
"The cards of a user for a collection"
type UserCardCollection implements Node {
  bonus: Float!
  cardCollection: CardCollection!
  "The `card_collection_cards` field cannot be nested within a list."
  cardCollectionCards: [CardCollectionCard!]!
  complete: Boolean!
  completedAt: ISO8601DateTime
  fulfilledSlotsCount: Int!
  id: ID!
  liveRanking: Int!
  score: Int!
  "The `slots` field cannot be nested within a list."
  slots: [UserCardCollectionSlot!]!
  user: User!
}
"The connection type for UserCardCollection."
type UserCardCollectionConnection {
  "A list of edges."
  edges: [UserCardCollectionEdge!]!
  "A list of nodes."
  nodes: [UserCardCollection!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type UserCardCollectionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UserCardCollection
}
"A slot in a user collection of cards"
type UserCardCollectionSlot {
  cardCollectionCards: [CardCollectionCard!]!
  cardCollectionCardsCount: Int!
  highlightedCardCollectionCard: CardCollectionCard
  slot: CardCollectionSlot!
  slug: String!
}
"The connection type for User."
type UserConnection {
  "A list of edges."
  edges: [UserEdge!]!
  "A list of nodes."
  nodes: [User!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"A Sorare manager device"
type UserDevice implements Node {
  deviceType: String!
  id: ID!
  lastUsedAt: ISO8601DateTime
  os: String!
  userAgent: String!
}
"A Sorare manager device related event"
type UserDeviceEvent implements Node {
  deviceType: String!
  eventType: DeviceWasUpdatedEvent!
  id: ID!
  lastUsedAt: ISO8601DateTime
  os: String!
  userAgent: String!
}
"An edge in a connection."
type UserEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: User
}
"A user-readable error"
type UserError {
  "The error code"
  code: Int
  "A description of the error"
  message: String!
  "Which input value this error came from"
  path: [String!]
}
"An object representing the past or present ownership of a card by a user"
type UserOwner implements OwnerInterface {
  account: Account
  address: String!
  blockchain: String!
  card: Card!
  from: ISO8601DateTime!
  id: ID!
  optimistic: Boolean!
  ownerable: User!
  "Card price, in wei."
  price: String!
  referenceId: String
  settleAt: ISO8601DateTime
  transferType: String!
}
"A Sorare user profile"
type UserProfile implements Node {
  clubBanner: SkinShopItem
  clubName: String!
  clubShield: SkinShopItem
  discordUsername: String
  enabledWallets: [EnabledWallet!]
  id: ID!
  "Get marketplace preferences"
  marketplacePreferences(
    "Sport(s) whose marketplace preferences are to be returned. All if not provided."
    sports: [Sport!]
  ): [MarketplaceSportPreferences!]!
  pictureUrl(derivative: String = "low_res"): String
  "The date the user created his first non rookie / training lineup"
  proSince: ISO8601DateTime @deprecated(reason: "Pro concept is no longer being used")
  rookie: Boolean! @deprecated(reason: "Rookie concept is no longer being used")
  status: String
  twitterUsername: String
  user: User!
  verified: Boolean!
}
"A Sorare user settings"
type UserSettings {
  currency: Currency
  disableAllEmails: Boolean!
  enabledWallets: [EnabledWallet!] @deprecated(reason: "Use userProfile.enabledWallets")
  fiatCurrency: FiatCurrency
  hideBalance: Boolean!
  hideCommonCards: Boolean!
  id: ID!
  lifecycle: Json!
  locale: String
  "Get notification settings. If no sport parameter is provided the football one will be returned"
  notificationPreferences(
    "Sport whose notification settings are to be returned"
    sport: Sport
  ): [NotificationPreference!]!
  postalAddress: PostalAddress!
  referrerPreferredRewardSport: Sport @deprecated(reason: "No longer used")
  rewardCurrency: Currency!
  "User status with regards to Sorare's TCU"
  tcuStatus: TermsAndConditionsStatus!
}
"A user shop item"
type UserShopItem implements Node {
  id: ID!
  shopItem: ClubShopItem!
}
"An affiliate"
type UserSource implements Node {
  id: ID!
  name: String!
}
"A Sorare user sport specific profile"
type UserSportProfile implements Node {
  id: ID!
  onboarded: Boolean!
  onboardingStatus: UserSportProfileOnboardingStatus!
  sport: Sport!
  variant: UserSportProfileVariant!
}
"A Sorare wallet"
type UserWallet implements Node {
  ethereumAddress: String!
  holdsValue: Boolean!
  id: ID!
  passwordEncryptedPrivateKey: PasswordEncryptedPrivateKey
  privateKeyRecoveryPayload(id: String!): PrivateKeyRecoveryPayload
  privateKeyRecoveryPayloads: [PrivateKeyRecoveryPayload!]!
  recoveryOptions: [PrivateKeyRecoveryOption!]!
  starkKey: String!
  starkKeyWithPrefix: String!
  status: UserWalletStatusEnum!
}
"A Sorare user with the subscription slug of the current user"
type UserWithSubscriptionSlug implements PublicUserInfoInterface & UserSocialInterface {
  accounts: [Account!]!
  active: Boolean
  awards(category: AwardCategory): [UserAward!]! @deprecated(reason: "Use football manager tasks instead")
  baseballProfile: UserSportProfile
  "The `bought_single_sale_offers` field cannot be nested within a list."
  boughtSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use boughtSingleSaleTokenOffers instead")
  "The `bought_single_sale_token_offers` field cannot be nested within a list."
  boughtSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  "The `buying_english_auctions` field cannot be nested within a list."
  buyingEnglishAuctions(
    "Returns auctions sorted by `startDate` in descending order when set."
    newlyListed: Boolean
  ): [EnglishAuction!]! @deprecated(reason: "use buyingTokenAuctions instead")
  "The `buying_token_auctions` field cannot be nested within a list."
  buyingTokenAuctions(
    "Returns auctions sorted by `startDate` in descending order when set."
    newlyListed: Boolean,sport: [Sport!]  ): [TokenAuction!]!
  cardCounts: CardCount!
  cardsCount: Int!
  createdAt: ISO8601DateTime!
  "The `custom_decks` field cannot be nested within a list."
  customDecks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Full text search query to filter custom decks"
    query: String
  ): CustomDeckConnection!
  "Set to true if the account has been deleted or suspended"
  disabled: Boolean! @deprecated(reason: "Use suspended instead")
  "The `ended_with_no_buyer_single_sale_offers` field cannot be nested within a list."
  endedWithNoBuyerSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use endedWithNoBuyerSingleSaleTokenOffers instead")
  "The `ended_with_no_buyer_single_sale_token_offers` field cannot be nested within a list."
  endedWithNoBuyerSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  "The `english_auctions` field cannot be nested within a list."
  englishAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): EnglishAuctionConnection! @deprecated(reason: "use tokenAuctions instead")
  ethVaultId: Int
  ethereumAddress: String
  followed: EmailSubscription
  "The `followers` field cannot be nested within a list."
  followers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserWithSubscriptionSlugConnection!
  followersCount: Int!
  "The `following` field cannot be nested within a list."
  following(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserWithSubscriptionSlugConnection!
  followingCount: Int!
  "The `football_card_collections` field cannot be nested within a list."
  footballCardCollections(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,favoriteOnly: Boolean, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Full text search query to filter card collections"
    query: String,
    "Default to playable rarities"
    rarities: [Rarity!],seasonStartYears: [Int!], startedOnly: Boolean, teamSlug: String  ): CardCollectionConnection
  footballProfile(variant: UserSportProfileVariant): UserSportProfile
  highlightedDeck: HighlightedDeck
  "Typical number of hours the manager takes to answer trades"
  hoursToAnswerTrades: Int
  id: ID!
  "The `live_single_sale_offers` field cannot be nested within a list."
  liveSingleSaleOffers(
    "Returns single sale offers sorted by `startDate` in descending order when set."
    newlyListed: Boolean
  ): [SingleSaleOffer!]! @deprecated(reason: "Use the paginated version instead")
  "The `live_single_sale_token_offers` field cannot be nested within a list."
  liveSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  "The `lost_english_auctions` field cannot be nested within a list."
  lostEnglishAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): EnglishAuctionConnection! @deprecated(reason: "use lostTokenAuctions instead")
  "The `lost_token_auctions` field cannot be nested within a list."
  lostTokenAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenAuctionConnection!
  nbaProfile: UserSportProfile
  nickname: String!
  "The `paginated_cards` field cannot be nested within a list."
  paginatedCards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,age: Int, assetIds: [String!], 
    "Returns the elements in the list that come before the specified cursor."
    before: String,customCardEditionName: String, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): CardConnection!
  "The `paginated_live_single_sale_offers` field cannot be nested within a list."
  paginatedLiveSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use liveSingleSaleTokenOffers instead")
  player: Player
  "The `podium_rankings` field cannot be nested within a list."
  podiumRankings(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,ranking: Int, so5LeaderboardType: So5LeaderboardType  ): So5RankingConnection!
  "The `podiums` field cannot be nested within a list."
  podiums: [So5Podium!]!
  profile: UserProfile!
  "The `recommended_managers` field cannot be nested within a list."
  recommendedManagers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserConnection!
  "The `rewarded_rankings` field cannot be nested within a list."
  rewardedRankings(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,so5LeaderboardType: So5LeaderboardType  ): So5RankingConnection!
  "The `single_sale_offers` field cannot be nested within a list."
  singleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use singleSaleTokenOffers instead")
  "The `single_sale_token_offers` field cannot be nested within a list."
  singleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  slug: String!
  "The `sold_single_sale_offers` field cannot be nested within a list."
  soldSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use soldSingleSaleTokenOffers instead")
  "The `sold_single_sale_token_offers` field cannot be nested within a list."
  soldSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  sorareAddress: String
  starkKey: String
  starkKeyRegistered: Boolean! @deprecated(reason: "no longer relevant")
  subscriptionSlug: String
  "Set to true if the user deleted his account or was suspended"
  suspended: Boolean!
  "The `token_auctions` field cannot be nested within a list."
  tokenAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenAuctionConnection!
  "The `trophies` field cannot be nested within a list."
  trophies: [So5Trophies!]!
  "The `trophies_summary` field cannot be nested within a list."
  trophiesSummary: So5TrophiesSummary!
  "The `won_english_auctions` field cannot be nested within a list."
  wonEnglishAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): EnglishAuctionConnection! @deprecated(reason: "use wonTokenAuctions instead")
  "The `won_token_auctions` field cannot be nested within a list."
  wonTokenAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenAuctionConnection!
}
"The connection type for UserWithSubscriptionSlug."
type UserWithSubscriptionSlugConnection {
  "A list of edges."
  edges: [UserWithSubscriptionSlugEdge!]!
  "A list of nodes."
  nodes: [UserWithSubscriptionSlug!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type UserWithSubscriptionSlugEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UserWithSubscriptionSlug
}
"Autogenerated return type of validateFiatWallet."
type validateFiatWalletPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"A boolean value and its reason"
type Validity {
  missingAnyRarities: [Rarity!]!
  missingCards: Int!
  missingPositions: [Position!]!
  missingRarity(rarity: Rarity!): Int!
  notEnoughEligibleCards: Boolean!
  reason: String
  transferMarketFilters: String
  value: Boolean!
}
type ValueBoundaries {
  max: Int!
  min: Int!
}
type ValueOpenBoundaries {
  max: Int
  min: Int
}
"A representation of the stock count per variant on a shop item"
type VariantStockCount {
  currentStockCount: Int!
  initialStockCount: Int!
  size: ShirtSize!
}
"A Stripe Verification Session"
type VerificationSession {
  clientSecret: String
  id: String!
}
"Autogenerated return type of verifyPhoneNumber."
type verifyPhoneNumberPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currentUser: CurrentUser
  errors: [UserError!]!
}
"A withdrawal"
type Withdrawal implements Node {
  agreedFeeAmount: String!
  amount: String!
  createdAt: ISO8601DateTime!
  id: ID!
  status: WithdrawalStatus!
  to: String!
  transactionHash: String
}
"A withdrawal with conversion rates"
type WithdrawalWithRates implements Node {
  agreedFeeAmount: String!
  amount: String!
  amountInFiat: Fiat!
  createdAt: ISO8601DateTime!
  id: ID!
  status: WithdrawalStatus!
  to: String!
  transactionHash: String
}
"A xp restore shop item to level up the xp of a card"
type XPRestoreShopItem implements Node & ShopItemInterface & XPBoosterShopItemInterface {
  cardCollectionRequirements: [CardCollectionRequirement!]!
  createdAt: ISO8601DateTime!
  description: String
  disabled: Boolean!
  endLevel: Int!
  expirationDate: ISO8601DateTime
  id: ID!
  limitPerUser: Int!
  myAvailableTotalPurchasesCount: Int!
  myAvailableUserShopItems: [UserShopItem!]
  myBalance: Int!
  myLimitResetAt: ISO8601DateTime
  myPurchasesCount: Int!
  name: String!
  pictureUrl: String!
  position: ShopItemType!
  price: Int!
  rarity: Rarity!
  salePrice: Int
  shopItemsRequired: [ShopItem!]!
  startLevel: Int!
  unlocked: Boolean!
}
"Bank account interface"
interface BankAccountInterface {
  country: Country!
  id: ID!
  ownerAddress: MangopayBankAccountOwnerAddress
  ownerName: String
}
"Blockchain info"
interface BlockchainUserInterface {
  accounts: [Account!]!
  cardsCount: Int!
  ethVaultId: Int
  ethereumAddress: String
  sorareAddress: String
  starkKey: String
  starkKeyRegistered: Boolean! @deprecated(reason: "no longer relevant")
}
interface CardBundleOffer {
  id: String!
  priceUSDCents: Int!
  cards: [CardInterface!]!
  expiresAt: Time!
  leaderboard: LeaderboardInterface
  rewardPlayerName: String!
  rank: Int!
}
"Card Game Interface"
interface CardGameInterface {
  cardCollectionCards: [CardCollectionCard!]!
  coverageStatus: CardCoverageStatus!
  "Current card fitness bonus"
  fitnessBonus: Float
  gameForLeague(so5LeaderboardSlug: String = null, so5LeagueSlug: String = null): Game
  "Current card level"
  grade: Int!
  gradeAfterTransfer: Int!
  "So5Lineup that this card is being used in for the live So5Fixture"
  liveSo5Lineup: So5Lineup
  openedSo5Lineup: So5Lineup @deprecated(reason: "Use Card.openedSo5Lineups instead")
  "So5Lineups that this card is being used in for the opened So5Fixtures"
  openedSo5Lineups: [So5Lineup!]!
  "Total card bonus (XP + Season bonus)"
  power(so5LeaderboardSlug: String = null): String!
  powerBreakdown(so5LeaderboardSlug: String = null): PowerBreakdown!
  powerMalusAfterTransfer: String!
  u23Eligible: Boolean!
  xp: Int!
  xpAfterTransfer: Int!
  "XP start range of current card level"
  xpNeededForCurrentGrade: Int!
  "XP end range of current card level"
  xpNeededForNextGrade: Int
}
interface CardInLineupGameScoreInterface {
  gameStats: PlayerGameStatsInterface!
}
interface CardInLineupInterface {
  lineup: LineupInterface!
  card: CardInterface!
  playerInFixture: PlayerInFixtureInterface!
  score: Float!
  totalBonus: Float!
  gameScores: [CardInLineupGameScoreInterface!]
}
interface CardInterface {
  id: UUID!
  slug: String!
  assetId: ID!
  owner: User
  rarity: CardRarity!
  season: String!
  serialNumber: Int!
  fullImageUrl: String!
  avatarImageUrl: String!
  backImageUrl: String!
  player: PlayerInterface!
  team: SportsTeamInterface
  cardLevel: Int!
  xpThresholdForCurrentCardLevel: Int!
  xpThresholdForNextCardLevel: Int
  xp: Int!
  seasonBonus: Float!
  rarityBonus: Float!
  xpBonus: Float!
  totalBonus: Float!
  bonusLossAfterTransfer: Float!
}
"Card Market Resolvers"
interface CardMarketInterface {
  canBuy: Boolean! @deprecated(reason: "Use `Token.tradeableStatus` instead")
  latestEnglishAuction: EnglishAuction @deprecated(reason: "Use `Token.latestEnglishAuction` instead")
  liveSingleBuyOffers: [Offer!]! @deprecated(reason: "Use `Token.liveSingleBuyOffers` instead")
  liveSingleSaleOffer: SingleSaleOffer @deprecated(reason: "Use `Token.liveSingleSaleOffer` instead")
  myMintedSingleSaleOffer: SingleSaleOffer @deprecated(reason: "Use `Token.myMintedSingleSaleOffer` instead")
  onSale: Boolean! @deprecated(reason: "Use `token` fields instead")
  openEnglishAuction: EnglishAuction @deprecated(reason: "Use `token` fields instead")
  privateMinPrice: String @deprecated(reason: "Use `Token.privateMinPrice` instead")
  publicMinPrice: String @deprecated(reason: "Use `Token.publicMinPrice` instead")
}
interface CardTradeInterface {
  id: UUID!
  expiresAfter: Time
  userGiveCard: CardInterface!
  userGiveCardUsedInLineup: LineupInterface
  userReceiveCardChoices: [CommonCardSampleInterface!]!
  userReceiveCard: CardInterface
  isComplete: Boolean!
}
interface CollectionInterface {
  slug: String!
  isComplete: Boolean!
  slots: [CollectionSlotInterface!]!
  slotsCount: Int!
  filledSlots: Int!
  team: SportsTeamInterface
  season: String
}
interface CollectionSlotInterface {
  requiredPlayer: PlayerInterface!
  ownedCards: [CardInterface!]
  displayCard: CardInterface
}
interface CommonCardSampleInterface {
  id: UUID!
  player: PlayerInterface!
  commonCardImageUrl: String!
}
"Competition Onboarding Design"
interface CompetitionGraphicalIdentityInterface {
  backgroundColor: String
  backgroundPictureUrl: String
  featuredCardPictureUrls: [String!]
  featuredPlayer: PickablePlayer
  logoUrl: String
}
interface DeckInterface {
  "The `cards` field cannot be nested within a list."
  cards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CardConnection!
  cardsCount: Int!
  deckCards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DeckCardConnection!
  deckCardsCount: Int!
  firstCard: Card
  id: ID!
  slug: String!
  user: User
}
interface EnglishAuctionInterface {
  bestBid: BidWithRates
  "The `bids` field cannot be nested within a list."
  bids(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BidConnection!
  bidsCount: Int!
  blockchainId: String!
  cancelled: Boolean!
  cards: [Card!]!
  contentProvider: EnglishAuctionContentProvider
  creditCardFee: Float!
  currency: SupportedCurrency!
  "Current price, in auction currency."
  currentPrice: String!
  endDate: ISO8601DateTime!
  id: ID!
  "Minimum next bid amount, in auction currency."
  minNextBid: String!
  "Best bid if the connected user is the best bidder, null otherwise"
  myBestBid: MyBidWithRates
  open: Boolean!
  slug: String!
  startDate: ISO8601DateTime!
  tokenAuction: TokenAuction!
}
interface FeedItemInterface {
  id: ID!
  itemDate: ISO8601DateTime!
}
interface FixtureInterface {
  id: UUID!
  slug: String!
  fixtureState: FixtureState!
  gameWeek: Int!
  startDate: Time!
  endDate: Time!
  games: [GameInterface!]!
  leaderboards(includeTraining: Boolean): [LeaderboardInterface!]!
  myEligibleGames: [GameInterface!]!
  myLiveLineupGames: [GameWithCardInLineupInterface!]!
  myLineups: [LineupInterface!]!
  nextFixture: FixtureInterface
  previousFixture: FixtureInterface
  rewardPool(rarity: BaseballCardRarity, cardRarity: CardRarity, tier: Int!): [PlayerInterface!]!
}
"Public Football Head to Head manager information"
interface FootballHeadToHeadPublicManagerInterface {
  eloGroup: String!
  eloScore: Int!
  nickname: String!
  "The `past_challenges` field cannot be nested within a list."
  pastChallenges(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,type: ChallengeType  ): FootballHeadToHeadChallengeConnection!
  "The `past_games` field cannot be nested within a list."
  pastGames(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): FootballHeadToHeadGameConnection!
  pictureUrl(derivative: String = "low_res"): String
  records: FootballHeadToHeadManagerRecords!
}
interface GameInterface {
  id: UUID!
  status: GameStatus!
  startDate: Time!
  homeTeam: SportsTeamInterface!
  awayTeam: SportsTeamInterface!
  homeScore: Int!
  awayScore: Int!
  gameWeek: Int!
}
interface GameWithCardInLineupInterface {
  game: GameInterface!
  homeCardsInLineups: [CardInLineupInterface!]!
  awayCardsInLineups: [CardInLineupInterface!]!
}
interface LeaderboardInterface {
  id: UUID!
  slug: String!
  displayName: String!
  descriptions: [String]!
  displayNameWithoutRarity: String!
  lineupsCount: Int!
  prizePool: LeaderboardPrizePool!
  isUserEligible: Boolean!
  isTraining: Boolean!
  iconImageUrl: String!
  monochromeIconImageUrl: String!
  fixture: FixtureInterface!
  requirements: LeaderboardRequirementsInterface!
  leaderboardRarity: LeaderboardRarity!
  scoringStrategy: String!
}
interface LeaderboardRequirementsInterface {
  allowedRarities: [CardRarity!]!
  minRarity: LeaderboardRulesMinimumRarityRequirement
  minRookieCount: Int!
  playerAgeRequirements: PlayerAgeRequirements
  marketplaceQueryParameters: String
}
interface LeagueInterface {
  id: String!
  slug: String!
  name: String!
  members: [User!]!
}
interface LeagueLeaderboardInterface {
  league: LeagueInterface!
  leaderboard: LeaderboardInterface!
  lineupCount: Int!
  lineups: [LeagueLineupInterface!]!
  participants: [User!]!
}
interface LeagueLineupInterface {
  rank: Int!
  lineup: LineupInterface!
  leaderboard: LeagueLeaderboardInterface!
}
interface LineupInterface {
  id: UUID!
  leaderboard: LeaderboardInterface!
  cards: [CardInLineupInterface!]!
  games: [GameWithCardInLineupInterface!]!
  score: Float!
  rank: Int!
  user: User!
  xpScore: Float! @deprecated(reason: "No longer supported")
  projectedReward: ProjectedReward
  reward: RewardInterface
}
"An object with an ID."
interface Node {
  "ID of the object."
  id: ID!
}
"User Notification"
interface NotificationInterface {
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
  read: Boolean!
  sport: Sport
  user: CurrentUser!
}
"An Offer"
interface OfferInterface {
  aasmState: String!
  acceptedAt: ISO8601DateTime
  blockchainId: String
  cancelledAt: ISO8601DateTime
  createdAt: ISO8601DateTime!
  creditCardFee: Float!
  endDate: ISO8601DateTime!
  id: ID!
  marketFeeWeiAmount: WeiAmount!
  sender: Ownerable!
  startDate: ISO8601DateTime!
  tokenOffer: TokenOffer!
  trade: TokenTrade
}
"Card owner (contract or user)"
interface OwnerInterface {
  account: Account
  address: String!
  blockchain: String!
  card: Card!
  from: ISO8601DateTime!
  id: ID!
  optimistic: Boolean!
  "Card price, in wei."
  price: String!
  referenceId: String
  settleAt: ISO8601DateTime
  transferType: String!
}
interface PlayerGameStatsInterface {
  playedInGame: Boolean!
  game: GameInterface!
  team: SportsTeamInterface!
  againstTeam: SportsTeamInterface!
}
interface PlayerInFixtureInterface {
  fixture: FixtureInterface!
  player: PlayerInterface!
  status: PlayerInFixtureStatusInterface!
}
interface PlayerInFixtureStatusInterface {
  gameStats: [PlayerGameStatsInterface!]!
  upcomingGames: [GameInterface!]!
  inGame: Boolean!
  isScoreFinal: Boolean!
  statusIconType: PlayerInFixtureStatusIconType!
  hasTBDGames: Boolean!
}
interface PlayerInterface {
  id: UUID!
  slug: String!
  birthDate: Time!
  age: Int!
  displayName: String!
  firstName: String!
  lastName: String!
  avatarImageUrl: String!
  team: SportsTeamInterface
  birthPlaceCountry: String!
  shirtNumber: Int!
  isActive: Boolean!
  playerInjury: PlayerInjury
  pictureUrl: String!
}
"Public Football Sorare Daily manager information"
interface PublicManagerInterface {
  division: Int!
  nickname: String!
  pictureUrl(derivative: String = "low_res"): String
}
"Public user information"
interface PublicUserInfoInterface {
  accounts: [Account!]!
  active: Boolean
  awards(category: AwardCategory): [UserAward!]! @deprecated(reason: "Use football manager tasks instead")
  baseballProfile: UserSportProfile
  "The `bought_single_sale_offers` field cannot be nested within a list."
  boughtSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use boughtSingleSaleTokenOffers instead")
  "The `bought_single_sale_token_offers` field cannot be nested within a list."
  boughtSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  "The `buying_english_auctions` field cannot be nested within a list."
  buyingEnglishAuctions(
    "Returns auctions sorted by `startDate` in descending order when set."
    newlyListed: Boolean
  ): [EnglishAuction!]! @deprecated(reason: "use buyingTokenAuctions instead")
  "The `buying_token_auctions` field cannot be nested within a list."
  buyingTokenAuctions(
    "Returns auctions sorted by `startDate` in descending order when set."
    newlyListed: Boolean,sport: [Sport!]  ): [TokenAuction!]!
  cardCounts: CardCount!
  cardsCount: Int!
  createdAt: ISO8601DateTime!
  "The `custom_decks` field cannot be nested within a list."
  customDecks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Full text search query to filter custom decks"
    query: String
  ): CustomDeckConnection!
  "Set to true if the account has been deleted or suspended"
  disabled: Boolean! @deprecated(reason: "Use suspended instead")
  "The `ended_with_no_buyer_single_sale_offers` field cannot be nested within a list."
  endedWithNoBuyerSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use endedWithNoBuyerSingleSaleTokenOffers instead")
  "The `ended_with_no_buyer_single_sale_token_offers` field cannot be nested within a list."
  endedWithNoBuyerSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  "The `english_auctions` field cannot be nested within a list."
  englishAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): EnglishAuctionConnection! @deprecated(reason: "use tokenAuctions instead")
  ethVaultId: Int
  ethereumAddress: String
  followed: EmailSubscription
  "The `followers` field cannot be nested within a list."
  followers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserWithSubscriptionSlugConnection!
  followersCount: Int!
  "The `following` field cannot be nested within a list."
  following(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserWithSubscriptionSlugConnection!
  followingCount: Int!
  "The `football_card_collections` field cannot be nested within a list."
  footballCardCollections(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,favoriteOnly: Boolean, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Full text search query to filter card collections"
    query: String,
    "Default to playable rarities"
    rarities: [Rarity!],seasonStartYears: [Int!], startedOnly: Boolean, teamSlug: String  ): CardCollectionConnection
  footballProfile(variant: UserSportProfileVariant): UserSportProfile
  highlightedDeck: HighlightedDeck
  "Typical number of hours the manager takes to answer trades"
  hoursToAnswerTrades: Int
  id: ID!
  "The `live_single_sale_offers` field cannot be nested within a list."
  liveSingleSaleOffers(
    "Returns single sale offers sorted by `startDate` in descending order when set."
    newlyListed: Boolean
  ): [SingleSaleOffer!]! @deprecated(reason: "Use the paginated version instead")
  "The `live_single_sale_token_offers` field cannot be nested within a list."
  liveSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  "The `lost_english_auctions` field cannot be nested within a list."
  lostEnglishAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): EnglishAuctionConnection! @deprecated(reason: "use lostTokenAuctions instead")
  "The `lost_token_auctions` field cannot be nested within a list."
  lostTokenAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenAuctionConnection!
  nbaProfile: UserSportProfile
  nickname: String!
  "The `paginated_cards` field cannot be nested within a list."
  paginatedCards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,age: Int, assetIds: [String!], 
    "Returns the elements in the list that come before the specified cursor."
    before: String,customCardEditionName: String, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): CardConnection!
  "The `paginated_live_single_sale_offers` field cannot be nested within a list."
  paginatedLiveSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use liveSingleSaleTokenOffers instead")
  player: Player
  "The `podium_rankings` field cannot be nested within a list."
  podiumRankings(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,ranking: Int, so5LeaderboardType: So5LeaderboardType  ): So5RankingConnection!
  "The `podiums` field cannot be nested within a list."
  podiums: [So5Podium!]!
  profile: UserProfile!
  "The `recommended_managers` field cannot be nested within a list."
  recommendedManagers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserConnection!
  "The `rewarded_rankings` field cannot be nested within a list."
  rewardedRankings(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,so5LeaderboardType: So5LeaderboardType  ): So5RankingConnection!
  "The `single_sale_offers` field cannot be nested within a list."
  singleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use singleSaleTokenOffers instead")
  "The `single_sale_token_offers` field cannot be nested within a list."
  singleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  slug: String!
  "The `sold_single_sale_offers` field cannot be nested within a list."
  soldSingleSaleOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): SingleSaleOfferConnection! @deprecated(reason: "use soldSingleSaleTokenOffers instead")
  "The `sold_single_sale_token_offers` field cannot be nested within a list."
  soldSingleSaleTokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenOfferConnection!
  sorareAddress: String
  starkKey: String
  starkKeyRegistered: Boolean! @deprecated(reason: "no longer relevant")
  "Set to true if the user deleted his account or was suspended"
  suspended: Boolean!
  "The `token_auctions` field cannot be nested within a list."
  tokenAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenAuctionConnection!
  "The `trophies` field cannot be nested within a list."
  trophies: [So5Trophies!]!
  "The `trophies_summary` field cannot be nested within a list."
  trophiesSummary: So5TrophiesSummary!
  "The `won_english_auctions` field cannot be nested within a list."
  wonEnglishAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption  ): EnglishAuctionConnection! @deprecated(reason: "use wonTokenAuctions instead")
  "The `won_token_auctions` field cannot be nested within a list."
  wonTokenAuctions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortByEndDate: SortingOption, sport: [Sport!]  ): TokenAuctionConnection!
}
interface ReferralRewardInterface {
  id: UUID!
  card: CardInterface!
  state: RewardState!
}
interface RewardInterface {
  id: UUID!
  card: CardInterface!
  backImageUrl: String!
  tier: Int!
  lineup: LineupInterface!
  state: RewardState!
}
interface ShopItemInterface {
  cardCollectionRequirements: [CardCollectionRequirement!]!
  createdAt: ISO8601DateTime!
  description: String
  disabled: Boolean!
  expirationDate: ISO8601DateTime
  id: ID!
  limitPerUser: Int!
  myAvailableTotalPurchasesCount: Int!
  myAvailableUserShopItems: [UserShopItem!]
  myBalance: Int!
  myLimitResetAt: ISO8601DateTime
  myPurchasesCount: Int!
  name: String!
  pictureUrl: String!
  position: ShopItemType!
  price: Int!
  salePrice: Int
  shopItemsRequired: [ShopItem!]!
  unlocked: Boolean!
}
interface So5CurrentUserInterface {
  "List of current user blockchain football cards engaged in lineups (for live or upcoming fixtures)"
  blockchainCardsInLineups: [String!]!
  footballLast30DaysLineupsCount: Int!
  myFootballManagerTasks: [FootballManagerTask!]!
  onboardingStatus: Onboarding!
  "If the so5 no card route is open for submission"
  so5NoCardRouteOpened: Boolean!
  unclaimedActionRewards: [ActionReward!]!
  unclaimedSo5Rewards: [So5Reward!]!
}
"So5Leaderboard Rules"
interface So5LeaderboardRulesInterface {
  canCompose: Validity!
  defaultAverageScore: AveragePlayerScore
  displayedRules: So5Rules
  rules: So5Rules
}
"Social pictures"
interface SocialPicturesInterface {
  socialPictureUrls: SocialPictureDerivative!
}
interface SportsNode {
  id: UUID!
}
interface SportsTeamInterface {
  id: UUID!
  name: String!
  market: String!
  fullName: String!
  abbreviation: String!
  slug: String!
  svgUrl: String!
  monochromeSvgUrl: String!
  teamStyleGuidePrimaryColor: HexColorCode!
  players: [PlayerInterface!]!
}
"Objects with publicly accessible cards"
interface TeamInterface {
  activeCompetitions: [Competition!]!
  "The `active_memberships` field cannot be nested within a list."
  activeMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MembershipConnection!
  "The `active_players` field cannot be nested within a list."
  activePlayers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PlayerConnection!
  "The `cards` field cannot be nested within a list."
  cards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,age: Int, assetIds: [String!], 
    "Returns the elements in the list that come before the specified cursor."
    before: String,customCardEditionName: String, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): CardConnection!
  code: String
  country: Country!
  customBanner: CustomBanner
  dataPartner: DataPartner
  founded: String
  "The `games` field cannot be nested within a list."
  games(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "End time (inclusive) of the game."
    endDate: ISO8601DateTime!,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Start time (inclusive) of the game."
    startDate: ISO8601DateTime!
  ): GameConnection!
  id: ID!
  lastFiveGames: [Game!]!
  "The `latest_games` field cannot be nested within a list."
  latestGames(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GameConnection!
  name: String!
  optaId: String
  pictureSecondaryUrl: String
  pictureUrl(derivative: String = "low_res"): String
  "The `players` field cannot be nested within a list."
  players(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PlayerConnection!
  ready: Boolean!
  "The `recent_departures` field cannot be nested within a list."
  recentDepartures(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PlayerConnection!
  shortName: String!
  slug: String!
  upcomingGames(first: Int!): [Game]!
}
"Card token metadata"
interface TokenCardMetadataInterface {
  id: ID!
  playerDisplayName: String!
  playerSlug: String!
  rarity: Rarity!
  seasonStartYear: Int!
  serialNumber: Int!
  singleCivilYear: Boolean!
  supply: Int!
  teamSlug: String!
}
"Operation that have a trade"
interface TokenOperationTradeInterface {
  hasTrade: Boolean!
}
interface UserInterface {
  id: ID!
  slug: String!
  nickname: String!
}
"User Offer Interface"
interface UserOffersInterface {
  blockedUntil: ISO8601DateTime
  blockedUsers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserConnection!
  directOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,direction: OfferDirection!, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption  ): OfferConnection! @deprecated(reason: "Use tokenOffers")
  endedDirectOffersReceived(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption  ): OfferConnection! @deprecated(reason: "Use endedTokenOffersReceived")
  endedDirectOffersSent(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption  ): OfferConnection! @deprecated(reason: "Use endedTokenOffersSent")
  endedTokenOffersReceived(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption, sport: [Sport!] = [FOOTBALL, BASEBALL, NBA], states: [OfferState!]  ): TokenOfferConnection!
  endedTokenOffersSent(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption, sport: [Sport!] = [FOOTBALL, BASEBALL, NBA], states: [OfferState!]  ): TokenOfferConnection!
  pendingDirectOffersReceived(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption  ): OfferConnection! @deprecated(reason: "Use pendingTokenOffersReceived")
  pendingDirectOffersSent(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption  ): OfferConnection! @deprecated(reason: "Use pendingTokenOffersSent")
  pendingTokenOffersReceived(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption, sport: [Sport!] = [FOOTBALL, BASEBALL, NBA]  ): TokenOfferConnection!
  pendingTokenOffersSent(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption, sport: [Sport!] = [FOOTBALL, BASEBALL, NBA]  ): TokenOfferConnection!
  tokenOffers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,direction: OfferDirection!, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption, sport: [Sport!] = [FOOTBALL, BASEBALL, NBA], states: [OfferState!]  ): TokenOfferConnection!
}
"User social connections"
interface UserSocialInterface {
  followed: EmailSubscription
  "The `followers` field cannot be nested within a list."
  followers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserWithSubscriptionSlugConnection!
  followersCount: Int!
  "The `following` field cannot be nested within a list."
  following(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserWithSubscriptionSlugConnection!
  followingCount: Int!
  "The `recommended_managers` field cannot be nested within a list."
  recommendedManagers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserConnection!
}
"Fast withdrawal"
interface WithFastWithdrawal {
  "Get a starkware conditional transfer request for a fast withdrawal"
  fastWithdrawal(
    "Amount to withdraw, in wei."
    amount: String!,
    "Destination Ethereum address."
    to: String!
  ): FastWithdrawal! @deprecated(reason: "use prepareFastWithdrawal mutation")
}
"Favorites"
interface WithFavoriteInterface {
  favoriteCards: [Card!]! @deprecated(reason: "Use `my_subscriptions` instead")
  favoriteClubs: [Club!]! @deprecated(reason: "Use `my_subscriptions` instead")
  favoritePlayers: [Player!]! @deprecated(reason: "Use `my_subscriptions` instead")
  mySubscriptions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,sortType: SortingOption, types: [SubscribableType!]  ): EmailSubscriptionConnection!
}
"Objects with memberships"
interface WithMemberships {
  activeClubMembership: Membership
  appearances: Int!
  beforeLastOwningMembership: Membership
  clubMemberships: [Membership!]!
  memberships: [Membership!]!
}
"Notifications"
interface WithNotifications {
  notifications(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filters notifications by the specified categories when set."
    categories: [NotificationCategoryInput!],
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters notifications by sports"
    sports: [Sport!]
  ): NotificationConnection!
  "Get notifications fields."
  notificationsDetails(
    "Filters notifications by the specified categories when set."
    categories: [NotificationCategoryInput!]
  ): Notifications!
  unreadNotificationsCount(
    "Filters notifications by the specified categories when set."
    categories: [NotificationCategoryInput!],
    "Filters notifications by sports"
    sports: [Sport!]
  ): Int!
}
"Objects with publicly accessible cards"
interface WithPublicCardsInterface {
  "The `cards` field cannot be nested within a list."
  cards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,age: Int, assetIds: [String!], 
    "Returns the elements in the list that come before the specified cursor."
    before: String,customCardEditionName: String, 
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,owned: Boolean, ownedSinceAfter: ISO8601DateTime, playerSlugs: [String!], 
    "positions of the card capitalized"
    positions: [Position!],
    "rarities of the card in lowercase"
    rarities: [Rarity!],serialNumber: Int, shirtNumber: Int, slugs: [String!], teamSlugs: [String!]  ): CardConnection!
}
"With Referral Interface"
interface WithReferralsInterface {
  referee: Boolean!
  refereeReward: ReferralReward
  referralAsReferee: Referral
  "Get the list of referral milestone rewards"
  referralMilestoneRewards(sport: Sport!): [ReferralMilestoneReward!]!
  referralRewardsCount: Int!
  referralUrl: String!
  "Get the list of referrals"
  referrals(
    "Page to retrieve. Defaults to 0."
    page: Int,
    "Maximum number of referrals to return. Defaults to 50."
    pageSize: Int,
    "Filters the referrals by sport."
    sport: Sport,
    "Filters the returned referrals by `state` when set."
    state: ReferralState
  ): ReferralPaginated!
  referrer: User
  unclaimedReferralRewardsCount: Int!
}
interface WithSubscriptionsInterface {
  currentUserSubscription: EmailSubscription
  slug: String!
  subscriptionsCount: Int!
}
interface XPBoosterShopItemInterface {
  endLevel: Int!
  rarity: Rarity!
  startLevel: Int!
}
"Object that can be an account accountable"
union Accountable = CommonAccount | EthereumAccount | FiatWalletAccount | LoomAccount | StarkwareAccount
"Object that can be an account owner"
union AccountOwner = Contract | User
"A Mangopay bank account type"
union BankAccount = CaBankAccount | GbBankAccount | IbanBankAccount | OtherBankAccount | UsBankAccount
"Object that have a blockchain address to interact with the platform"
union BlockchainUser = AnonymousUser | User
"Object that can be a shop item"
union ClubShopItem = DeliverableWithNoVariantShopItem | ExtraSwapShopItem | JerseyShopItem | LevelUpShopItem | RecoveryKitShopItem | ShopItem | SkinShopItem | XPRestoreShopItem
"Object that can be a deliverable shop item"
union DeliverableShopItem = DeliverableWithNoVariantShopItem | JerseyShopItem | ShopItem
"Object that can be drafted for the Football: Sorare daily game"
union DraftableObject = SorareDailyDraftableCard | SorareDailyDraftablePlayer
"Object that can be an EnglishAuction content provider"
union EnglishAuctionContentProvider = Club | Competition | NationalTeam
"Object that can be a feed item"
union FeedItem = ClanFeedItem | GameFeedItem | SquadFeedItem
"Object that can be drafted for the Football: Head to Head game"
union FootballHeadToHeadDraftableObject = FootballHeadToHeadDraftableCard | FootballHeadToHeadDraftablePlayer
"User notification"
union Notification = AnnouncementNotification | AuctionNotification | CardCollectionNotification | CardNotification | DecisiveActionNotification | ExternalDepositNotification | KycRequestNotification | OfferNotification | ReferralRewardNotification | SaleNotification | So5LineupNotification | So5UserGroupNotification | UserAwardNotification
"Object that can be an owner"
union Ownerable = AnonymousUser | Contract | User
"Object that can be an operation of a PaymentIntent"
union PaymentIntentOperation = Bid | Offer | TokenPrimaryOffer
"Object that can be a tokenOperation of a PaymentIntent"
union PaymentIntentTokenOperation = TokenBid | TokenOffer | TokenPrimaryOffer
"Object that can be a referrer"
union Referrer = User | UserSource
"An authorization to move assets"
union Request = MangopayCreditCardAuthorizationRequest | MangopayWalletTransferAuthorizationRequest | StarkexLimitOrderAuthorizationRequest | StarkexTransferAuthorizationRequest | StripeCreditCardAuthorizationRequest
"Object that can be subscribed to"
union Subscribable = Card | CardCollection | Club | Country | Player | User
"Type of a subscriber to a new card, player, country or club related auction"
union Subscriber = CurrentUser
"Object that can be a team"
union Team = Club | NationalTeam
"Offer, PrimaryOffer or Auction"
union TokenDeal = TokenAuction | TokenOffer | TokenPrimaryOffer
"Sport token metadata"
union TokenMetadata = TokenBaseballMetadata | TokenFootballMetadata
"Object that can be an operation of a UserAccountEntry"
union UserAccountEntryOperation = Bid | EthMigration | FastWithdrawal | FullWithdrawalRequest | Offer | So5Reward | StarkwareWithdrawal | TokenMonetaryReward | TokenPrimaryOffer | TokenWithdrawal | Withdrawal
"Object that can be an tokenOperation of a UserAccountEntry"
union UserAccountEntryTokenOperation = EthMigration | FastWithdrawal | FullWithdrawalRequest | MangopayWithdrawal | So5Reward | StarkwareWithdrawal | TokenBid | TokenMonetaryReward | TokenOffer | TokenPrimaryOffer | TokenWithdrawal | Withdrawal
enum Action {
  ACTIVITY
  GLOBAL_CUP_22_REFERRAL
}
enum ArenaRequestState {
  ACCEPTED
  CREATED
}
enum AvailableDraftPlayersSorting {
  PERCENTAGE
  VALUE
}
enum AveragePlayerScore {
  LAST_FIFTEEN_SO5_AVERAGE_SCORE
  LAST_FIVE_SO5_AVERAGE_SCORE
}
enum Award {
  BUYER
  COACH
  SCOUT
}
enum AwardCategory {
  COLLECTOR
  GENERAL_MANAGER
  MANAGER
}
enum BankAccountType {
  CA
  GB
  IBAN
  OTHER
  US
}
enum BaseballCardRarity {
  unique
  super_rare
  rare
  limited
  common
}
enum BaseballComposeLineupCardsScoreSortOrder {
  SEASON_AVERAGE_SCORE
  LAST_15_AVERAGE_SCORE
}
enum BaseballConference {
  AMERICAN
  NATIONAL
}
enum BaseballCreateOrUpdateLineupValidationError {
  MISSING_PITCHER_AT_REQUIRED_RARITY
  ALLOWED_RARITIES_VIOLATION
  MIN_RARITY_VIOLATION
  BOOST_UNAVAILABLE
}
enum BaseballInningHalf {
  TOP
  BOTTOM
}
enum BaseballPlayerFixtureStatsPosition {
  STARTING_PITCHER
  RELIEF_PITCHER
  CORNER_INFIELDER
  MIDDLE_INFIELDER
  OUTFIELDER
}
enum BaseballPlayerLineupPosition {
  STARTING_PITCHER
  RELIEF_PITCHER
  CORNER_INFIELDER
  MIDDLE_INFIELDER
  OUTFIELDER
}
enum BaseballPlayerPosition {
  STARTING_PITCHER
  RELIEF_PITCHER
  FIRST_BASE
  THIRD_BASE
  DESIGNATED_HITTER
  CATCHER
  SECOND_BASE
  SHORTSTOP
  OUTFIELD
}
enum BaseballPosition {
  CATCHER
  DESIGNATED_HITTER
  FIRST_BASE
  OUTFIELD
  RELIEF_PITCHER
  SECOND_BASE
  SHORTSTOP
  STARTING_PITCHER
  THIRD_BASE
  UNKNOWN
}
enum Blockchain {
  ETHEREUM
  LOOM
  NO_BLOCKCHAIN
  STARKWARE
}
enum CardCoverageStatus {
  FULL
  LEGEND
  NOT_COVERED
  NOT_ELIGIBLE
  PARTIAL
  SPECIAL
}
enum CardDesign {
  BASEBALL_2022
  BASEBALL_2023
  FOOTBALL_2018
  FOOTBALL_2019
  FOOTBALL_2020
  FOOTBALL_2021
  FOOTBALL_2022
  FOOTBALL_2022_2023
  FOOTBALL_2023
  FOOTBALL_GC_2022
  FOOTBALL_GC_SILHOUETTE_2022
  FOOTBALL_LEGACY_LEGEND
  FOOTBALL_LEGEND
  NBA_2022
  NBA_2023
  NBA_2023_DRAFT
}
enum CardQuality {
  TIER_0
  TIER_1
  TIER_2
  TIER_3
  TIER_4
  TIER_5
}
enum CardRarity {
  unique
  super_rare
  rare
  limited
  common
}
enum CardWasUpdatedEvent {
  "When a bid was created on an auction"
  auction_event_bid
  "When the bid value is increased"
  auction_event_bid_increased
  "When an auction is cancelled"
  auction_event_cancelled
  "When an auction closes without bids"
  auction_event_closed
  "When an auction is flagged as fraudulent"
  auction_event_flagged
  "When an auction was successfully closed"
  auction_event_successfull
  "When an offer is settled"
  offer_event_accepted
  "When an offer is cancelled"
  offer_event_cancelled
  "When an offer is flagged as fraudulent"
  offer_event_flagged
  "When an offer becomes live"
  offer_event_opened
  "When the bonus of a user card collection changes"
  user_card_collection_event_bonus_changed
}
enum ChallengeState {
  CLOSED
  CREATED
}
enum ChallengeType {
  ARENA
  FRIENDLY
}
enum ClanFeedItemType {
  LINEUP_CREATED
  PLAYER_SUBSTITUTED
}
enum Collection {
  BASEBALL
  FOOTBALL
  FOOTBALL_NATIONAL_SERIES
  NBA
}
enum CommonDraftCampaignStatus {
  CLOSED
  FINAL
  OPEN
  REDRAFTABLE
  SWAPPABLE
}
enum CommonDraftCampaignType {
  EXTRA
  ONBOARDING
}
enum CompetitionFormat {
  DOMESTIC_CUP
  DOMESTIC_LEAGUE
  DOMESTIC_SUPER_CUP
  INTERNATIONAL_CUP
  INTERNATIONAL_SUPER_CUP
}
enum CompetitionType {
  CLUB
  INTERNATIONAL
}
enum ConversionCreditCampaignStatus {
  ACTIVE
  CANCELLED
  CREATED
  EXPIRED
}
enum ConversionCreditStatus {
  CANCELLED
  CLAIMED
  CREATED
  EXPIRED
  RECLAIMED
  USED
  USING
}
enum CreditCardBrand {
  "American Express"
  AMERICAN_EXPRESS
  "Cartes Bancaires"
  CARTES_BANCAIRES
  "Diners Club"
  DINERS_CLUB
  "Discover"
  DISCOVER
  "JCB"
  JCB
  "Maestro"
  MAESTRO
  "MasterCard"
  MASTERCARD
  "UnionPay"
  UNION_PAY
  "Unknown"
  UNKNOWN
  "Visa"
  VISA
}
enum CreditCardType {
  AMEX
  CB_VISA_MASTERCARD
  MAESTRO
}
enum Currency {
  ETH
  FIAT
}
enum CustomRewardExperience {
  EVENT
  JERSEY
  MERCH
  TICKET
}
enum CustomSortingOption {
  CUSTOM
  DEFAULT
}
enum DecisiveStatType {
  ASSIST_PENALTY_WON
  CLEAN_SHEET
  CLEAN_SHEET_60
  CLEARANCE_OFF_LINE
  ERROR_LEAD_TO_GOAL
  GOALS
  GOAL_ASSIST
  LAST_MAN_TACKLE
  OWN_GOALS
  PENALTY_CONCEDED
  PENALTY_SAVE
  RED_CARD
  THREE_GOALS_CONCEDED
}
enum DeckCategory {
  ALL_TIME_BEST
  USER_FAVORITE
}
enum DeckFormation {
  FREE
  ONE_ONE_TWO
  ONE_TWO_ONE
  TWO_ONE_ONE
}
enum Delivery {
  EMAIL
  PHONE
}
enum DepositProvider {
  ETH_WALLET
  EXTERNAL
  MANGOPAY_BANK_WIRE
  MANGOPAY_CREDIT_CARD
  MOONPAY
  RAMP
}
enum DepositStatus {
  COMPLETED
  EXPIRED
  FAILED
  PENDING
}
enum DeviceWasUpdatedEvent {
  "When a device is confirmed"
  confirmed
  "When a device is revoked"
  revoked
}
enum EnabledWallet {
  ETH
  FIAT
}
enum ExternalDepositNotificationStatus {
  FINALIZED
  PENDING
}
enum FeaturedPageDuration {
  DAYS_1
  DAYS_30
  DAYS_7
}
enum FiatCurrency {
  EUR
  GBP
  USD
}
enum FiatWalletAccountState {
  OWNER
  PAYER
  VALIDATED_OWNER
}
enum FiatWalletKycRefusedReason {
  DOCUMENT_DO_NOT_MATCH_USER_DATA
  DOCUMENT_HAS_EXPIRED
  DOCUMENT_INCOMPLETE
  DOCUMENT_NOT_ACCEPTED
  DOCUMENT_UNREADABLE
  UNDERAGE_PERSON
}
enum FiatWalletKycState {
  CREATED
  OUT_OF_DATE
  REFUSED
  VALIDATED
  VALIDATION_ASKED
}
enum FixtureState {
  opened
  started
  closed
}
enum FootballManagerTaskSlug {
  BUY_CARD
  COMPOSE_TEAM_AMATEUR
  COMPOSE_TEAM_SEMI_PRO
  DISCOVER_PROGRESSION
  DRAFT_SECOND_AMATEUR
  LEARN_COMPETITIONS
  PLACE_BID
  SCOUT_PLAYER
  WATCH_TUTORIAL
  WATCH_VIDEO
}
enum FootballManagerTaskState {
  ASSIGNED
  CANCELED
  CLAIMED
  COMPLETED
  READY
}
enum FootballPosition {
  COACH
  DEFENDER
  FORWARD
  GOALKEEPER
  MIDFIELDER
  UNKNOWN
}
enum GameCoverageStatus {
  FULL
  LOW
  NOT_COVERED
  UNCERTAIN
}
enum GameFeedItemType {
  DECISIVE_STAT_UPDATED
  GAME_PERIOD_CHANGED
}
enum GameStatus {
  scheduled
  playing
  played
  canceled
  delayed
  postponed
  suspended
}
enum GoSport {
  NBA @deprecated(reason: "use Sport.NBA instead")
  BASEBALL @deprecated(reason: "use Sport.BASEBALL instead")
}
enum GradualOnboardingPhase {
  NONE
  CLAIM_FIRST_COMMON_CARDS
  FIRST_OPEN_FIXTURE
  FIRST_LIVE_FIXTURE
  SECOND_OPEN_FIXTURE
  SECOND_LIVE_FIXTURE
  FIRST_LIMITED_LEADERBOARD
}
enum IRLPrizeType {
  TICKETS
  GIFT_CARD
  JERSEY
  MEMORABILIA
  TV_SUBSCRIPTION
}
"A Mangopay KYC Document type"
enum KycDocumentType {
  DRIVING_LICENSE
  NATIONAL_HEALTH_INSURANCE_CARD
  NATIONAL_ID
  PASSPORT
  RESIDENCE_PERMIT
  TAX_ID
}
enum KycRequestNotificationStatus {
  REFUSED
  VALIDATED
}
enum LeaderboardRarity {
  COMMON
  LIMITED
  RARE
  SUPER_RARE
  UNIQUE
  MIXED
}
enum LineupTacticType {
  ALL_OUT_ATTACK
  GEGENPRESSING
  JOGA_BONITO
  PARK_THE_BUS
  TIKI_TAKA
}
enum LiveActivity {
  LINEUP
}
enum NBAConference {
  EASTERN
  WESTERN
}
enum NBACreateOrUpdateLineupValidationError {
  ALLOWED_RARITIES_VIOLATION
  MIN_RARITY_VIOLATION
}
enum NBAOnboardingTask {
  NO_TASK
  SELECT_STARTER_CARD
}
enum NBAPlayerPosition {
  NBA_GUARD
  NBA_FORWARD
  NBA_CENTER
}
enum NBAPosition {
  CENTER
  FORWARD
  GUARD
  UNKNOWN
}
enum OAuthProvider {
  FACEBOOK
  GOOGLE_OAUTH2
}
enum OfferDirection {
  RECEIVED
  SENT
}
enum OfferState {
  ACCEPTED
  BLOCKED
  CANCELLED
  ENDED
  FLAGGED
  MINTED
  OPENED
  PENDING_MIGRATION
  PENDING_REJECTION
  PENDING_REVIEW
  READY_FOR_SCORING
  REJECTED
  SCORED
  SETTLABLE
  SETTLEMENT_FAILED
  SETTLEMENT_PUBLISHED
}
enum OfferType {
  DIRECT_OFFER
  SINGLE_BUY_OFFER
  SINGLE_SALE_OFFER
}
enum OnboardingStepEnum {
  CARD_DETAILS
  CARD_SCARCITIES
  COMPOSE_TEAM
  CONGRATULATION
  CREATE_YOUR_CLUB
  EARNING_REWARDS
  FIRST_DIVISION_DRAFT
  FOLLOW_PLAYERS
  GET_STARTED
  MARKETPLACE_WALKTHROUGH
  SELECT_FAVORITE_CLUB
  SPECIAL_EVENT_DRAFT
  WELCOME_TO_MARKETPLACE
  WHAT_ARE_LEAGUES
  WINNING_A_LEAGUE
}
enum OnboardingTaskEnum {
  ADD_FAVOURITE_CLUBS
  AFTER_COMPLETE
  COMPOSE_TEAM
  CONGRATULATION
  FIRST_DIVISION_DRAFT
  FOLLOW_PLAYER
  JOIN_ROOKIE
  PLACE_FIRST_BID
  SPECIAL_EVENT_DRAFT
}
enum OnboardingTaskState {
  DONE
  TODO
  TO_CLAIM
}
enum Outcome {
  DRAW
  LOSE
  WIN
}
enum OwnerTransfer {
  BUNDLED_ENGLISH_AUCTION
  DEPOSIT
  DIRECT_OFFER
  ENGLISH_AUCTION
  MINT
  PACK
  REFERRAL
  REWARD
  SINGLE_BUY_OFFER
  SINGLE_SALE_OFFER
  TRANSFER
  WITHDRAWAL
}
enum PaymentCurrency {
  ETH
  EUR
  GBP
  USD
}
enum PaymentIntentState {
  CANCELLED
  FAILED
  PENDING_REFUND
  READY
  REFUNDED
  SPENT
}
enum PaymentMethodProvider {
  MANGOPAY
  STRIPE
}
enum Period {
  END_OF_EXTRA_TIME_BEFORE_PENALTIES
  END_OF_SECOND_HALF_BEFORE_EXTRA_TIME
  EXTRA_TIME_FIRST_HALF
  EXTRA_TIME_HALF_TIME
  EXTRA_TIME_SECOND_HALF
  FIRST_HALF
  FULL_TIME
  HALF_TIME
  PENALTY_SHOOTOUT
  PRE_MATCH
  SECOND_HALF
}
enum PicturePositioning {
  AS_IS
  AUTO
}
enum PlayerFixtureStatsSortOrder {
  SCORE
  OUTPERFORMANCE
}
enum PlayerInFixtureStatusIconType {
  FINAL_SCORE
  IN_PROGRESS_SCORE
  PENDING
  NO_GAME
  DID_NOT_PLAY
  INACTIVE
  TBD
}
enum PlayerOwnershipFilterType {
  UNOWNED
  OWNED
}
enum PlayerPlayingStatus {
  NOT_PLAYING
  REGULAR
  RETIRED
  STARTER
  SUBSTITUTE
  SUPER_SUBSTITUTE
}
enum Position {
  Coach
  Defender
  Forward
  Goalkeeper
  Midfielder
  Unknown
}
enum PrivateKeyRecoveryOptionMethodEnum {
  EMAIL
  PHONE
}
enum PrivateKeyRecoveryOptionStatusEnum {
  ACTIVE
  INACTIVE
  PENDING_VALIDATION
}
enum Rarity {
  common
  custom_series
  limited
  rare
  super_rare
  unique
}
enum ReferralState {
  ALL
  COMPLETED
  EXPIRED
  IN_PROGRESS
}
enum RestrictionGroup {
  ACADEMY_GROUP
  BLOCKCHAIN_GROUP
}
enum RewardCategory {
  ROOM
  SQUAD
}
enum RewardState {
  CLAIMED
  UNCLAIMED
}
enum SettlementDelayReason {
  "A conversion credit was used to buy the token"
  CONVERSION_CREDIT_USED
}
enum ShippingState {
  CLAIMED
  READY_TO_CLAIM
}
enum ShirtSize {
  L
  M
  S
  XL
  XS
  XXL
}
enum ShopItemsSorting {
  DATE
  PRICE
}
enum ShopItemType {
  BANNER
  DELIVERABLE_WITH_NO_VARIANT
  EXTRA_SWAP
  EXTRA_TEAMS_CAP
  JERSEY
  LEVEL_UP
  LOGO
  RECOVERY_KIT
  SHIELD
  XP_RESTORE
}
enum SignupPlatform {
  MOBILE
  MOBILE_WEB
  WEB
}
enum So5LeaderboardRarity {
  COMMON
  LIMITED
  MIX
  RARE
  RARE_PRO
  SUPER_RARE
  UNIQUE
}
enum So5LeaderboardTournament {
  CHALLENGER_EUROPE
  CHAMPION_AMERICA
  CHAMPION_ASIA
  CHAMPION_EUROPE
  CHAMPION_JUPILER
  FIRST_DIVISION_ENGLAND
  FIRST_DIVISION_FRANCE
  FIRST_DIVISION_GERMANY
  FIRST_DIVISION_ITALY
  FIRST_DIVISION_SPAIN
  FIRST_DIVISION_US
  GLOBAL_ALL_STAR
  GLOBAL_CAP
  GLOBAL_KICKOFF
  GLOBAL_SPECIALIST
  GLOBAL_UNDERDOG
  GLOBAL_UNDER_TWENTY_ONE
  GLOBAL_UNIQUE_ONLY
  SECOND_DIVISION_EUROPE
  SPECIAL_GLOBAL_CUP
  SPECIAL_TRAINING_CENTER
  SPECIAL_WEEKLY
  STARTER_ACADEMY
  STARTER_ROOKIE
}
enum So5LeaderboardType {
  CHALLENGER_EUROPE_LIMITED
  CHALLENGER_EUROPE_RARE
  CHALLENGER_EUROPE_RARE_PRO
  CHALLENGER_EUROPE_SUPER_RARE
  CHALLENGER_EUROPE_UNIQUE
  CHAMPION_AMERICA_LIMITED
  CHAMPION_AMERICA_RARE
  CHAMPION_AMERICA_RARE_PRO
  CHAMPION_AMERICA_SUPER_RARE
  CHAMPION_AMERICA_UNIQUE
  CHAMPION_ASIA_LIMITED
  CHAMPION_ASIA_RARE
  CHAMPION_ASIA_RARE_PRO
  CHAMPION_ASIA_SUPER_RARE
  CHAMPION_ASIA_UNIQUE
  CHAMPION_EUROPE_LIMITED
  CHAMPION_EUROPE_RARE
  CHAMPION_EUROPE_RARE_PRO
  CHAMPION_EUROPE_SUPER_RARE
  CHAMPION_EUROPE_UNIQUE
  CHAMPION_JUPILER_RARE
  CHAMPION_JUPILER_RARE_PRO
  CHAMPION_JUPILER_SUPER_RARE
  CHAMPION_JUPILER_UNIQUE
  FIRST_DIVISION_ENGLAND_AMATEUR
  FIRST_DIVISION_ENGLAND_PRO
  FIRST_DIVISION_ENGLAND_SEMI_PRO
  FIRST_DIVISION_FRANCE_AMATEUR
  FIRST_DIVISION_FRANCE_PRO
  FIRST_DIVISION_FRANCE_SEMI_PRO
  FIRST_DIVISION_GERMANY_AMATEUR
  FIRST_DIVISION_GERMANY_PRO
  FIRST_DIVISION_GERMANY_SEMI_PRO
  FIRST_DIVISION_ITALY_AMATEUR
  FIRST_DIVISION_ITALY_PRO
  FIRST_DIVISION_ITALY_SEMI_PRO
  FIRST_DIVISION_SPAIN_AMATEUR
  FIRST_DIVISION_SPAIN_PRO
  FIRST_DIVISION_SPAIN_SEMI_PRO
  FIRST_DIVISION_US_AMATEUR
  FIRST_DIVISION_US_PRO
  FIRST_DIVISION_US_SEMI_PRO
  GLOBAL_ALL_STAR_LIMITED
  GLOBAL_ALL_STAR_RARE
  GLOBAL_ALL_STAR_RARE_PRO
  GLOBAL_ALL_STAR_SUPER_RARE
  GLOBAL_ALL_STAR_UNIQUE
  GLOBAL_CAP_220_LIMITED
  GLOBAL_CAP_220_RARE
  GLOBAL_CAP_220_SUPER_RARE
  GLOBAL_CAP_220_UNIQUE
  GLOBAL_CAP_240_LIMITED
  GLOBAL_CAP_240_RARE
  GLOBAL_CAP_240_SUPER_RARE
  GLOBAL_CAP_240_UNIQUE
  GLOBAL_CAP_270_LIMITED
  GLOBAL_CAP_270_RARE
  GLOBAL_CAP_270_SUPER_RARE
  GLOBAL_CAP_270_UNIQUE
  GLOBAL_KICKOFF_LIMITED
  GLOBAL_KICKOFF_RARE
  GLOBAL_KICKOFF_SUPER_RARE
  GLOBAL_KICKOFF_UNIQUE
  GLOBAL_SPECIALIST_LIMITED
  GLOBAL_SPECIALIST_RARE
  GLOBAL_SPECIALIST_SUPER_RARE
  GLOBAL_SPECIALIST_SUPER_RARE_UNIQUE
  GLOBAL_SPECIALIST_UNIQUE
  GLOBAL_UNDERDOG_LIMITED
  GLOBAL_UNDERDOG_RARE
  GLOBAL_UNDERDOG_SUPER_RARE
  GLOBAL_UNDERDOG_UNIQUE
  GLOBAL_UNDER_TWENTY_ONE_LIMITED
  GLOBAL_UNDER_TWENTY_ONE_RARE
  GLOBAL_UNDER_TWENTY_ONE_RARE_PRO
  GLOBAL_UNDER_TWENTY_ONE_SUPER_RARE
  GLOBAL_UNDER_TWENTY_ONE_UNIQUE
  GLOBAL_UNIQUE_ONLY
  LEGEND
  LEGEND_PRO
  SECOND_DIVISION_EUROPE_LIMITED
  SECOND_DIVISION_EUROPE_RARE
  SECOND_DIVISION_EUROPE_RARE_PRO
  SECOND_DIVISION_EUROPE_SUPER_RARE
  SECOND_DIVISION_EUROPE_UNIQUE
  SPECIAL_GLOBAL_CUP
  SPECIAL_TRAINING_CENTER
  SPECIAL_WEEKLY
  STARTER_ACADEMY_ADVANCED
  STARTER_ACADEMY_INTERMEDIATE
  STARTER_ACADEMY_NOVICE
  STARTER_ACADEMY_PROFICIENT
  STARTER_ROOKIE
}
enum So5State {
  LIVE
  PAST
  UPCOMING
}
enum So5UserGroupStatus {
  ENDED
  STARTED
  TO_START
}
enum SortingOption {
  ASC
  DESC
}
enum Sport {
  BASEBALL
  FOOTBALL
  NBA
}
enum SquadFeedItemType {
  MANAGER_JOINED
  PLAYER_SUBSTITUTED
}
enum StarterPackState {
  CANCELLED
  CREATED
  FAILED
  ON_SALE
  READY
  SOLD
}
enum StatCategory {
  ATTACKING
  DEFENDING
  GENERAL
  GOALKEEPING
  NEGATIVE_DECISIVE_STAT
  PASSING
  POSITIVE_DECISIVE_STAT
  POSSESSION
  UNKNOWN
}
enum SubscribableType {
  BASEBALL_CARD
  BASEBALL_PLAYER
  CARD
  COUNTRY
  NBA_CARD
  NBA_PLAYER
  PLAYER
  TEAM
  USER
}
enum SupportedCurrency {
  EUR
  GBP
  USD
  WEI
}
enum TermsAndConditionsStatus {
  "Has approved the latest TCUs"
  ACCEPTED
  "Has never approved any TCUs"
  INITIAL
  "Has approved TCUs but those are now outdated"
  OUTDATED
}
enum TokenPaymentMethod {
  CREDIT_CARD
  WALLET
}
enum Tradeable {
  "The card should be deposited on Sorare before being traded"
  DEPOSIT_REQUIRED
  "The card is neither in the Sorare account nor in the mapped account"
  NO
  "The card has not yet been transferred"
  NOT_YET
  "The card has no owner or does not belong to the user"
  UNDEFINED
  "The card is transferrable"
  YES
}
enum TransactionStatus {
  "Transaction cancelled"
  CANCELLED
  "Transaction confirmed"
  CONFIRMED
  "Transaction dropped"
  DROPPED
  "Transaction failed"
  FAILED
  "Transaction is currently minting"
  PENDING
}
enum UserAccountEntryEntry {
  DEPOSIT
  ETH_MIGRATION_ROUNDING
  PAYMENT
  PAYMENT_FEE
  REWARD
  WITHDRAWAL
  WITHDRAWAL_FEE
}
enum UserAccountEntryState {
  CANCELLED
  CONFIRMED
  PENDING
}
enum UserSportProfileOnboardingStatus {
  COMPLETED
  NONE
  STARTED
}
enum UserSportProfileVariant {
  GLOBAL_CUP_22
  NONE
  OFF_SEASON
}
enum UserWalletStatusEnum {
  LOCKED
  READY
  RECOVERY_SENT
}
enum VariantStockCountType {
  SHIRT_SIZE
}
enum WalletStatus {
  "The card is stored in the Sorare account"
  INTERNAL
  "The card is stored in the mapped account"
  MAPPED
  "The card has no owner or does not belong to the user"
  UNKNOWN
}
enum WithdrawalState {
  CREATED
  FAILED
  FINALIZED
  PROCESSING
  REFUNDED
}
enum WithdrawalStatus {
  "Withdrawal was cancelled"
  CANCELLED
  "Withdrawal is confirmed"
  CONFIRMED
  "Withdrawal is created and should be confirmed"
  CREATED
  "Withdrawal has settled on the blockchain"
  SETTLED
  "Withdrawal has failed"
  SETTLEMENT_FAILED
  "Withdrawal has been published on the blockchain"
  SETTLEMENT_PUBLISHED
}
"Autogenerated input type of acceptOffer"
input acceptOfferInput {
  approvals: [AuthorizationApprovalInput!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  conversionCreditId: ID
  migrationData: OfferMigrationInput
  "Global ID of the Offer or PrimaryOffer to accept."
  offerId: ID
  settlementInfo: AcceptorSettlementInfoInput
}
"The acceptor settlement info"
input AcceptorSettlementInfoInput {
  conversionCreditId: ID
  currency: SupportedCurrency!
  exchangeRateId: String!
  paymentMethod: TokenPaymentMethod!
  savePaymentMethod: Boolean = false
  walletChallengeSignature: StarkwareSignatureInput
}
"Autogenerated input type of acceptSo5NoCardLineup"
input acceptSo5NoCardLineupInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  so5NoCardLineupId: ID!
}
"Autogenerated input type of acceptTerms"
input acceptTermsInput {
  acceptAgeLimit: Boolean
  acceptGameRules: Boolean!
  acceptPrivacyPolicy: Boolean!
  acceptTerms: Boolean!
  agreedToReceiveOffersFromPartners: Boolean
  agreedToReceiveOffersFromPartnersSpecific: [String!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  tcuToken: String
}
"Autogenerated input type of activateWalletRecovery"
input activateWalletRecoveryInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  destination: String!
  method: PrivateKeyRecoveryOptionMethodEnum!
  verificationCode: String!
}
"Autogenerated input type of addCardsToDeck"
input addCardsToDeckInput {
  cardSlugs: [String!]!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  deckSlug: String!
}
"Autogenerated input type of addDevice"
input addDeviceInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of addEmailToList"
input addEmailToListInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  email: String!
  name: String!
  recaptchaToken: String
  recaptchaTokenV2: String
  utmParams: UtmInput
}
"Autogenerated input type of addFavouriteClubs"
input addFavouriteClubsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  subscribables: [SubscribableInput!]!
}
"Autogenerated input type of addWalletRecovery"
input addWalletRecoveryInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  otpAttempt: String = null
  privateKeyRecovery: PrivateKeyRecoveryInput!
}
"An amount in cents or wei and its currency"
input AmountInput {
  amount: String!
  currency: SupportedCurrency!
}
"Autogenerated input type of approveMigrator"
input approveMigratorInput {
  address: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  nonce: Int!
  signature: String!
}
input AuthorizationApprovalInput {
  fingerprint: String!
  mangopayWalletTransferApproval: MangopayWalletTransferApprovalInput
  starkexLimitOrderApproval: StarkexApprovalInput
  starkexTransferApproval: StarkexApprovalInput
}
input AvailableDraftPlayersSortInput {
  direction: SortingOption!
  type: AvailableDraftPlayersSorting!
}
input BackupPrivateKeyRecoveryInput {
  encryptedSymmetricKey: String!
  iv: String!
  payload: String!
  rsaEncryptionKey: String
  rsaPublicKey: String!
}
"A Mangopay Bank Account Owner Address object"
input BankAccountOwnerAddressInput {
  addressLine1: String!
  addressLine2: String
  city: String!
  country: String!
  postalCode: String!
  region: String
}
input BaseballCardsInput {
  ids: [UUID!]
  assetIds: [ID!]
}
input BaseballCreateOrUpdateLineupInput {
  lineupId: UUID
  leaderboardSlug: String!
  cardSlugs: [String!]!
}
input BaseballDeleteLineupInput {
  lineupId: UUID!
}
input BaseballPlayerFixtureStatsInput {
  position: BaseballPlayerFixtureStatsPosition!
  first: Int! = 100
  after: String
  playerOwnershipFilter: PlayerOwnershipFilter
}
"Autogenerated input type of bid"
input bidInput {
  "Amount in the currency provided in settlement info"
  amount: String!
  approvals: [AuthorizationApprovalInput!]
  "Global ID of the english auction to bid on"
  auctionId: ID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  settlementInfo: AcceptorSettlementInfoInput
}
"Autogenerated input type of blockUserOffers"
input blockUserOffersInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  userSlug: String!
}
"A Mangopay BrowserInfo object"
input BrowserInfoInput {
  colorDepth: Int!
  language: String!
  screenHeight: Int!
  screenWidth: Int!
  timeZoneOffset: Int!
}
"Autogenerated input type of buyDeliverableShopItem"
input buyDeliverableShopItemInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  postalAddress: PostalAddressInput!
  shirtSize: ShirtSize
  shopItemId: ID!
}
"Autogenerated input type of buyShopItem"
input buyShopItemInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  shopItemId: ID!
}
"Autogenerated input type of cancelEthBankWithdrawals"
input cancelEthBankWithdrawalsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of cancelFastWithdrawal"
input cancelFastWithdrawalInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  fastWithdrawalId: ID!
}
"Autogenerated input type of cancelOffer"
input cancelOfferInput {
  blockchainId: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of cancelWithdrawal"
input cancelWithdrawalInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  withdrawalId: ID!
}
"Autogenerated input type of changePassword"
input changePasswordInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  newPasswordHash: String!
  passwordEncryptedPrivateKey: PasswordEncryptedPrivateKeyInput!
  passwordHash: String!
}
"Autogenerated input type of checkPhoneNumberVerificationCode"
input checkPhoneNumberVerificationCodeInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  code: String!
  privateKeyRecovery: PrivateKeyRecoveryInput
}
"Autogenerated input type of claimAward"
input claimAwardInput {
  award: Award!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of claimCardDrop"
input claimCardDropInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  task: OnboardingTaskEnum!
}
"Autogenerated input type of claimConversionCredit"
input claimConversionCreditInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  conversionCreditId: ID
  promoCode: String
}
"Autogenerated input type of claimFootballManagerTask"
input claimFootballManagerTaskInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  footballManagerTaskId: ID!
}
"Autogenerated input type of claimReferralReward"
input claimReferralRewardInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  referralRewardId: ID!
}
"Autogenerated input type of claimReward"
input claimRewardInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  so5RewardId: ID!
}
"Autogenerated input type of claimRewards"
input claimRewardsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  so5RewardIds: [ID!]!
}
"Autogenerated input type of completeOnboardingTask"
input completeOnboardingTaskInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  task: OnboardingTaskEnum!
}
"Autogenerated input type of confirmDevice"
input confirmDeviceInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  token: String!
}
"Autogenerated input type of confirmEmail"
input confirmEmailInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  token: String!
}
"Autogenerated input type of confirmSo5Lineups"
input confirmSo5LineupsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  so5LeagueIds: [ID!]
  so5LineupIds: [ID!]
}
"Autogenerated input type of confirmSo5NoCardLineup"
input confirmSo5NoCardLineupInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  so5LeaderboardId: ID!
  so5NoCardLineupId: ID!
}
"Autogenerated input type of consumeCardBooster"
input consumeCardBoosterInput {
  cardId: ID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  userShopItemId: ID!
}
"Autogenerated input type of consumeEphemeralToken"
input consumeEphemeralTokenInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  token: String!
}
"Autogenerated input type of consumeRecoveryKit"
input consumeRecoveryKitInput {
  cardId: ID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  fullRecover: Boolean!
}
"Autogenerated input type of createCardAuthorization"
input createCardAuthorizationInput {
  authorizationId: String!
  browserInfo: BrowserInfoInput!
  cardId: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of createCardDeposit"
input createCardDepositInput {
  amount: Int!
  browserInfo: BrowserInfoInput!
  cardId: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  saveCard: Boolean!
}
"Autogenerated input type of createCardRegistration"
input createCardRegistrationInput {
  cardType: CreditCardType
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of createCardWithdrawal"
input createCardWithdrawalInput {
  assetId: String
  cardSlug: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  destination: String!
  "List of signed LimitOrder objects."
  starkSignatures: [StarkSignatureInput!]!
}
"Autogenerated input type of createCommonDraftSwap"
input createCommonDraftSwapInput {
  cardOutSlugs: [String!]!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  commonDraftCampaignSlug: String!
  printablePlayerInIds: [ID!]!
  so5LeaderboardSlug: String!
}
"Autogenerated input type of createCustomDeck"
input createCustomDeckInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  name: String!
  visible: Boolean!
}
"Autogenerated input type of createDepositBankAccountMutation"
input createDepositBankAccountMutationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of createDirectOffer"
input createDirectOfferInput {
  approvals: [AuthorizationApprovalInput!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  counteredOfferId: String
  "ID used as unique deal identifier. Consider using `crypto.getRandomValues(new Uint32Array(4)).join()` to generate one."
  dealId: String!
  """
  Number of seconds this offer should be valid. Will be rounded to
                                     86400 (1 day) if given a lower value.
  """
  duration: Int
  migrationData: OfferMigrationInput
  "Amount to receive and its currency. if set, must be one of the proposer wallet currencies."
  receiveAmount: AmountInput
  receiveAssetIds: [String!]
  receiveWeiAmount: WeiAmount
  receiverSlug: String!
  "Amount to send and its currency. If set, must be one of the proposer wallet currencies."
  sendAmount: AmountInput
  sendAssetIds: [String!]
  sendWeiAmount: WeiAmount
}
"Autogenerated input type of createDraftAndSo5Lineup"
input createDraftAndSo5LineupInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  commonDraftCampaignSlug: String!
  printablePlayerIds: [ID!]!
  so5DraftablePlayerAppearances: [So5DraftablePlayerAppearanceInput!]!
  so5LeaderboardId: ID!
}
"Autogenerated input type of createEphemeralLink"
input createEphemeralLinkInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  url: String!
}
"Autogenerated input type of createEthBankWithdrawalIntent"
input createEthBankWithdrawalIntentInput {
  amount: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of createEthDeposit"
input createEthDepositInput {
  "Pending deposit amount, in wei"
  amount: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Transaction hash of the deposit"
  transactionHash: String!
}
"Autogenerated input type of createEthMigration"
input createEthMigrationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  nonce: String!
  signature: String!
  weiAmount: String!
}
"Autogenerated input type of createEthVault"
input createEthVaultInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of createFastWithdrawal"
input createFastWithdrawalInput {
  amount: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  salt: String!
  "List of signed LimitOrder objects."
  starkSignatures: [StarkSignatureInput!]!
  to: String!
}
"Autogenerated input type of createFiatPayer"
input createFiatPayerInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  firstName: String!
  lastName: String!
}
"Autogenerated input type of createFiatWallet"
input createFiatWalletInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  countryOfResidenceCode: String!
  currency: FiatCurrency!
  dob: ISO8601Date!
  firstName: String!
  lastName: String!
  mangopayTermsAndConditionsAccepted: Boolean!
  nationalityCode: String!
}
"Autogenerated input type of createFiatWithdrawal"
input createFiatWithdrawalInput {
  "Amount to withdraw and its currency"
  amounts: AmountInput!
  bankAccountId: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of createIdentityVerificationSession"
input createIdentityVerificationSessionInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  userIdentityVerificationId: String!
}
"Autogenerated input type of createOrUpdateSingleBuyOfferMinPrice"
input createOrUpdateSingleBuyOfferMinPriceInput {
  amount: String
  assetId: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  isPrivate: Boolean!
  "Min price to set and its currency."
  minPrice: AmountInput
}
"Autogenerated input type of createOrUpdateSo5Lineup"
input createOrUpdateSo5LineupInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  draft: Boolean = false
  name: String
  so5Appearances: [So5AppearanceInput!]!
  so5LeaderboardId: ID!
  so5LineupId: ID
}
"Autogenerated input type of createSingleBuyOffer"
input createSingleBuyOfferInput {
  assetId: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID used as unique deal identifier. Consider using `crypto.getRandomValues(new Uint32Array(4)).join()` to generate one."
  dealId: String!
  price: WeiAmount!
  "List of signed LimitOrder objects."
  starkSignatures: [StarkSignatureInput!]!
}
"Autogenerated input type of createSingleSaleOffer"
input createSingleSaleOfferInput {
  approvals: [AuthorizationApprovalInput!]
  assetId: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID used as unique deal identifier. Consider using `crypto.getRandomValues(new Uint32Array(4)).join()` to generate one."
  dealId: String!
  "Number of seconds this offer should be valid"
  duration: Int
  migrationData: OfferMigrationInput
  price: WeiAmount
  "Reference amount to receive and its currency. Must be one of the settlement currencies."
  receiveAmount: AmountInput
  """
  List of accepted currencies. Must match the proposer wallet currencies (e.g:
  you cannot receive fiat without a fiat wallet).
  """
  settlementCurrencies: [SupportedCurrency!]
  startDate: ISO8601DateTime
}
"Autogenerated input type of createSo5UserGroup"
input createSo5UserGroupInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  description: String
  displayName: String!
  endGameWeek: Int
  logoId: ID
  so5LeaderboardType: So5LeaderboardType
  startGameWeek: Int
}
"Autogenerated input type of createSubscription"
input createSubscriptionInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  interactionContext: String
  subscribable: SubscribableInput!
}
"Autogenerated input type of createWallet"
input createWalletInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  passwordHash: String!
  wallet: WalletInput!
}
"Autogenerated input type of createWireTransferDeposit"
input createWireTransferDepositInput {
  "Amount to deposit and its currency"
  amounts: AmountInput!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of createWithdrawalBankAccount"
input createWithdrawalBankAccountInput {
  accountIdentifier: String!
  bankAccountType: BankAccountType!
  bankIdentifier: String!
  bankName: String
  branchCode: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  countryCode: String!
  ownerAddress: BankAccountOwnerAddressInput!
  ownerName: String!
}
"Autogenerated input type of createWithdrawal"
input createWithdrawalInput {
  agreedFeeAmount: String
  amount: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  dealId: String!
  signature: String!
  to: String!
}
"Autogenerated input type of deactivateWalletRecovery"
input deactivateWalletRecoveryInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  destination: String!
  method: PrivateKeyRecoveryOptionMethodEnum!
}
"Autogenerated input type of declareFootballManagerTask"
input declareFootballManagerTaskInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  footballManagerTaskId: ID!
}
"Autogenerated input type of declineSo5NoCardLineup"
input declineSo5NoCardLineupInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  so5NoCardLineupId: ID!
}
"Autogenerated input type of deleteCustomDeck"
input deleteCustomDeckInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  deckSlug: String!
}
"Autogenerated input type of deletePostalAddress"
input deletePostalAddressInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of deleteSo5Lineup"
input deleteSo5LineupInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  so5LineupId: ID!
}
"Autogenerated input type of deleteSo5UserGroup"
input deleteSo5UserGroupInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  so5UserGroupId: ID!
}
"Autogenerated input type of deleteSubscription"
input deleteSubscriptionInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  slug: String!
}
"Autogenerated input type of deleteUserSo5Lineups"
input deleteUserSo5LineupsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  so5LeagueIds: [ID!]
}
"Autogenerated input type of destroyAccount"
input destroyAccountInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  password: String!
}
"Autogenerated input type of destroyReferral"
input destroyReferralInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  referralId: ID!
}
"Autogenerated input type of detachPaymentMethod"
input detachPaymentMethodInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  paymentMethod: String!
  provider: PaymentMethodProvider
}
"Autogenerated input type of disable2fa"
input disable2faInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  otpAttempt: String!
  password: String!
}
"Autogenerated input type of disconnectOmniauthProvider"
input disconnectOmniauthProviderInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  email: String
  provider: String!
}
"Autogenerated input type of editCardInDeck"
input editCardInDeckInput {
  cardSlug: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  deckSlug: String!
  newIndex: Int!
}
"Autogenerated input type of editCustomDeck"
input editCustomDeckInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  deckSlug: String!
  name: String!
  newIndex: Int
  visible: Boolean!
}
input EligibleCardsSort {
  direction: SortingOption!
  type: AveragePlayerScore!
}
"Autogenerated input type of enable2fa"
input enable2faInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  otpAttempt: String!
}
"Autogenerated input type of fetchEncryptedPrivateKey"
input fetchEncryptedPrivateKeyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  otpAttempt: String
}
"A Football: HeadToHead Appearance input"
input FootballHeadToHeadAppearanceInput {
  captain: Boolean!
  draftableObjectId: ID!
}
"Autogenerated input type of footballHeadToHeadAppearanceSubstitute"
input footballHeadToHeadAppearanceSubstituteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  newAppearance: FootballHeadToHeadAppearanceInput!
  previousAppearanceId: ID!
}
"Autogenerated input type of footballHeadToHeadArenaRequestCreate"
input footballHeadToHeadArenaRequestCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  lineupId: ID!
}
"Autogenerated input type of footballHeadToHeadInviteAccept"
input footballHeadToHeadInviteAcceptInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  inviteId: ID!
}
"Autogenerated input type of footballHeadToHeadInviteCreate"
input footballHeadToHeadInviteCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  gameId: ID!
  managerId: ID!
}
"Autogenerated input type of footballHeadToHeadLineupUpsert"
input footballHeadToHeadLineupUpsertInput {
  appearances: [FootballHeadToHeadAppearanceInput!]!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  gameId: ID!
  tactic: LineupTacticType!
}
"Autogenerated input type of footballSorareDailyAppearanceSubstitute"
input footballSorareDailyAppearanceSubstituteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  newAppearance: SorareDailyAppearanceInput!
  previousAppearanceId: ID!
}
"Autogenerated input type of footballSorareDailyClanCreate"
input footballSorareDailyClanCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  displayName: String!
}
"Autogenerated input type of footballSorareDailyClanJoin"
input footballSorareDailyClanJoinInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  joinSecret: String!
}
"Autogenerated input type of footballSorareDailyClanLeave"
input footballSorareDailyClanLeaveInput {
  clanId: ID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of footballSorareDailyLineupCreate"
input footballSorareDailyLineupCreateInput {
  appearances: [SorareDailyAppearanceInput!]!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  gameId: ID!
}
"Autogenerated input type of footballSorareDailyManagerClaimDailyCoins"
input footballSorareDailyManagerClaimDailyCoinsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of footballSorareDailyPackPurchase"
input footballSorareDailyPackPurchaseInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  packSlug: String!
}
"Autogenerated input type of footballSorareDailyReact"
input footballSorareDailyReactInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  emoji: String!
  lineupId: ID!
}
"Autogenerated input type of footballSorareDailyRewardClaim"
input footballSorareDailyRewardClaimInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  rewardId: ID!
}
"Autogenerated input type of footballSorareDailyRewardsClaim"
input footballSorareDailyRewardsClaimInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  lineupId: ID!
}
"Autogenerated input type of footballSorareDailySquadCreate"
input footballSorareDailySquadCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  gameId: ID!
}
"Autogenerated input type of footballSorareDailySquadJoin"
input footballSorareDailySquadJoinInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  joinSecret: String!
}
"Autogenerated input type of footballSorareDailySquadLeave"
input footballSorareDailySquadLeaveInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  squadId: ID!
}
"Autogenerated input type of generateAccountingExtract"
input generateAccountingExtractInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of generateActionRewardPickablePlayers"
input generateActionRewardPickablePlayersInput {
  actionRewardId: ID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of generateOtpBackupCodes"
input generateOtpBackupCodesInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  otpAttempt: String = null
}
"Autogenerated input type of generateSo5NoCardLineup"
input generateSo5NoCardLineupInput {
  accessToken: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  proofOfResidency: File
  recaptchaToken: String
  recaptchaTokenV2: String
  so5FixtureId: ID!
}
"Autogenerated input type of joinSo5UserGroup"
input joinSo5UserGroupInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  joinSecret: String!
}
"Autogenerated input type of linkEthereumAddress"
input linkEthereumAddressInput {
  address: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  signature: String!
}
input MangopayWalletTransferApprovalInput {
  nonce: Int!
  signature: StarkwareSignatureInput!
}
"A marketplace preference"
input MarketplacePreferenceInput {
  name: String!
  sports: [Sport!]!
  value: Json!
}
"Autogenerated input type of markNotificationsAsRead"
input markNotificationsAsReadInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  notificationId: String
  notificationIds: [String!]
}
input NBACardsInput {
  ids: [UUID!]
  assetIds: [ID!]
}
input NBACompleteOnboardingTaskInput {
  task: NBAOnboardingTask!
  selectedCardPlayerId: UUID
}
input NBACreateOrUpdateLineupInput {
  lineupId: UUID
  leaderboardSlug: String!
  cardSlugs: [String!]!
}
input NBADeleteLineupInput {
  lineupId: UUID!
}
"A notification filter"
input NotificationCategoryInput {
  name: String!
  type: String!
}
"A notification preference"
input NotificationPreferenceInput {
  name: String!
  "Sport whose notification settings is to be updated.If unset will be applied to all sports."
  sport: Sport
  value: Json!
}
"An object including all arguments to migrate an offer"
input OfferMigrationInput {
  expirationBlock: Int!
  migrateInternalCardsSignature: String
  migrateMappedCardsSignature: String
}
input OperationInput {
  name: String!
  path: String!
  timeMs: Int!
}
input PasswordEncryptedPrivateKeyInput {
  iv: String!
  payload: String!
  salt: String!
}
"Autogenerated input type of pickActionRewardPlayers"
input pickActionRewardPlayersInput {
  actionRewardId: ID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  playerSlugs: [String!]!
}
input PlayerOwnershipFilter {
  rarity: CardRarity!
  filterType: PlayerOwnershipFilterType!
}
input PostalAddressInput {
  additionalAddress: String
  city: String!
  company: String
  countryCode: String!
  firstName: String
  lastName: String
  streetAddress: String!
  zipcode: String!
}
"Autogenerated input type of prepareAcceptOffer"
input prepareAcceptOfferInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the Offer or PrimaryOffer to accept."
  offerId: ID
  settlementInfo: AcceptorSettlementInfoInput
}
"Autogenerated input type of prepareBid"
input prepareBidInput {
  amount: String
  "Global ID of the english auction to bid on"
  auctionId: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  englishAuctionId: String
  settlementInfo: AcceptorSettlementInfoInput
}
"Autogenerated input type of prepareCardWithdrawal"
input prepareCardWithdrawalInput {
  assetId: String
  cardSlug: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  destination: String
}
"Autogenerated input type of prepareEthDeposit"
input prepareEthDepositInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  weiAmount: WeiAmount!
}
"Autogenerated input type of prepareFastWithdrawal"
input prepareFastWithdrawalInput {
  "Amount to withdraw, in wei."
  amount: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Destination Ethereum address."
  to: String!
}
"Autogenerated input type of prepareOffer"
input prepareOfferInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Amount to receive and its currency. Must be one of the settlement currencies."
  receiveAmount: AmountInput
  receiveAssetIds: [String!]!
  receiveWeiAmount: WeiAmount
  receiverSlug: String
  "Amount to send and its currency. Must be one of the settlement currencies."
  sendAmount: AmountInput
  sendAssetIds: [String!]!
  sendWeiAmount: WeiAmount
  """
  List of accepted currencies. Must match the proposer wallet currencies (e.g:
  you cannot receive fiat without a fiat wallet).
  """
  settlementCurrencies: [SupportedCurrency!]
  type: OfferType
}
"Autogenerated input type of prepareTokenDeposit"
input prepareTokenDepositInput {
  assetId: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
input PrivateKeyRecoveryInput {
  appId: String!
  email: String
  encryptionKey: String!
  iv: String!
  payload: String!
  phone: String
  teamId: String!
}
input RangeInput {
  max: Int
  min: Int
}
"Autogenerated input type of refreshAward"
input refreshAwardInput {
  award: Award!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of rejectOffer"
input rejectOfferInput {
  block: Boolean
  blockchainId: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of relayCall"
input relayCallInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  encodedFunction: String!
  extraGas: Int!
  signature: String!
}
"Autogenerated input type of removeCardFromDeck"
input removeCardFromDeckInput {
  cardSlug: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  deckSlug: String!
}
"Autogenerated input type of removeUserFromSo5UserGroup"
input removeUserFromSo5UserGroupInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  so5UserGroupId: String!
  userId: String!
}
"Autogenerated input type of reportTelemetry"
input reportTelemetryInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  operations: [OperationInput!]!
}
"Autogenerated input type of requestReceipt"
input requestReceiptInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  paymentId: ID!
}
"Autogenerated input type of requestSo5NoCardLineupEligibleLeaderboards"
input requestSo5NoCardLineupEligibleLeaderboardsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  so5NoCardLineupId: ID!
}
"Autogenerated input type of resendConfirmationInstructions"
input resendConfirmationInstructionsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  recaptchaToken: String
  recaptchaTokenV2: String
}
"Autogenerated input type of resendVerificationCode"
input resendVerificationCodeInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  reference: String!
}
"Autogenerated input type of resetPrivateKey"
input resetPrivateKeyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  starkKey: String
}
"Autogenerated input type of restoreWallet"
input restoreWalletInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  passwordEncryptedPrivateKey: PasswordEncryptedPrivateKeyInput!
  passwordHash: String!
}
"Autogenerated input type of resumeOnboarding"
input resumeOnboardingInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of revokeDevice"
input revokeDeviceInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  deviceId: String!
}
"Autogenerated input type of revokeOAuthAccessToken"
input revokeOAuthAccessTokenInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  id: String!
}
"Autogenerated input type of sendWalletRecovery"
input sendWalletRecoveryInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  destination: String!
  method: PrivateKeyRecoveryOptionMethodEnum!
}
"Autogenerated input type of setDeviceToken"
input setDeviceTokenInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  devicePlatform: String!
  deviceToken: String!
  disable: Boolean = false
}
"Autogenerated input type of setLiveActivityToken"
input setLiveActivityTokenInput {
  activityToken: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  devicePlatform: String!
  "Should be passed to true to remove the token"
  disable: Boolean = false
  topicId: String!
  topicType: LiveActivity!
}
input ShopItemsSortInput {
  direction: SortingOption!
  type: ShopItemsSorting!
}
"Autogenerated input type of signIn"
input signInInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  deviceFingerprint: String
  email: String
  gaClientId: String
  impactClickId: String
  otpAttempt: String
  otpSessionChallenge: String
  password: String
}
"Autogenerated input type of signInWithOAuth"
input signInWithOAuthInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  idToken: String!
  provider: OAuthProvider!
}
"Autogenerated input type of signOutFromAllDevices"
input signOutFromAllDevicesInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of signUp"
input signUpInput {
  acceptAgeLimit: Boolean
  acceptGameRules: Boolean
  acceptPrivacyPolicy: Boolean
  acceptTerms: Boolean
  agreedToReceiveOffersFromPartners: Boolean
  agreedToReceiveOffersFromPartnersSpecific: [String!]
  certified: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  email: String!
  "The path the new User is from (to be used to redirect him after email confirmation)"
  fromPath: String
  gaClientId: String
  impactClickId: String
  nickname: String!
  password: String!
  promoCode: String
  recaptchaToken: String
  recaptchaTokenV2: String
  referrer: String
  signupPlatform: SignupPlatform
  sorareAddress: String
  sorarePrivateKey: SorarePrivateKeyAttributes
  sorarePrivateKeyBackup: String
  starkKey: String
  utmParams: UtmInput
  wallet: WalletInput!
}
"Autogenerated input type of skipOnboarding"
input skipOnboardingInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"A SO5 Appearance - a card selected in a team for a SO5 fixture"
input So5AppearanceInput {
  captain: Boolean!
  cardSlug: String!
}
"A SO5 Draftable Player Appearance - a player selected in a common draft campaign for a SO5 fixture"
input So5DraftablePlayerAppearanceInput {
  captain: Boolean!
  draftablePlayerId: ID!
}
"A Football: SorareDaily Appearance input"
input SorareDailyAppearanceInput {
  captain: Boolean!
  draftableObjectId: ID!
}
"An encrypted private key"
input SorarePrivateKeyAttributes {
  encryptedPrivateKey: String!
  iv: String!
  salt: String!
}
input StarkexApprovalInput {
  expirationTimestamp: Int!
  nonce: Int!
  signature: StarkwareSignatureInput!
}
input StarkSignatureInput {
  "Signature of the associated LimitOrder object, transported as JSON. Computed with `@sorare/crypto`."
  data: String!
  "Mandatory if expirationTimestamp is not set"
  expiration: ISO8601DateTime
  "Required if expiration is not set"
  expirationTimestamp: Int
  "Nonce of the associated LimitOrder object. Retrieved through the `limitOrders` field."
  nonce: Int!
  starkKey: String
}
input StarkwareSignatureInput {
  r: String!
  s: String!
}
"Autogenerated input type of startOnboarding"
input startOnboardingInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of stopAutoBid"
input stopAutoBidInput {
  bidId: ID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
input SubscribableInput {
  slug: String!
  type: String!
}
"Autogenerated input type of UnblockEmail"
input UnblockEmailInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of unblockUserOffers"
input unblockUserOffersInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  userSlug: String!
}
"Autogenerated input type of updateCardFilters"
input updateCardFiltersInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  filters: Json!
  sport: Sport!
}
"Autogenerated input type of updateExternalEthDeposit"
input updateExternalEthDepositInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the deposit"
  id: ID!
  "Transaction hash of the deposit to the bridge"
  transactionHash: String!
}
"Autogenerated input type of updateFiatWallet"
input updateFiatWalletInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  dob: ISO8601Date
  firstName: String
  lastName: String
}
"Autogenerated input type of updateHighlightedCard"
input updateHighlightedCardInput {
  cardCollectionCardId: ID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}
"Autogenerated input type of updatePartnerOffersAgreement"
input updatePartnerOffersAgreementInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  partner: String!
  value: Boolean!
}
"Autogenerated input type of updateSo5UserGroup"
input updateSo5UserGroupInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  description: String
  displayName: String
  joinDisabled: Boolean
  logoId: ID
  picture: File
  so5UserGroupId: ID!
}
"Autogenerated input type of updateSubscription"
input updateSubscriptionInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  enabled: Boolean!
  rarities: [String!]!
  slug: String!
}
"Autogenerated input type of updateUserEmail"
input updateUserEmailInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  email: String!
  otpAttempt: String = null
  passwordHash: String
  privateKeyRecovery: PrivateKeyRecoveryInput!
  recaptchaToken: String
  recaptchaTokenV2: String
}
"Autogenerated input type of updateUserProfile"
input updateUserProfileInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  clubBannerId: ID
  clubName: String
  clubShieldId: ID
  enabledWallets: [EnabledWallet!]
  marketplacePreferences: [MarketplacePreferenceInput!]
  nickname: String
  picture: File
  status: String
}
"Autogenerated input type of updateUserSettings"
input updateUserSettingsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  currency: Currency
  fiatCurrency: FiatCurrency
  hideBalance: Boolean
  hideCommonCards: Boolean
  lastWeb3Provider: String
  lifecycle: UserLifecycleInput
  locale: String
  notificationPreference: NotificationPreferenceInput
  postalAddress: PostalAddressInput
  rewardCurrency: Currency
}
"Autogenerated input type of upsertCommonDraft"
input upsertCommonDraftInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  commonDraftCampaignSlug: String!
  dryRun: Boolean = false
  force: Boolean = false
  printablePlayerIds: [ID!]!
  so5LeaderboardSlug: String!
}
"A user lifecycle entry"
input UserLifecycleInput {
  name: String!
  value: Json!
}
"Utm params"
input UtmInput {
  partner: String
  trafficCategory: String
  user: String
  utmCampaign: String
  utmContent: String
  utmMedium: String
  utmSource: String
  utmTerm: String
}
"Autogenerated input type of validateFiatWallet"
input validateFiatWalletInput {
  backPage: File
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  frontPage: File!
}
"Autogenerated input type of verifyPhoneNumber"
input verifyPhoneNumberInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  phoneNumber: String!
}
input WalletInput {
  backupPrivateKeyRecoveries: [BackupPrivateKeyRecoveryInput!]!
  ethereumAddress: String!
  "Temporary until we migrate to the new wallet recovery flow"
  legacyBackupPrivateKeyRecovery: String
  passwordEncryptedPrivateKey: PasswordEncryptedPrivateKeyInput!
  privateKeyRecovery: PrivateKeyRecoveryInput!
  starkKeyWithPrefix: String!
}
directive @defer(label: String, if: Boolean! = true) on FRAGMENT_SPREAD | INLINE_FRAGMENT
"Exposes a URL that specifies the behavior of this scalar."
directive @specifiedBy(
    "The URL that specifies the behavior of this scalar."
    url: String!
  ) on SCALAR
